// -*- C++ -*-
//----------------------------------------------------------------------
//
//                         William S. Klug
//                University of California Los Angeles
//                 (C) 2004-2008 All Rights Reserved
//
//----------------------------------------------------------------------

/*! 
  \file SemiflexibleGel.cc

  \brief SemiflexibleGel is a concrete class derived from Body, implementing
  the concept of a collection of cross-linked semiflexible polymers (i.e., beams)

*/

#if defined(_OPENMP)
#include <omp.h>
#endif

namespace voom {

      
  template<int N>
  SemiflexibleGel<N>::SemiflexibleGel( SemiflexibleInput * input ) {
  

  //////////////////////////////////////////////////////////////////
  // Start by working with adaptive meshing with creation of gel.
  //////////////////////////////////////////////////////////////////
  
  // get rid of two declarations below when they are included in 
  // adaptiveMeshingFlag block
  
  // From old ADAPTIVE MESHING constructor arguments
  bool adaptiveMeshingFlag = input->getBool("adaptiveMeshing");

  if (!adaptiveMeshingFlag) {
    std::cout << "This constructor only does adaptive meshing, you fool!" 
	      << std::endl;
    exit(0);
  }

  double filDens = input->getReal("filDens"); 
  double filLength = input->getReal("L"); // not needed for RETRIEVE
	
		
	
  // ------------------GENERAL SYSTEM PARAMETERS------------------
  bool cutOffEnds = input->getBool("Cut Off Ends"); 
	
  // "minlength" and minLength in nematictest.cc
  // The latter is minimum segment length. Consider changing names.

  // WSK: "Min. length" = "minlength" probably refers to the minimum
  // length of a filament (not of a segment in the discretization).
  // Yes, we should change the name.
	
	
  // Other members from old parameter map
  double kT = input->getReal("kT");
  double kappa = input->getReal("angle stiffness");
  double mu = input->getReal("bond stiffness");
  double visc = input->getReal("viscosity");
  double dt = input->getReal("time step");
	
  // Need to check if values below were entered correctly from input file 
  // otherwise there will be a segmentation fault
	
  double minLength = input->getReal("Min Seg Length");

  // WSK: let's make the input class robust to handle situations when
  // parameters are not assigned values in an input file.  Either yell
  // and give up, or assign ad default parameter.
  //
  double targetSegLength;
  if (input->checkMap("target segment length")) {
    targetSegLength = input->getReal("target segment length");
  }
  else {
    targetSegLength = 2.0*minLength;
  }	
  // if no targetSegLength was entered, set 
  // targetSegLength = 2.0*minLength;
  // This calculation should be performed in the input class?
	
	
  // double check below (only for adaptive?)
  // This isn't needed when retrieving the gel
  std::string storageFileName = input->getString("storage file name");
	

	
	
	
  // ------------------ADAPTIVE MESH PARAMETERS------------------

  // maxPrestress commented out in input file
  // not entirely sure why we multiply by kT
  // double maxPrestress = kT*(input->getReal("maximum prestress"));	
  //
  // WSK: who knows?!	

	
  // ------------------ENTROPIC SPRINGS------------------
  double k_max = -1.0;
  double entropic_k = -1.0;
  double entropic_Lp = -1.0;
  bool linentropic = false;
  double linentfrac = 0.0;
  double linentmult = 1.0;
  // Why are we initializing to -1.0 again? This was done in the input class
  // Is this necessary?
	
	
  // flag for Spring or EntropicSpring
  const std::string bondType = input->getString("bondType");

  if (bondType == "EntropicSpring") {
	
    k_max = input->getReal("k_max");
    entropic_k = input->getReal("Entropic_k");
    entropic_Lp = input->getReal("Entropic_Lp");
    linentropic = input->getBool("Entropic_lin_springs");
		
    if (linentropic) {
      linentfrac = input->getReal("Entropic_lin_stiff_frac");
      linentmult = input->getReal("Entropic_lin_stiff_mult");
    }
  }			
	
	
  ////////////////////////////////////////////////////////////////////////////
  // The section below was already commented out but we need a prestress flag 
  // as well as a relax prestress flag.
  ////////////////////////////////////////////////////////////////////////////
  //     double k_max = -1.0;
  //     double entropic_k = -1.0;
  //     double entropic_Lp = -1.0;
  //     if(bondType == "EntropicSpring") {
  //       p = properties.find("k_max");
  //       if(p!=properties.end()) k_max = atof(p->second.data());
  //       p = properties.find("Entropic_k");
  //       if(p!=properties.end()) entropic_k = atof(p->second.data());
  //       p = properties.find("Entropic_Lp");
  //       if(p!=properties.end()) entropic_Lp = atof(p->second.data());
  //     }

  //bool prestress;
  //std::string prestressStr;
  //p = properties.find("prestress");
  //assert(p != properties.end());
  //prestressStr.assign(p->second);
  //if(prestressStr.find("true") != string::npos) prestress = true;
  //else prestress = false;
  ////////////////////////////////////////////////////////////////////////////
	
	
	
  // ------------------POLYDISPERSITY INPUT------------------	
	
  // There should be a polydispersity flag in the input file so we don't have to
  // assign the variables below unnecessarily. Currently they are initialized
  // even when they are not used.  
	
	
  // Are some of the variables below needed for gel creation regardless of
  // whether or not polydispersity is included? Should verify all are needed. 
  // I think some are used only in certain cases.
	
  bool longshort = false;
  bool exponential = false;
  bool longLinked = false;
  bool longLinStiff = true;
  double lsratio = 1.0; 
  double longStiff = 0.0;
  double longkC = kappa; // why are we reassigning this?
  double lsfrac = 0.0;
  double expmnl = 0.0;
  double expmin = 0.0;
	
	
  // only used in retrieve
  double longCutoff = 0.0;


	
  /*	
	std::map< int, int > filLens; // JKP: Why is this here if it is not used?
	std::string polydispStr;
	bool longshort = false;
	bool exponential = false;
	bool longLinked = false;
	bool longLinStiff = true;
	double lsratio = 1.0; 
	double longStiff = 0.0;
	double longkC = kappa; // why are we reassigning this?
	double lsfrac = 0.0;
	double expmnl = 0.0;
	double expmin = 0.0;
	p = properties.find("polydispersity");
	if(p != properties.end()) {
	polydispStr.assign(p->second);
	if(polydispStr.find("LongShort") != string::npos) {
	longshort = true;
	p = properties.find("longshortratio");
	assert(p != properties.end());
	lsratio = atof(p->second.data());
	p = properties.find("longfraction");
	assert(p != properties.end());
	lsfrac = atof(p->second.data());
	assert(lsfrac <= 1.0);
	p = properties.find("longstiffness");
	assert(p != properties.end());
	longStiff = atof(p->second.data());
	if(longStiff < 1.0e-6) longStiff = 0.0;
	p = properties.find("longlinked");
	if(p != properties.end()) {
	double llink = atof(p->second.data());
	if(llink > 0.5) longLinked = true;
	}
	p = properties.find("longbendstiffness");
	if(p != properties.end()) longkC = atof(p->second.data());
	}
	else if(polydispStr.find("Exponential") != string::npos){
	//insert here for exponential distributed length network
	exponential = true;
	expmnl = filLength;
	p = properties.find("minlength");
	assert(p != properties.end());
	expmin = atof(p->second.data());
	}
	}
  */ 


  // ------------------GEL CREATION----------------------------

  int nFils = 0;
  TempFilamentContainer tmpFils; 
  DefNodeContainer dNodes;
  std::set<int> longFils;
  double nemAngle = 0.0;
  std::string removalMethod;

  // ------------------BEGIN CREATING GEL----------------------
  bool retrieveGelFlag = input->getBool("retrieveGel");
  if (!retrieveGelFlag) {


    // ------------------NEMATIC PDF PARAMETERS------------------
    // NOT in retrieve constructor
    NematicProbTable npt;
    bool donem = false;
	
    double nematic;
    if (input->checkMap("nematic PDF param")) {
      nematic = input->getReal("nematic PDF param");
      donem = true;
    }
		
    std::string orientationPDF = input->getString("orientational PDF");
    if (orientationPDF == "Gaussian") {
      npt.setPDF(0);
      npt.setTable(nematic);
    }
    // need to write "Lorentzian" block in here that is commented out below
	
	

    // p = properties.find("nematic PDF param");
    // 	if(p != properties.end()) {
    // 		nematic = atof(p->second.data());
    // 		donem = true;
    // 		p = properties.find("orientational PDF");
    // 		if(p != properties.end()) {
    // 			if(p->second.find("Lorentzian") != string::npos) {
    // 				orientationPDF = "Lorentzian";
    // 				npt.setPDF(1);
    // 				npt.setTable(nematic);
    // 			}
    // 			else {
    // 				orientationPDF = "Gaussian";
    // 				npt.setPDF(0);
    // 				npt.setTable(nematic);
    // 			}
    // 		}
    // 		else {
    // 			orientationPDF = "Gaussian";
    // 			npt.setPDF(0);
    // 			npt.setTable(nematic);
    // 		}
    // 	p = properties.find("nematic direction angle");
    // 	if(p != properties.end()) nemAngle = atof(p->second.data());
    // 	}
	
    //ranlib::Normal<double> rngps(0,sqrt(kT/kAngle));
    //rngps.seed((unsigned int)time(0));
    ranlib::Uniform<double> rnguni;
    rnguni.seed((unsigned int)time(0));
    ranlib::Exponential<double> rngexp(expmnl-expmin);
    rngexp.seed((unsigned int)time(0));
	
	
    tvmet::Vector<double,2> syssize;
    syssize[0] = input->getReal("Wx");
    syssize[1] = input->getReal("Wy");
	
    std::cout << N << std::endl;
    _box = new LeesEdwards(syssize[0],syssize[1],0.0);
    VectorND size( _box->size() );
    double vol=1.0;
    for(int i=0; i<N; i++) {
      vol *= size[i];
    }
	
    nFils = (int)(filDens*vol);
    VectorND startPos;
    VectorND oldVec;
    VectorND newVec;
    double newAng;

    // TempFilamentContainer tmpFils(nFils); 
    tmpFils.resize(nFils);

    // create first and last points for each filament //

    if(longshort) {
      std::cout << "short filament length = " << filLength << std::endl
		<< "long filament length = " << lsratio*filLength << std::endl;
    }

    ////////////////////////////////////////////////////////////////
    // Copied section below directly from old constructor
    // Added creation of nodes container, which was previously
    // passed in. 
    ////////////////////////////////////////////////////////////////

    std::cout << "Starting gel creation." << std::endl;
    for(int i=0; i<nFils; i++) {
      //rngps.seed((unsigned int)time(0)+i);
      rnguni.seed((unsigned int)time(0)+i);
      rngexp.seed((unsigned int)time(0)+i);
      double curFilLen;
      if(exponential) {
	curFilLen = rngexp.random() + expmin;

      }
      else if(longshort) {
	if(i < lsfrac*nFils) {
	  curFilLen = lsratio*filLength;
	  longFils.insert(i);
	}
	else curFilLen = filLength;
      }
      else curFilLen = filLength;
 
      TempFilament * newFil = new TempFilament();
      
      // randomly choose a starting position for the filament //	
      for(int k=0;k<N;k++) {
	newFil->start(k) = size[k]*(rnguni.random());
      }
      
      // now randomly choose an angle and an ending position //
      if(!donem) {
        newAng = 2.0*M_PI*(rnguni.random());
      }
      else {
        newAng = npt.findAngle(rnguni.random());
	if(rnguni.random() < .5) {
	  newAng = -newAng;
	}
	if(rnguni.random() < .5) {
	  newAng += M_PI;
	}
	newAng += nemAngle;
      }
      newFil->end(0) = curFilLen*cos(newAng) + newFil->start(0);
      newFil->end(1) = curFilLen*sin(newAng) + newFil->start(1);

      // determine whether filament is completely in box, crosses through two zones, or crosses through three zones //
      newFil->filSegs.push_back(pair<VectorND,VectorND>(newFil->start,newFil->end));
      if(!(_box->inside(newFil->end))) {
	VectorND newend(newFil->end);
	_box->mapPoint(newend);
	VectorND newstart;
        newstart = newend - (newFil->end - newFil->start);
	newFil->filSegs.push_back(pair<VectorND,VectorND>(newstart,newend));
	if(newend(0) != newFil->end(0) && newend(1) != newFil->end(1)) {
	  newend = newFil->end;
	  _box->mapPointX(newend);
	  newstart = newend - (newFil->end - newFil->start);
	  newFil->filSegs.push_back(pair<VectorND,VectorND>(newstart,newend));
	  newend = newFil->end;
	  _box->mapPointY(newend);
	  newstart = newend - (newFil->end - newFil->start);
	  newFil->filSegs.push_back(pair<VectorND,VectorND>(newstart,newend));
	}
      }

      // now look at existing filaments and find crosslink points //
      for(int j=0; j<i; j++) {
	if(longLinked==true || (longFils.find(i)==longFils.end() || longFils.find(j)==longFils.end())) {
	  TempFilament * oldFil = tmpFils[j];
	  double oldFilLen = norm2((oldFil->end)-(oldFil->start));
	  VectorND diff;
	  diff = .5*((oldFil->end)+(oldFil->start)) - .5*(newFil->end+newFil->start);
	  _box->mapDistance(diff);
	  if(norm2(diff) <= .5*(oldFilLen+curFilLen)) {
	    VectorND intersect;
	    typename vector< pair< VectorND,VectorND > >::iterator oldFilImgs = oldFil->filSegs.begin();
	    bool connected = false;
	    while(!connected && oldFilImgs!=oldFil->filSegs.end()) {
	      typename vector< pair<VectorND,VectorND> >::iterator newFilImgs = newFil->filSegs.begin();
	      while(!connected && newFilImgs!=newFil->filSegs.end()) {
		bool checkConnect = IntersectionFinder<N>::checkIntersection(newFilImgs->first,newFilImgs->second,oldFilImgs->first,oldFilImgs->second,intersect);
		if(checkConnect) {
		  connected = true;
		  VectorND cldist;
		  cldist = intersect - newFilImgs->first;
		  //_box->mapDistance(cldist);
		  double distFromStart = norm2(cldist);
		  cldist += newFil->filSegs[0].first;
		  TempCrosslink* tmpCL = new TempCrosslink();
		  tmpCL->baseFil = j;
		  tmpCL->active = true;
		  //tmpCL->location = intersect;
		  //tmpCL->otherFils.insert(i);
		  //tmpCL->otherFils.insert(j);
		  tmpCL->otherFils.insert(pair< int, VectorND >(i,cldist));
		  newFil->crossFils.insert(pair<double,TempCrosslink *>(distFromStart,tmpCL));
		  cldist = intersect - oldFilImgs->first;
		  //_box->mapDistance(cldist);
		  distFromStart = norm2(cldist);
		  cldist += oldFil->filSegs[0].first;
		  tmpCL->otherFils.insert(pair< int, VectorND >(j,cldist));
		  oldFil->crossFils.insert(pair<double,TempCrosslink *>(distFromStart,tmpCL));
		}
		newFilImgs++;
	      }
	      oldFilImgs++;
	    }
	  }
	}
      }
      tmpFils[i] = newFil;
    }

    // now iterate along each filament and find (and remove) too-short segments //

    removalMethod = input->getString("nearby pair removal method");
    if (removalMethod != "Stretch" &&
	removalMethod != "Delete" &&
	removalMethod != "Collapse" ) {
      std::cout << "Removal method must be Stretch, Delete or Collapse." 
		<< std::endl;
      exit(0);
    }


    if(removalMethod == "Delete") {
      int deletedCrosslinks = 0;
      deletedCrosslinks = removeCrosslinks(tmpFils,minLength);
      std::cout << "Removed " << deletedCrosslinks << " crosslinks from gel to avoid excessively stiff segments." << std::endl;
    }

    else if(removalMethod == "Collapse") {
      int collapsedCrosslinks = collapseCrosslinks(tmpFils,minLength);
      std::cout << "Collapsed " << collapsedCrosslinks << " crosslinks to avoid excessively stiff segments." << std::endl;
    }

    storeSparseGel(storageFileName,tmpFils);
	
  }
  // ------------------END OF CREATE GEL------------------


  // ------------------RETRIEVE GEL------------------
  // Should do else if

  // -------------- beginning of stuff specific to retrieval --------------

  else { // if (retrieveGelFlag)
    std::string fileName = input->getString("storage file name");
    // JKP: need nodes container 
    // This can probably be created outside since it is in both retrieve and 
    // create portions
    // DefNodeContainer dNodes;
	



	
    // double nemAngle = 0.0; // this is also in gel creation
    if (input->checkMap("nematic direction angle")) {
      nemAngle = input->getReal("nematic direction angle");
    }
	
    int intSize = sizeof(int);
    int doubleSize = sizeof(double);
	
	
    // open the file at the end to get size //
    std::ifstream inFile(fileName.data(), ios::in | ios::binary | ios::ate);
    ifstream::pos_type fsize = inFile.tellg();

    // reset file to beginning //
    inFile.seekg(0,ios::beg);
    
    // read in system size and set up PeriodicBox //
    VectorND sysSize;
    for(int i=0; i<N; i++) {
      double curSS;
      inFile.read((char *)(&curSS),doubleSize);
      sysSize[i] = curSS;
    }

    _box = new LeesEdwards(sysSize[0],sysSize[1],0.0);
    //box->setShear(0.0);
  
    // read in # of filaments
    // int nFils;
    inFile.read((char *)(&nFils),intSize);
    // TempFilamentContainer tmpFils(nFils);
    tmpFils.resize(nFils);
    // std::set<int> longFils;
    for(int i=0; i<nFils; i++) {
      VectorND start;
      VectorND end;
      for(int j=0; j<N; j++) {
	double curp;
	inFile.read((char *)(&curp),doubleSize);
	start[j] = curp;
      } 
      for(int j=0; j<N; j++) {
	double curp;
	inFile.read((char *)(&curp),doubleSize);
	end[j] = curp;
      }
      TempFilament* tf = new TempFilament();
      tf->start = start;
      tf->end = end;
      tmpFils[i] = tf;

      VectorND sep;
      sep = end - start;
      double fLen = norm2(sep);
      if(fLen > longCutoff) longFils.insert(i); 
    }
    int nCLs;
    inFile.read((char *)(&nCLs),intSize);
    for(int i=0; i<nCLs; i++) {
      TempCrosslink* cl = new TempCrosslink();
      cl->active = true;
      int nCLsHere;
      inFile.read((char *)(&nCLsHere),intSize);
      for(int nc=0; nc<nCLsHere; nc++) {
	int filnum;
	inFile.read((char *)(&filnum),intSize);
	VectorND cllocalpos;
	for(int j=0; j<N; j++) {
	  double curp;
	  inFile.read((char *)(&curp),doubleSize);
	  cllocalpos[j] = curp;
	}
	cl->otherFils.insert(pair< int, VectorND >(filnum,cllocalpos));
      }
      typename map< int, VectorND >::iterator cfs = cl->otherFils.begin();
      cl->baseFil = cfs->first;
      //VectorND loc;
      //for(int j=0; j<N; j++) {
      //double curp;
      //inFile.read((char *)(&curp),doubleSize);
      //loc[j] = curp;
      //}
      //cl->location = loc;
      for(cfs; cfs!=cl->otherFils.end(); cfs++) {
	VectorND start1;
	start1 = tmpFils[cfs->first]->start;
	VectorND sep1;
	sep1 = cfs->second - start1;
	//_box->mapDistance(sep1);
	double dist1;
	dist1 = norm2(sep1);		
	tmpFils[cfs->first]->crossFils.insert(pair<double,TempCrosslink*>
					      (dist1,cl));
      }
    }

    inFile.close();
    std::cout << "Finished reading data on " << nFils << " filaments and " 
	      << nCLs << " crosslinks from file " << fileName << "; creating gel." 
	      << std::endl;
  }
  // -------------- end of stuff specific to retrieval --------------


  // we now have a list of crosslinks for each filament; we can now
  // create the gel
  int id = 0;
  NodeBase::DofIndexMap idx(N);
  DefNode * newNode;	
  double curPct = .1;
  for(int k=0; k<nFils; k++) {
    DefNodeContainer tmpDNC;
    TempFilament * curFil = tmpFils[k];
    int nCLs = curFil->crossFils.size();
    typename multimap<double,TempCrosslink*>::iterator clIter = curFil->crossFils.begin();
    int i = 0;
    VectorND segStart;
    segStart = curFil->start;

    // create first node //
    for(int m=0; m<N; m++) {
      idx[m] = N*id + m;
    }
    newNode = new BrownianNode<N>(id,idx,segStart,segStart);
    newNode->setId(id);
    tmpDNC.push_back(newNode);
    dNodes.push_back(newNode);
    id++;

    // create nodes between start and first crosslink and between all crosslink pairs //
    for(clIter; clIter!=curFil->crossFils.end(); clIter++) {
      if(clIter->second->active) {
	VectorND sep;
	sep = clIter->second->otherFils[k] - segStart;
	//_box->mapDistance(sep);
	double dist = norm2(sep);
	int nNodesBetween;
	if(targetSegLength > 0.0) {
	  nNodesBetween = (int)(std::floor((dist/targetSegLength)) -.5);
	}
	else {
	  if(dist > 2.0*minLength) {
	    int tmpNNB = (int)(std::floor((dist/fabs(targetSegLength))) -.5);
	    nNodesBetween = max(1,tmpNNB);
	  }
	  else nNodesBetween = 0;
	}
	double segLength = dist/(nNodesBetween+1.0);
	for(int nn=1; nn<=nNodesBetween; nn++) {
	  for(int m=0; m<N; m++) {
	    idx[m] = N*id + m;
	  }
	  VectorND nodePos;
	  nodePos = segStart + nn*sep*(segLength/dist);
	  newNode = new BrownianNode<N>(id,idx,nodePos,nodePos);
	  newNode->setId(id);
	  tmpDNC.push_back(newNode);
	  dNodes.push_back(newNode);
	  id++;
	}
	if(k == clIter->second->baseFil) {
	  for(int m=0; m<N; m++) {
	    idx[m] = N*id + m;
	  }
	  VectorND nodePos;
	  nodePos = segStart + sep;
	  newNode = new BrownianNode<N>(id,idx,nodePos,nodePos);
	  newNode->setId(id);
	  tmpDNC.push_back(newNode);
	  dNodes.push_back(newNode);
	  id++;
	  clIter->second->clNode = newNode;
	  //_crosslinkNodes.insert(newNode);
	  _crossNodeMap.insert(pair<DefNode*,DefNode*>(newNode,newNode));
	  PeriodicTie<N> * newTie = new PeriodicTie<N>(newNode,_box);
	  addConstraint(newTie);
	  clIter->second->ptie = newTie;
	  int nSlaves = clIter->second->otherFils.size() - 1;
	  _nSlavesMap.insert(pair<DefNode*,int>(newNode,nSlaves));
	}
	else {
	  //newNode = clIter->second->clNode;
	  //tmpDNC.push_back(newNode);
	  //for(int m=0; m<N; m++) {
	  //  idx[m] = N*id + m;
	  //}
	  DefNode* mastNode = clIter->second->clNode;
	  VectorND nodePos;
	  nodePos = segStart + sep;
	  newNode = new BrownianNode<N>(mastNode->id(),mastNode->index(),nodePos,nodePos);
	  newNode->setId(mastNode->id());
	  tmpDNC.push_back(newNode);
	  //dNodes.push_back(newNode);
	  //id++;
	  //_crosslinkNodes.insert(newNode);
	  _crossNodeMap.insert(pair<DefNode*,DefNode*>(newNode,mastNode));
	  PeriodicTie<N> * pt = clIter->second->ptie;
	  pt->addSlave(newNode);

	}
	  
	segStart += sep;
      }
    }

    // create nodes between last crosslink and end //	
    VectorND sep;
    sep = curFil->end - segStart;
    //_box->mapDistance(sep);
    double dist = norm2(sep);
    int nNodesBetween;
    if(targetSegLength > 0.0) {
      nNodesBetween = (int)(std::floor((dist/targetSegLength)) -.5);
    }
    else {
      if(dist > 2.0*minLength) {
	int tmpNNB = (int)(std::floor((dist/fabs(targetSegLength))) -.5);
	nNodesBetween = max(1,tmpNNB);
      }
      else nNodesBetween = 0;
    }
    double segLength = dist/(nNodesBetween+1.0);
    for(int nn=1; nn<=nNodesBetween+1; nn++) {
      for(int m=0; m<N; m++) {
	idx[m] = N*id + m;
      }
      VectorND nodePos;
      nodePos = segStart + nn*sep*(segLength/dist);
      newNode = new BrownianNode<N>(id,idx,nodePos,nodePos);
      newNode->setId(id);
      tmpDNC.push_back(newNode);
      dNodes.push_back(newNode);
      id++;
    }

    if(longFils.find(k) != longFils.end()) {
      if(bondType == "Spring" || longLinStiff) {
	addFilament(tmpDNC,longkC,longStiff,visc,kT,dt,minLength);
      }
      else {

	addFilament(tmpDNC,entropic_k,longkC,entropic_Lp,visc,kT,dt,k_max,longStiff);
      }
    }
    else {
      if(bondType == "Spring") {
	addFilament(tmpDNC,kappa,mu,visc,kT,dt,minLength); 
      }
      else {
	addFilament(tmpDNC,entropic_k,kappa,entropic_Lp,visc,kT,dt,k_max,mu);
      }
    }

    if(((double)(k))/((double)(nFils)) > curPct) {
      std::cout << "Created " << 100.0*curPct << " percent of filaments." << std::endl;
      curPct += .1;
    }

  }

  // now that gel is set up, compute various quantities //
    
  computeCrossDistro(-1.0);

  computeFilLenDistro();

  computeNematicDistro(nemAngle);

  if(cutOffEnds) cutOffEndsandCCD(-1.0,dNodes);

  _viscReg = 0;

  _output = paraview;

  for(int fn=0; fn<nFils; fn++) {
    for(typename multimap<double,TempCrosslink*>::iterator cli = tmpFils[fn]->crossFils.begin(); cli!=tmpFils[fn]->crossFils.end(); cli++) {
      if(cli->second->baseFil == fn) {
	TempCrosslink* tmpcl = cli->second;
	delete tmpcl;
      }  
    }	
    delete tmpFils[fn];
  }

  if(removalMethod!= "Collapse") {
    for(typename map<DefNode*,int>::iterator sn=_nSlavesMap.begin(); sn!=_nSlavesMap.end(); sn++) {
      if(sn->second != 1) std::cerr << "Error: nodes pinned incorrectly!" << std::endl;
    }
  }

  //else printCLFilDist();

  //printInitialBends();

  if(linentropic) {
    stiffenRandomSegments(linentfrac,linentmult);
  }

  int nAngleSprings = 0;
  int nBonds = 0;
  int nRods = 0;
  for(FilamentIterator fi=_filaments.begin(); fi!=_filaments.end(); fi++) {
    nAngleSprings += (*fi)->angles.size();
    nBonds += (*fi)->bonds.size();
    nRods += (*fi)->rods.size();
  }
    
  std::cout << "Set up gel with " 
	    << nFils << " filaments, " 
	    << nAngleSprings << " angle springs, "
	    << nBonds << " bonds, and "
	    << nRods << " brownian rods."
	    << std::endl;
	
	
  // ------------------TESTING PARAMETERS------------------
	
  // ------------------VTK/OTHERS------------------
	
	
	
	
	
	
  std::cout << "\n" << std::endl;
  std::cout << "-----Properties from _pm---" << std::endl;
  std::cout << "Filament Density: " << filDens << std::endl;
  std::cout << "Fil Len: " << filLength << std::endl;
  std::cout << "Bond type: " << bondType << std::endl;				
  std::cout << "Cut off ends: " << cutOffEnds << std::endl;
  std::cout << "Min seg Length: " << minLength << std::endl;
  std::cout << "kT: " << kT << std::endl;
  std::cout << "angle stiffness: " << kappa << std::endl;
  std::cout << "bond stiffness: " << mu << std::endl;
  std::cout << "viscosity: " << visc << std::endl;
  std::cout << "time step: " << dt << std::endl;
  std::cout << "storage file name: " << storageFileName << std::endl;
  std::cout << "adaptive mesh flag: " << adaptiveMeshingFlag << std::endl;
  std::cout << "removal method: " << removalMethod << std::endl;
  std::cout << "target seg length: " << targetSegLength << std::endl;
  
  
  std::cout << "\n" << std::endl;
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

  // make periodic box //
  //box = new LeesEdwards(syssize[0],syssize[1],0.0);
    
  // create body //
  //   if(!adaptiveMeshing) {
  // 		gel = new SemiflexibleGel<2>(nodes,box,filDens,nNodesPerFilament,dL,bondType,cutOffEnds,_pm);
  // 		gel->compute(true,true,false);
  // 		std::cout << "Sanity check: gel energy at zero shear = " << gel->energy() << std::endl;
  //     }
  //   else {
  // 		gel = new SemiflexibleGel<2>(nodes,box,filDens,L,bondType,cutOffEnds,minLength,_pm);
  //     }
  //   //gel->addPinch(6.0,false,nodes,kBond,kAngle,visc,kT,dt,kcl);
  //     
  //   // write gel data to file //
  //   if(!adaptiveMeshing) {
  // 		gel->storeGel(fName);
  //     }
  //   
  // 
  //   return;

  std::cout << "\n" << std::endl;

  }
  
 
  //
  // adaptive meshing constructor
  // JKP: CREATING gel
  //
  template<int N>
  SemiflexibleGel<N>::SemiflexibleGel(DefNodeContainer & dNodes, PeriodicBox * box, double filDens, double filLength, const string & bondType, bool cutOffEnds, double minLength, const PropertyList & properties) {
    // Adaptively mesh the gel. //
    ConstPropertyIterator p = properties.find("kT");
    assert( p != properties.end() );
    double kT = atof(p->second.data());

    p = properties.find("angle stiffness");
    assert( p != properties.end() );
    double kappa = atof(p->second.data());

    p = properties.find("bond stiffness");
    assert(p != properties.end());
    double mu = atof(p->second.data());

    p = properties.find("viscosity");
    assert( p != properties.end() );
    double visc = atof(p->second.data());

    p = properties.find("time step");
    assert( p != properties.end() );
    double dt = atof(p->second.data());

    p = properties.find("storage file name");
    assert(p != properties.end());
    std::string storageFileName = p->second.data();

    // removalMethod key: 0 = stretch short segments; 1 = delete one in each pair; 2 = collapse nodes //
    int removalMethod = 0;	
    p = properties.find("nearby pair removal method");
    if(p != properties.end()) {
      std::string removeMeth = p->second.data();
      if(removeMeth.find("Delete")!=string::npos) removalMethod = 1;
      else if(removeMeth.find("Collapse")!=string::npos) removalMethod = 2;
    }

    double targetSegLength;
    p = properties.find("target segment length");
    if(p != properties.end()) {
      targetSegLength = atof(p->second.data());
    }
    else targetSegLength = 2.0*minLength;
    //assert(targetSegLength > 0.0);
    //assert(targetSegLength > minLength);

    double maxPrestress = -1.0;
    p = properties.find("maximum prestress");
    if(p != properties.end()) {
      maxPrestress = kT*atof(p->second.data());
    }

    double k_max = -1.0;
    double entropic_k = -1.0;
    double entropic_Lp = -1.0;
    bool linentropic = false;
    double linentfrac = 0.0;
    double linentmult = 1.0;
    if(bondType == "EntropicSpring") {
      p = properties.find("k_max");
      if(p!=properties.end()) k_max = atof(p->second.data());
      p = properties.find("Entropic_k");
      if(p!=properties.end()) entropic_k = atof(p->second.data());
      p = properties.find("Entropic_Lp");
      if(p!=properties.end()) entropic_Lp = atof(p->second.data());
      p = properties.find("Entropic_lin_springs");
      if(p!=properties.end()) {
	if(atoi(p->second.data()) == 1) {
	  linentropic = true;
	  p = properties.find("Entropic_lin_stiff_frac");
	  if(p!=properties.end()) linentfrac = atof(p->second.data());
	  p = properties.find("Entropic_lin_stiff_mult");
	  if(p!=properties.end()) linentmult = atof(p->second.data());
	}
      }
    }

    //     double k_max = -1.0;
    //     double entropic_k = -1.0;
    //     double entropic_Lp = -1.0;
    //     if(bondType == "EntropicSpring") {
    //       p = properties.find("k_max");
    //       if(p!=properties.end()) k_max = atof(p->second.data());
    //       p = properties.find("Entropic_k");
    //       if(p!=properties.end()) entropic_k = atof(p->second.data());
    //       p = properties.find("Entropic_Lp");
    //       if(p!=properties.end()) entropic_Lp = atof(p->second.data());
    //     }

    //bool prestress;
    //std::string prestressStr;
    //p = properties.find("prestress");
    //assert(p != properties.end());
    //prestressStr.assign(p->second);
    //if(prestressStr.find("true") != string::npos) prestress = true;
    //else prestress = false;

    std::map< int, int > filLens;
    std::string polydispStr;
    bool longshort = false;
    bool exponential = false;
    bool longLinked = false;
    bool longLinStiff = true;
    double lsratio = 1.0; 
    double longStiff = 0.0;
    double longkC = kappa;
    double lsfrac = 0.0;
    double expmnl = 0.0;
    double expmin = 0.0;
    p = properties.find("polydispersity");
    if(p != properties.end()) {
      polydispStr.assign(p->second);
      if(polydispStr.find("LongShort") != string::npos) {
	longshort = true;
	p = properties.find("longshortratio");
	assert(p != properties.end());
	lsratio = atof(p->second.data());
	p = properties.find("longfraction");
	assert(p != properties.end());
	lsfrac = atof(p->second.data());
	assert(lsfrac <= 1.0);
	p = properties.find("longstiffness");
	assert(p != properties.end());
	longStiff = atof(p->second.data());
	if(longStiff < 1.0e-6) longStiff = 0.0;
	p = properties.find("longlinked");
	if(p != properties.end()) {
	  double llink = atof(p->second.data());
	  if(llink > 0.5) longLinked = true;
	}
	p = properties.find("longbendstiffness");
	if(p != properties.end()) longkC = atof(p->second.data());
      }
      else if(polydispStr.find("Exponential") != string::npos){
	//insert here for exponential distributed length network
	exponential = true;
	expmnl = filLength;
	p = properties.find("minlength");
	assert(p != properties.end());
	expmin = atof(p->second.data());
      }
    }

    NematicProbTable npt;
    bool donem = false;
    double nematic = 0.0;
    double nemAngle = 0.0;
    std::string orientationPDF;
    p = properties.find("nematic PDF param");
    if(p != properties.end()) {
      nematic = atof(p->second.data());
      donem = true;
      p = properties.find("orientational PDF");
      if(p != properties.end()) {
	if(p->second.find("Lorentzian") != string::npos) {
	  orientationPDF = "Lorentzian";
	  npt.setPDF(1);
	  npt.setTable(nematic);
	}
	else {
	  orientationPDF = "Gaussian";
	  npt.setPDF(0);
	  npt.setTable(nematic);
	}
      }
      else {
	orientationPDF = "Gaussian";
	npt.setPDF(0);
	npt.setTable(nematic);
      }
      p = properties.find("nematic direction angle");
      if(p != properties.end()) nemAngle = atof(p->second.data());
    }

    //ranlib::Normal<double> rngps(0,sqrt(kT/kAngle));
    //rngps.seed((unsigned int)time(0));
    ranlib::Uniform<double> rnguni;
    rnguni.seed((unsigned int)time(0));
    ranlib::Exponential<double> rngexp(expmnl-expmin);
    rngexp.seed((unsigned int)time(0));

    _box = box;
    VectorND size( _box->size() );
    double vol=1.0;
    for(int i=0; i<N; i++) {
      vol *= size[i];
    }
    int nFils = (int)(filDens*vol);
    VectorND startPos;
    VectorND oldVec;
    VectorND newVec;
    double newAng;

    TempFilamentContainer tmpFils(nFils); 
    // create first and last points for each filament //

    std::set<int> longFils;

    if(longshort) {
      std::cout << "short filament length = " << filLength << std::endl
		<< "long filament length = " << lsratio*filLength << std::endl;
    }

    std::cout << "Starting gel creation." << std::endl;
    for(int i=0; i<nFils; i++) {
      //rngps.seed((unsigned int)time(0)+i);
      rnguni.seed((unsigned int)time(0)+i);
      rngexp.seed((unsigned int)time(0)+i);
      double curFilLen;
      if(exponential) {
	curFilLen = rngexp.random() + expmin;
	//std::cout << "Shouldn't be here..." << std::endl;
      }
      else if(longshort) {
	if(i < lsfrac*nFils) {
	  curFilLen = lsratio*filLength;
	  longFils.insert(i);
	}
	else curFilLen = filLength;
      }
      else curFilLen = filLength;
 
      TempFilament * newFil = new TempFilament();
      
      // randomly choose a starting position for the filament //	
      for(int k=0;k<N;k++) {
	newFil->start(k) = size[k]*(rnguni.random());
      }
      
      // now randomly choose an angle and an ending position //
      if(!donem) {
        newAng = 2.0*M_PI*(rnguni.random());
      }
      else {
        newAng = npt.findAngle(rnguni.random());
	if(rnguni.random() < .5) {
	  newAng = -newAng;
	}
	if(rnguni.random() < .5) {
	  newAng += M_PI;
	}
	newAng += nemAngle;
      }
      newFil->end(0) = curFilLen*cos(newAng) + newFil->start(0);
      newFil->end(1) = curFilLen*sin(newAng) + newFil->start(1);

      // determine whether filament is completely in box, crosses through two zones, or crosses through three zones //
      newFil->filSegs.push_back(pair<VectorND,VectorND>(newFil->start,newFil->end));
      if(!(_box->inside(newFil->end))) {
	VectorND newend(newFil->end);
	_box->mapPoint(newend);
	VectorND newstart;
        newstart = newend - (newFil->end - newFil->start);
	newFil->filSegs.push_back(pair<VectorND,VectorND>(newstart,newend));
	if(newend(0) != newFil->end(0) && newend(1) != newFil->end(1)) {
	  newend = newFil->end;
	  _box->mapPointX(newend);
	  newstart = newend - (newFil->end - newFil->start);
	  newFil->filSegs.push_back(pair<VectorND,VectorND>(newstart,newend));
	  newend = newFil->end;
	  _box->mapPointY(newend);
	  newstart = newend - (newFil->end - newFil->start);
	  newFil->filSegs.push_back(pair<VectorND,VectorND>(newstart,newend));
	}
      }

      // now look at existing filaments and find crosslink points //
      for(int j=0; j<i; j++) {
	if(longLinked==true || (longFils.find(i)==longFils.end() || longFils.find(j)==longFils.end())) {
	  TempFilament * oldFil = tmpFils[j];
	  double oldFilLen = norm2((oldFil->end)-(oldFil->start));
	  VectorND diff;
	  diff = .5*((oldFil->end)+(oldFil->start)) - .5*(newFil->end+newFil->start);
	  _box->mapDistance(diff);
	  if(norm2(diff) <= .5*(oldFilLen+curFilLen)) {
	    VectorND intersect;
	    typename vector< pair< VectorND,VectorND > >::iterator oldFilImgs = oldFil->filSegs.begin();
	    bool connected = false;
	    while(!connected && oldFilImgs!=oldFil->filSegs.end()) {
	      typename vector< pair<VectorND,VectorND> >::iterator newFilImgs = newFil->filSegs.begin();
	      while(!connected && newFilImgs!=newFil->filSegs.end()) {
		bool checkConnect = IntersectionFinder<N>::checkIntersection(newFilImgs->first,newFilImgs->second,oldFilImgs->first,oldFilImgs->second,intersect);
		if(checkConnect) {
		  connected = true;
		  VectorND cldist;
		  cldist = intersect - newFilImgs->first;
		  //_box->mapDistance(cldist);
		  double distFromStart = norm2(cldist);
		  cldist += newFil->filSegs[0].first;
		  TempCrosslink* tmpCL = new TempCrosslink();
		  tmpCL->baseFil = j;
		  tmpCL->active = true;
		  //tmpCL->location = intersect;
		  //tmpCL->otherFils.insert(i);
		  //tmpCL->otherFils.insert(j);
		  tmpCL->otherFils.insert(pair< int, VectorND >(i,cldist));
		  newFil->crossFils.insert(pair<double,TempCrosslink *>(distFromStart,tmpCL));
		  cldist = intersect - oldFilImgs->first;
		  //_box->mapDistance(cldist);
		  distFromStart = norm2(cldist);
		  cldist += oldFil->filSegs[0].first;
		  tmpCL->otherFils.insert(pair< int, VectorND >(j,cldist));
		  oldFil->crossFils.insert(pair<double,TempCrosslink *>(distFromStart,tmpCL));
		}
		newFilImgs++;
	      }
	      oldFilImgs++;
	    }
	  }
	}
      }
      tmpFils[i] = newFil;
    }


    // now iterate along each filament and find (and remove) too-short segments //
    if(removalMethod == 1) {
      int deletedCrosslinks = 0;
      deletedCrosslinks = removeCrosslinks(tmpFils,minLength);
      //for(int i=0; i<nFils; i++) {
      //deletedCrosslinks += removeCrosslinks(tmpFils[i],minLength);
      //}
      std::cout << "Removed " << deletedCrosslinks << " crosslinks from gel to avoid excessively stiff segments." << std::endl;
    }

    else if(removalMethod ==2) {
      int collapsedCrosslinks = collapseCrosslinks(tmpFils,minLength);
      std::cout << "Collapsed " << collapsedCrosslinks << " crosslinks to avoid excessively stiff segments." << std::endl;
    }

    storeSparseGel(storageFileName,tmpFils);
	
    // we now have a list of crosslinks for each filament; we can now create the gel //
    int id = 0;
    NodeBase::DofIndexMap idx(N);
    DefNode * newNode;	
    //if(bondType == "Spring") {
    for(int k=0; k<nFils; k++) {
      DefNodeContainer tmpDNC;
      TempFilament * curFil = tmpFils[k];
      int nCLs = curFil->crossFils.size();
      typename multimap<double,TempCrosslink*>::iterator clIter = curFil->crossFils.begin();
      int i = 0;
      VectorND segStart;
      segStart = curFil->start;
      
      // create first node //
      for(int m=0; m<N; m++) {
	idx[m] = N*id + m;
      }
      newNode = new BrownianNode<N>(id,idx,segStart,segStart);
      newNode->setId(id);
      tmpDNC.push_back(newNode);
      dNodes.push_back(newNode);
      id++;
      
      // create nodes between start and first crosslink and between all crosslink pairs //
      for(clIter; clIter!=curFil->crossFils.end(); clIter++) {
	if(clIter->second->active) {
	  VectorND sep;
	  sep = clIter->second->otherFils[k] - segStart;
	  //_box->mapDistance(sep);
	  double dist = norm2(sep);
	  int nNodesBetween;
	  if(targetSegLength > 0.0) {
	    nNodesBetween = (int)(std::floor((dist/targetSegLength)) -.5);
	  }
	  else {
	    if(dist > 2.0*minLength) {
	      int tmpNNB = (int)(std::floor((dist/fabs(targetSegLength))) -.5);
	      nNodesBetween = max(1,tmpNNB);
	    }
	    else nNodesBetween = 0;
	  }
	  double segLength = dist/(nNodesBetween+1.0);
	  for(int nn=1; nn<=nNodesBetween; nn++) {
	    for(int m=0; m<N; m++) {
	      idx[m] = N*id + m;
	    }
	    VectorND nodePos;
	    nodePos = segStart + nn*sep*(segLength/dist);
	    newNode = new BrownianNode<N>(id,idx,nodePos,nodePos);
	    newNode->setId(id);
	    tmpDNC.push_back(newNode);
	    dNodes.push_back(newNode);
	    id++;
	  }
	  if(k == clIter->second->baseFil) {
	    for(int m=0; m<N; m++) {
	      idx[m] = N*id + m;
	    }
	    VectorND nodePos;
	    nodePos = segStart + sep;
	    newNode = new BrownianNode<N>(id,idx,nodePos,nodePos);
	    newNode->setId(id);
	    tmpDNC.push_back(newNode);
	    dNodes.push_back(newNode);
	    id++;
	    clIter->second->clNode = newNode;
	    //_crosslinkNodes.insert(newNode);
	    _crossNodeMap.insert(pair<DefNode*,DefNode*>(newNode,newNode));
	    PeriodicTie<N> * newTie = new PeriodicTie<N>(newNode,_box);
	    addConstraint(newTie);
	    clIter->second->ptie = newTie;
	    int nSlaves = clIter->second->otherFils.size() - 1;
	    _nSlavesMap.insert(pair<DefNode*,int>(newNode,nSlaves));
	  }
	  else {
	    //newNode = clIter->second->clNode;
	    //tmpDNC.push_back(newNode);
	    //for(int m=0; m<N; m++) {
	    //  idx[m] = N*id + m;
	    //}
	    DefNode* mastNode = clIter->second->clNode;
	    VectorND nodePos;
	    nodePos = segStart + sep;
	    newNode = new BrownianNode<N>(mastNode->id(),mastNode->index(),nodePos,nodePos);
	    newNode->setId(mastNode->id());
	    tmpDNC.push_back(newNode);
	    //dNodes.push_back(newNode);
	    //id++;
	    //_crosslinkNodes.insert(newNode);
	    _crossNodeMap.insert(pair<DefNode*,DefNode*>(newNode,mastNode));
	    PeriodicTie<N> * pt = clIter->second->ptie;
	    pt->addSlave(newNode);
	    
	  }
	  
	  segStart += sep;
	}
      }
      

      // create nodes between last crosslink and end //	
      VectorND sep;
      sep = curFil->end - segStart;
      //_box->mapDistance(sep);
      double dist = norm2(sep);
      int nNodesBetween;
      if(targetSegLength > 0.0) {
	nNodesBetween = (int)(std::floor((dist/targetSegLength)) -.5);
      }
      else {
	if(dist > 2.0*minLength) {
	  int tmpNNB = (int)(std::floor((dist/fabs(targetSegLength))) -.5);
	  nNodesBetween = max(1,tmpNNB);
	}
	else nNodesBetween = 0;
      }
      double segLength = dist/(nNodesBetween+1.0);
      for(int nn=1; nn<=nNodesBetween+1; nn++) {
	for(int m=0; m<N; m++) {
	  idx[m] = N*id + m;
	}
	VectorND nodePos;
	nodePos = segStart + nn*sep*(segLength/dist);
	newNode = new BrownianNode<N>(id,idx,nodePos,nodePos);
	newNode->setId(id);
	tmpDNC.push_back(newNode);
	dNodes.push_back(newNode);
	id++;
      }
      
      if(longFils.find(k) != longFils.end()) {
	if(bondType == "Spring" || longLinStiff) {
	  addFilament(tmpDNC,longkC,longStiff,visc,kT,dt,minLength);
	}
	else {
	  addFilament(tmpDNC,entropic_k,longkC,entropic_Lp,visc,kT,dt,k_max,longStiff);
	}
      }
      else {
	if(bondType == "Spring") {
	  addFilament(tmpDNC,kappa,mu,visc,kT,dt,minLength); 
	}
	else {
	  addFilament(tmpDNC,entropic_k,kappa,entropic_Lp,visc,kT,dt,k_max,mu);
	}
      }
      
    }
    
    // now that gel is set up, compute various quantities //
    
    computeCrossDistro(-1.0);

    computeFilLenDistro();

    computeNematicDistro(nemAngle);

    if(cutOffEnds) cutOffEndsandCCD(-1.0,dNodes);

    _viscReg = 0;

    _output = paraview;

    for(int fn=0; fn<nFils; fn++) {
      for(typename multimap<double,TempCrosslink*>::iterator cli = tmpFils[fn]->crossFils.begin(); cli!=tmpFils[fn]->crossFils.end(); cli++) {
        if(cli->second->baseFil == fn) {
	  TempCrosslink* tmpcl = cli->second;
	  delete tmpcl;
        }  
      }	
      delete tmpFils[fn];
    }

    if(removalMethod!=2) {
      for(typename map<DefNode*,int>::iterator sn=_nSlavesMap.begin(); sn!=_nSlavesMap.end(); sn++) {
        if(sn->second != 1) std::cerr << "Error: nodes pinned incorrectly!" << std::endl;
      }
    }

    //else printCLFilDist();

    //printInitialBends();

    if(linentropic) {
      stiffenRandomSegments(linentfrac,linentmult);
    }

    int nAngleSprings = 0;
    int nBonds = 0;
    int nRods = 0;
    for(FilamentIterator fi=_filaments.begin(); fi!=_filaments.end(); fi++) {
      nAngleSprings += (*fi)->angles.size();
      nBonds += (*fi)->bonds.size();
      nRods += (*fi)->rods.size();
    }
    
    std::cout << "Set up gel with " 
	      << nFils << " filaments, " 
	      << nAngleSprings << " angle springs, "
	      << nBonds << " bonds, and "
	      << nRods << " brownian rods."
	      << std::endl;
 
  }

  // Construct a filament with linear springs
  template<int N>
  SemiflexibleGel<N>::Filament::Filament( const DefNodeContainer & n, 
					  double kBond, double kAngle,
					  double viscosity, double kT, double dt) 
    : nodes(n) {
    
    for( int i=0; i<nodes.size()-1; i++ ) {
      // create Bonds and Rods
      //
      // i -- i+1 
      //
      Bond * b = new Bond( nodes[i], nodes[i+1], kBond ) ;
      bonds.push_back(b);
      Rod * r = new Rod( nodes[i], nodes[i+1], viscosity, kT, dt ) ;
      rods.push_back(r);

    }
    
    for( int i=0; i<nodes.size()-2; i++ ) {
      // create Angles
      //
      // i         i+2 
      //   \     /
      //     i+1	  
      Angle * a = new Angle( nodes[i], nodes[i+1], nodes[i+2], kAngle );
      angles.push_back(a);
    }	
  }

  // construct a filament with nonlinear (entropic) springs
  template<int N>
  SemiflexibleGel<N>::Filament::Filament( const DefNodeContainer & n, double kAngle, 
					  double viscosity, double kT, double dt, 
					  double kC, int fitOrder, double maxForce) 
    : nodes(n) {
    
    double Lp = kC/kT;
    double L0 = norm2(nodes[0]->point()-nodes[1]->point());
    double Larc = (nodes.size()-1)*L0*(1.0+(L0/(6.0*Lp)));
    for( int i=0; i<nodes.size()-1; i++ ) {
      // create Bonds and Rods
      //
      // i -- i+1 
      // 
      Bond * b = new EntropicSpring<N>( nodes[i], nodes[i+1], kT, kC, fitOrder, nodes.size()-1, Larc, true, maxForce ) ;
      bonds.push_back(b);
      Rod * r = new Rod( nodes[i], nodes[i+1], viscosity, kT, dt ) ;
      rods.push_back(r);

    }
    
    for( int i=0; i<nodes.size()-2; i++ ) {
      // create Angles
      //
      // i         i+2 
      //   \     /
      //     i+1	  
      Angle * a = new Angle( nodes[i], nodes[i+1], nodes[i+2], kAngle );
      angles.push_back(a);
    }	
  }

  // construct a filament with different segment lengths //
  template<int N>
  SemiflexibleGel<N>::Filament::Filament(const DefNodeContainer & n, double kappa, double mu, double viscosity, double kT, double dt, double minLength) : nodes(n) {
    int stretchedSegs = 0;
    if(nodes.size()>1) {
      for( int i=0; i<nodes.size()-1; i++ ) {
	// create Bonds and Rods
	//
	// i -- i+1 
	//
	VectorND bondSep;
	bondSep = nodes[i+1]->position() - nodes[i]->position();
	//box->mapDistance(bondSep);
	double bondLength = norm2(bondSep);
	if(bondLength < minLength) {
	  bondLength = minLength;
	  stretchedSegs++;
	}
	double kBond = mu/bondLength;
	Bond * b = new Bond( nodes[i], nodes[i+1], kBond, bondLength ) ;
	bonds.push_back(b);
	Rod * r = new Rod( nodes[i], nodes[i+1], viscosity, kT, dt, bondLength ) ;
	rods.push_back(r);
	
	//std::cout << "Warning: stretched " << stretchedSegs << " filament segments to avoid excessive stiffness." << std::endl;
	
      }
    }
    if(nodes.size()>2) {
      for( int i=0; i<nodes.size()-2; i++ ) {
	// create Angles
	//
	// i         i+2 
	//   \     /
	//     i+1	  
	VectorND segSep1;
	VectorND segSep2;
	segSep1 = nodes[i+2]->position() - nodes[i+1]->position();
	segSep2 = nodes[i+1]->position() - nodes[i]->position();
	//box->mapDistance(segSep1);
	//box->mapDistance(segSep2);
	double segLength1 = norm2(segSep1);
	double segLength2 = norm2(segSep2);
	if(segLength1 < minLength) {
	  segLength1 = minLength;
	}
	if(segLength2 < minLength) {
	  segLength2 = minLength;
	}
	double avgLength = .5*(segLength1+segLength2);
	double kAngle = kappa/avgLength;
	Angle * a = new Angle( nodes[i], nodes[i+1], nodes[i+2], kAngle );
	angles.push_back(a);
      }	
    }
  }

  // construct a nonlinear filament with different segment lengths //
  template<int N>
  SemiflexibleGel<N>::Filament::Filament(const DefNodeContainer & n, double entropic_k, double kap, double Lp, double viscosity, double kT, double dt, double k_max, double mu, std::map<DefNode*,DefNode*> & cnMap) : nodes(n) {
    

    if(nodes.size()>1) {
      for( int i=0; i<nodes.size()-1; i++ ) {
	// create Bonds and Rods
	//
	// i -- i+1 
	//
	VectorND bondSep;
	bondSep = nodes[i+1]->position() - nodes[i]->position();
	//box->mapDistance(bondSep);
	double bondLength = norm2(bondSep);
	Bond * b = new EntropicSpring<N>(nodes[i],nodes[i+1],entropic_k,Lp,bondLength,mu);
	bonds.push_back(b);
	Rod * r = new Rod( nodes[i], nodes[i+1], viscosity, kT, dt, bondLength ) ;
	rods.push_back(r);
	
      }
    }
    if(nodes.size()>2) {
      for( int i=0; i<nodes.size()-2; i++ ) {
	// create Angles
	//
	// i         i+2 
	//   \     /
	//     i+1	  
	VectorND segSep1;
	VectorND segSep2;
	segSep1 = nodes[i+2]->position() - nodes[i+1]->position();
	segSep2 = nodes[i+1]->position() - nodes[i]->position();
	//box->mapDistance(segSep1);
	//box->mapDistance(segSep2);
	double segLength1 = norm2(segSep1);
	double segLength2 = norm2(segSep2);
	double avgLength = .5*(segLength1+segLength2);
	double kAngle = kap/avgLength;
	Angle * a = new Angle( nodes[i], nodes[i+1], nodes[i+2], kAngle );
	angles.push_back(a);
      }	
    }
        
    //     std::vector<int> tmpCLNodes;
    //     int nNodes = nodes.size();
    //     for(int nn=0; nn<nNodes; nn++) {
    //       if(cnMap.find(nodes[nn]) != cnMap.end()) {
    // 	tmpCLNodes.push_back(nn);
    //       }
    //     }
    //     if(tmpCLNodes.size() ==0 || tmpCLNodes[0] != 0) {
    //       typename vector<int>::iterator ni = tmpCLNodes.begin();
    //       tmpCLNodes.insert(ni,0);
    //     }
    //     if(tmpCLNodes[tmpCLNodes.size()-1] != nNodes-1) {
    //       tmpCLNodes.push_back(nNodes-1);
    //     }
    
    //     if(nNodes>1) {
    //       for(int nc=0; nc<tmpCLNodes.size()-1; nc++) {
    // 	int startNode = tmpCLNodes[nc];
    // 	int endNode = tmpCLNodes[nc+1];
    // 	VectorND arc;
    // 	arc = nodes[endNode]->position() - nodes[startNode]->position();
    // 	double L0 = norm2(arc);
    // 	for(int nodeNum=startNode; nodeNum<endNode; nodeNum++) {
    // 	  // create Bonds and Rods
    // 	  //
    // 	  // i -- i+1 
    // 	  //
    // 	  VectorND bondSep;
    // 	  bondSep = nodes[nodeNum+1]->position() - nodes[nodeNum]->position();
    // 	  double bondLength = norm2(bondSep);
    // 	  Bond * b = new EntropicSpring<N>(nodes[nodeNum],nodes[nodeNum+1],entropic_k,Lp,L0,mu);
    // 	  bonds.push_back(b);
    // 	  Rod * r = new Rod( nodes[nodeNum], nodes[nodeNum+1], viscosity, kT, dt, bondLength ) ;
    // 	  rods.push_back(r);
	  
    // 	  //std::cout << "Warning: stretched " << stretchedSegs << " filament segments to avoid excessive stiffness." << std::endl;
	  
    // 	}
    //       }
    //     }

    //     assert(bonds.size() == nodes.size()-1);

    //     if(nodes.size()>2) {
    //       for( int i=0; i<nodes.size()-2; i++ ) {
    // 	// create Angles
    // 	//
    // 	// i         i+2 
    // 	//   \     /
    // 	//     i+1	  
    // 	VectorND segSep1;
    // 	VectorND segSep2;
    // 	segSep1 = nodes[i+2]->position() - nodes[i+1]->position();
    // 	segSep2 = nodes[i+1]->position() - nodes[i]->position();
    // 	//box->mapDistance(segSep1);
    // 	//box->mapDistance(segSep2);
    // 	double segLength1 = norm2(segSep1);
    // 	double segLength2 = norm2(segSep2);
    // 	double avgLength = .5*(segLength1+segLength2);
    // 	double kAngle = kap/avgLength;
    // 	Angle * a = new Angle( nodes[i], nodes[i+1], nodes[i+2], kAngle );
    // 	angles.push_back(a);
    //       }	
      
    //       assert(angles.size() == nodes.size()-2);
    //     }
    
  }

  template<int N>
  SemiflexibleGel<N>::Filament::~Filament() {
    for(int i=0; i< bonds.size(); i++) delete( bonds[i]);
    for(int i=0; i<  rods.size(); i++) delete(  rods[i]);
    for(int i=0; i<angles.size(); i++) delete(angles[i]);
  }

  template<int N>
  const typename tvmet::Vector<double,N> & SemiflexibleGel<N>::Filament::point() {
    int nNodes = nodes.size();
    pt = nodes[0]->point() + nodes[nNodes-1]->point();
    pt /= 2.0;
    return pt;
  }

  template<int N>
  void SemiflexibleGel<N>::updateNodalPoints(std::string & strainedGelFN) {
    int intSize = sizeof(int);
    int doubleSize = sizeof(double);
    // open the file at the end to get size //
    std::ifstream inFile(strainedGelFN.data(), ios::in | ios::binary | ios::ate);
    ifstream::pos_type fsize = inFile.tellg();
    
    // reset file to beginning //
    inFile.seekg(0,ios::beg);
    
    // read in system size //
    VectorND sysSize;
    for(int i=0; i<N; i++) {
      double curSS;
      inFile.read((char *)(&curSS),doubleSize);
      sysSize[i] = curSS;
    }
    
    // read in # of filaments
    int nFils;
    inFile.read((char *)(&nFils),intSize);
    
    assert(nFils == _filaments.size());
    
    NodeBase::DofIndexMap idx(N);
    int id = 0;
    
    // read in nodal data and create gel elements //
    for(int j=0; j<nFils; j++) {
      int nNodesHere;
      inFile.read((char *)(&nNodesHere),intSize);
      assert(nNodesHere == filament(j)->nodes.size());
      //DefNodeContainer tmpDNC(nNodesHere);
      for(int k=0; k<nNodesHere; k++) {
	VectorND curPos;
	VectorND refPos;
	for(int kdof=0; kdof<N; kdof++) {
	  idx[kdof] = N*id + kdof;
	  double cpdof;
	  inFile.read((char *)(&cpdof),doubleSize);
	  curPos[kdof] = cpdof;
	}
	for(int kdof=0; kdof<N; kdof++) {
	  double rpdof;
	  inFile.read((char *)(&rpdof),doubleSize);
	  refPos[kdof] = rpdof;
	}
	filament(j)->nodes[k]->setPoint(curPos);
	
	id++;
      }
    }

    inFile.close();
    
    std::cout << "SemiflexibleGel: updated nodal points using file " <<  strainedGelFN << std::endl;
        
  }

  template<int N>
  void SemiflexibleGel<N>::removePrestress() {
    // first, set nodal positions so that crosslinked nodes lie on top of one another //
    for(ConstraintIterator c=_constraints.begin(); c!=_constraints.end(); c++) {
      (*c)->predict();
    }
    // now reset reference lengths and stiffnesses of springs and angle springs //
    for(FilamentIterator fi=_filaments.begin(); fi!=_filaments.end(); fi++) {
      for(BondIterator bi=(*fi)->bonds.begin(); bi!=(*fi)->bonds.end(); bi++) {
	double oldd = (*bi)->getLength();
	(*bi)->resetLength();
	double newd = (*bi)->getLength();
	// do not allow segments to get too short //
	if(newd <= 5.0e-3) {
	  (*bi)->resetLength(5.0e-3);
	  newd = 5.0e-3;
	  std::cout << "Found short segment!" << std::endl;
	}
	double ksp = (*bi)->stiffness();
	(*bi)->setStiffness(ksp*oldd/newd);
      }
      for(AngleIterator ai=(*fi)->angles.begin(); ai!=(*fi)->angles.end(); ai++) {
	double oldL = (*ai)->meanSegmentLength();
	double newL = (*ai)->meanSegmentExtension();
	double kang = (*ai)->stiffness();
	if(newL <= 5.0e-3) {
	  newL = 5.0e-3;
	  std::cout << "Found short segments!" << std::endl;
	}
	(*ai)->setStiffness(kang*oldL/newL);
      }
    }
  }

  template<int N>
  int SemiflexibleGel<N>::removeCrosslinks(TempFilamentContainer & tmpFils, double minLength) {
    int deletedCrosslinks = 0;
    ranlib::Uniform<double> rnguni;
    rnguni.seed((unsigned int)time(0));
    int nf;
    for(nf=0; nf<tmpFils.size(); nf++) {
      TempFilament* fil = tmpFils[nf];
      typename multimap<double,TempCrosslink*>::iterator clIter = fil->crossFils.begin();
      vector<TempCrosslink*> cls;
      for(clIter; clIter!=fil->crossFils.end(); clIter++) {
	if(clIter->second->active) {
	  cls.push_back(clIter->second);
	}
      }
      int nCL = cls.size();
      int i = 0;
      while(i<nCL-1) {
	int j=i+1;
	while(j<nCL && cls[j]->active == false) j++;
	if(j<nCL) {
	  rnguni.seed((unsigned int)(time(0)+j));
	  VectorND clSep;
	  clSep = cls[j]->otherFils[nf] - cls[i]->otherFils[nf];
	  //_box->mapDistance(clSep);
	  double clDist = norm2(clSep);
	  if(clDist < minLength) {
	    // randomly select one of the crosslinks to remove //
	    if(rnguni.random() < .5) {
	      cls[i]->active = false;
	      i = j;	    
	    }
	    else {
	      cls[j]->active = false;
	    }
	    deletedCrosslinks++;
	  }
	  else i = j;
	}
	else i = j;
      }
    }

    return deletedCrosslinks;  
  }

  template<int N>
  int SemiflexibleGel<N>::collapseCrosslinks(TempFilamentContainer & tmpFils, double minLength) {
    //     // collapse crosslinks to avoid short segments //
    //     VectorND size;
    //     size = _box->size();
    //     int nIn = (int)(floor(size[0]/minLength)+.5);
    //     bool fit = false;
    //     double boxSize;
    //     while(!fit) {
    //       boxSize = size[0]/nIn;
    //       fit = true;
    //       for(int i=0; i<N; i++) {
    //         if(fmod(size[0],boxSize) > 1.0e-6) fit = false;
    //       }
    //       nIn--;
    //     }
    //     for(int i=0; i<N; i++) assert(fmod(size[i],boxSize) < 1.0e-6);
    //     int nx = (int)((size[0]/boxSize)+.5);
    //     int ny = (int)((size[1]/boxSize)+.5);
    
    //     TempBox** boxes = new TempBox*[nx];
    //     for(int xbox=0; xbox<nx; xbox++) {
    //       TempBox* newBox = new TempBox[ny];
    //       boxes[xbox] = newBox;
    //     }
    //     int nFils = tmpFils.size();
    //     for(int i=0; i<nFils; i++) {
    //       TempFilament* fi = tmpFils[i];
    //       for(typename multimap<double,TempCrosslink*>::iterator cl=fi->crossFils.begin(); cl!=fi->crossFils.end(); cl++) {
    //         if(cl->second->baseFil == i) {
    //           VectorND & pos = cl->second->location;
    //           int xpos = (int)(floor(pos[0]/boxSize)+.5);
    // 	  int ypos = (int)(floor(pos[1]/boxSize)+.5);
    // 	  boxes[xpos][ypos].boxCLs.push_back(cl->second);
    //         }
    //       }
    //       fi->crossFils.clear();
    //     }

    //     // now look for clusters to collapse //
    //     int nCollapsed = 0;
    //     for(int i=0; i<nx; i++) {
    //       for(int j=0; j<ny; j++) {
    //         int nBoxCLs = boxes[i][j].boxCLs.size();
    // 	for(int m=0; m<nBoxCLs; m++) {
    // 	  TempCrosslink* cl = boxes[i][j].boxCLs[m];
    //           if(cl->active) {
    //             // look for in-box neighbors //
    // 	    int nCollapsedHere = 1;
    // 	    VectorND center(0.0);
    // 	    for(int n=m+1; n<nBoxCLs; n++) {
    //               TempCrosslink* cl2 = boxes[i][j].boxCLs[n];
    // 	      if(cl2->active) {
    //                 VectorND diff;
    //                 diff = cl->location - cl2->location;
    // 		bool sameFil = false;
    // 		typename set<int>::iterator fs1 = cl->otherFils.begin();
    // 		while(!sameFil && fs1!=cl->otherFils.end()) {
    // 		  if(cl2->otherFils.find(*fs1) != cl2->otherFils.end()) sameFil = true;
    // 		  fs1++;
    // 		}
    //                 if(norm2(diff) < minLength && sameFil) {
    //                   center += diff;
    // 		  nCollapsedHere++;
    // 		  nCollapsed++;
    // 		  cl2->active = false;
    // 		  typename set<int>::iterator fs2 = cl2->otherFils.begin();
    // 		  for(fs2; fs2!=cl2->otherFils.end(); fs2++) {
    // 		    cl->otherFils.insert(*fs2);
    //                   }
    // 		  typename set<int>::iterator fb = cl->otherFils.begin();
    // 		  cl->baseFil = *fb;
    // 	 	}
    //               }
    //             }
    // 	    // look at other boxes //
    // 	    for(int di=-1; di<=1; di++) {
    //               for(int dj=-1; dj<=1; dj++) {
    //                 int ip = (i+di+nx)%nx;
    // 		int jp = (j+dj+ny)%ny;
    // 		if(ip!=i || jp!=j) {
    //                   int nBoxCLs2 = boxes[ip][jp].boxCLs.size();
    // 		  for(int p=0; p<nBoxCLs2; p++) {
    // 		    TempCrosslink* cl2 = boxes[ip][jp].boxCLs[p];
    // 		    if(cl2->active) {
    // 	              VectorND diff;
    // 		      diff = cl->location - cl2->location;
    // 		      _box->mapDistance(diff);
    //                       bool sameFil = false;
    //                       typename set<int>::iterator fs1 = cl->otherFils.begin();
    // 		      while(!sameFil && fs1!=cl->otherFils.end()) {
    // 		        if(cl2->otherFils.find(*fs1) != cl2->otherFils.end()) sameFil = true;
    // 		        fs1++;
    // 		      }
    //                       if(norm2(diff) < minLength && sameFil) {
    //                         center += diff;
    //                         nCollapsedHere++;
    // 			nCollapsed++;
    // 			cl2->active = false;
    // 		        typename set<int>::iterator fs2 = cl2->otherFils.begin();
    // 		        for(fs2; fs2!=cl2->otherFils.end(); fs2++) {
    // 		          cl->otherFils.insert(*fs2);
    //                         }
    // 		        typename set<int>::iterator fb = cl->otherFils.begin();
    // 		        cl->baseFil = *fb;
			
    //                       }
    //                     }    
    //                   }
    //                 }
    //               }
    //             }
    // 	    // having collapsed, reset position and baseFil //
    //             center /= nCollapsedHere;
    // 	    center += cl->location;
    // 	    _box->mapPoint(center);
    // 	    cl->location = center; 
    //           }
    //         } 
    //       }
    //     }
    
    //     for(int i=0; i<nx; i++) {
    //       for(int j=0; j<ny; j++) {
    //         typename vector<TempCrosslink *>::iterator cls = boxes[i][j].boxCLs.begin();
    // 	for(cls; cls!=boxes[i][j].boxCLs.end(); cls++) {
    // 	  if((*cls)->active) {
    // 	    typename set<int>::iterator cl = (*cls)->otherFils.begin();
    // 	    for(cl; cl!=(*cls)->otherFils.end(); cl++) {
    //               VectorND filStart;
    //               filStart = tmpFils[*cl]->start;
    // 	      VectorND sep;
    // 	      sep = (*cls)->location - filStart;
    // 	      _box->mapDistance(sep);
    // 	      tmpFils[*cl]->crossFils.insert(pair<double,TempCrosslink*>(norm2(sep),*cls));
    //             }
    //           }
    // 	  else delete *cls;  
    //         }
    //       }
    //     }

    //     return nCollapsed;

    return 0;
  }

  template<int N>
  void SemiflexibleGel<N>::printConnectionData(std::string & connFileName) {
    typename std::map< DefNode*,pair<int,int> > node2filmap;
    typename std::map< Bond*, int> bond2segidmap;

    struct NeighbList {
      typename std::set<int> neighbs;
    };

    int fn = 0;
    int segid = 0;
    for(fn; fn<_filaments.size(); fn++) {
      int nn = 0;
      Filament* f = filament(fn);
      for(nn; nn<f->nodes.size()-1; nn++) {
	bond2segidmap.insert(pair<Bond*,int>(f->bonds[nn],segid));
	segid++;
	std::pair<int,int> newPair = pair<int,int>(fn,nn);
	node2filmap.insert(pair< DefNode*,pair<int,int> >(f->nodes[nn],newPair));
      }
      std::pair<int,int> newPair = pair<int,int>(fn,f->nodes.size()-1);
      node2filmap.insert(pair< DefNode*,pair<int,int> >(f->nodes[f->nodes.size()-1],newPair));
    }

    NeighbList* masterList[segid];
    for(int i=0;i<segid;i++) {
      masterList[i] = new NeighbList();
    }
    
    std::map<DefNode*,DefNode*> pinchMap;
    std::vector<Pinch*> & pinchVec = pinches();
    int nPinch = pinchVec.size();
    if(2*nPinch != _pinchNodes.size()) {
      std::cout << "Possible error: " << nPinch << " pinches but " << _pinchNodes.size() << " nodes pinched." << std::endl;
    }
    for(int np=0; np<nPinch; np++) {
      std::pair<DefNode*,DefNode*> newPair = pinchVec[np]->getNodes();
      std::pair<DefNode*,DefNode*> newPair2 = pair<DefNode*,DefNode*>(newPair.second,newPair.second);
      pinchMap.insert(newPair);
      pinchMap.insert(newPair2);
    }

    // now figure out and print connectivity //

    for(fn=0; fn<_filaments.size(); fn++) {
      int bn = 0;
      Filament* f = filament(fn);
      for(bn; bn<f->bonds.size(); bn++) {
	int segid = bond2segidmap[ f->bonds[bn] ];
	// add bonds on same filament //
	if(bn!=0) {
	  masterList[segid]->neighbs.insert(bond2segidmap[ f->bonds[bn-1] ]);
	}
	if(bn!=f->bonds.size()-1) {
	  masterList[segid]->neighbs.insert(bond2segidmap[ f->bonds[bn+1] ]);
	}

	// look for crosslinks in which this bond has a slave node //
	if(_crossNodeMap.find(f->nodes[bn]) != _crossNodeMap.end()) {
	  if(_crossNodeMap[ f->nodes[bn] ] != f->nodes[bn]) {
	    int fpart = node2filmap[ _crossNodeMap[ f->nodes[bn] ] ].first;
	    int npart = node2filmap[ _crossNodeMap[ f->nodes[bn] ] ].second;
	    Filament* f2 = filament(fpart);
	    if(npart != 0) {
	      masterList[segid]->neighbs.insert(bond2segidmap[ f2->bonds[npart-1] ]);
	      masterList[ bond2segidmap[ f2->bonds[npart-1] ] ]->neighbs.insert(segid);
	    }
	    if(npart != f2->nodes.size()-1) {
	      masterList[segid]->neighbs.insert(bond2segidmap[ f2->bonds[npart] ]);
	      masterList[ bond2segidmap[ f2->bonds[npart] ] ]->neighbs.insert(segid);
	    }
	  }
	}
	
	if(_crossNodeMap.find(f->nodes[bn+1]) != _crossNodeMap.end()) {
	  if(_crossNodeMap[ f->nodes[bn+1] ] != f->nodes[bn+1]) {
	    int fpart = node2filmap[ _crossNodeMap[ f->nodes[bn+1] ] ].first;
	    int npart = node2filmap[ _crossNodeMap[ f->nodes[bn+1] ] ].second;
	    Filament* f2 = filament(fpart);
	    if(npart != 0) {
	      masterList[segid]->neighbs.insert(bond2segidmap[ f2->bonds[npart-1] ]);
	      masterList[ bond2segidmap[ f2->bonds[npart-1] ] ]->neighbs.insert(segid);
	    }
	    if(npart != f2->nodes.size()-1) {
	      masterList[segid]->neighbs.insert(bond2segidmap[ f2->bonds[npart] ]);
	      masterList[ bond2segidmap[ f2->bonds[npart] ] ]->neighbs.insert(segid);
	    }
	  }
	}
	
	// look for motors that might connect this bond to other bonds //	
	if(pinchMap.find(f->nodes[bn]) != pinchMap.end()) {
	  if(pinchMap[ f->nodes[bn] ] != f->nodes[bn]) {
	    int fpart = node2filmap[ pinchMap[ f->nodes[bn] ] ].first;
	    int npart = node2filmap[ pinchMap[ f->nodes[bn] ] ].second;
	    Filament* f2 = filament(fpart);
	    if(npart != 0) {
	      masterList[segid]->neighbs.insert(bond2segidmap[ f2->bonds[npart-1] ]);
	      masterList[ bond2segidmap[ f2->bonds[npart-1] ] ]->neighbs.insert(segid);
	    }
	    if(npart != f2->nodes.size()-1) {
	      masterList[segid]->neighbs.insert(bond2segidmap[ f2->bonds[npart] ]);
	      masterList[ bond2segidmap[ f2->bonds[npart] ] ]->neighbs.insert(segid);
	    }
	  }
	}
	
	if(pinchMap.find(f->nodes[bn+1]) != pinchMap.end()) {
	  if(pinchMap[ f->nodes[bn+1] ] != f->nodes[bn+1]) {
	    int fpart = node2filmap[ pinchMap[ f->nodes[bn+1] ] ].first;
	    int npart = node2filmap[ pinchMap[ f->nodes[bn+1] ] ].second;
	    Filament* f2 = filament(fpart);
	    if(npart != 0) {
	      masterList[segid]->neighbs.insert(bond2segidmap[ f2->bonds[npart-1] ]);
	      masterList[ bond2segidmap[ f2->bonds[npart-1] ] ]->neighbs.insert(segid);
	    }
	    if(npart != f2->nodes.size()-1) {
	      masterList[segid]->neighbs.insert(bond2segidmap[ f2->bonds[npart] ]);
	      masterList[ bond2segidmap[ f2->bonds[npart] ] ]->neighbs.insert(segid);
	    }
	  }
	}
      }
    }

    // now all segments have neighbor lists, so print them to file //

    std::ofstream connFile(connFileName.c_str());

    int cursegid = 0;
    for(fn=0; fn<_filaments.size(); fn++) {
      int bn = 0;
      Filament* f = filament(fn);
      for(bn; bn<f->bonds.size(); bn++) {
	// print out location //
	VectorND loc;
	loc = 0.5*(f->nodes[bn]->position() + f->nodes[bn+1]->position());
	connFile << loc[0] << "," << loc[1] << ",";
	assert(bond2segidmap[ f->bonds[bn] ] == cursegid);
	typename std::set<int>::iterator ni = masterList[cursegid]->neighbs.begin();
	for(ni; ni!=masterList[cursegid]->neighbs.end(); ni++) {
	  connFile << *ni << ",";
	}
	connFile << std::endl;
	cursegid++;
      }
    }

    connFile.close();
  }
  
  template<int N>
  void SemiflexibleGel<N>::printStiffenedSegments(std::string & stiffSegFile, double crit) {
    std::ofstream stiffSF(stiffSegFile.c_str());

    int fn=0;
    int segid = 0;
    for(fn; fn<_filaments.size(); fn++) {
      int bn = 0;
      Filament* f = filament(fn);
      for(bn; bn<f->bonds.size(); bn++) {
	double stiffratio = f->bonds[bn]->stiffnessChange();
	if(stiffratio >= crit || f->bonds[bn]->getLin()) {
	  stiffSF << segid << std::endl;
	}
	segid++;
      }
    }

    
  }

  template<int N>
  void SemiflexibleGel<N>::stiffenRandomSegments(double frac, double mult) {
    std::vector<Bond*> bondList;
    for(int fn=0; fn<_filaments.size(); fn++) {
      Filament* f = filament(fn);
      for(int bn=0; bn<f->bonds.size(); bn++) {
	bondList.push_back(f->bonds[bn]);
      }
    }

    int nStiff = (int)(frac*bondList.size());

    typename std::vector<Bond*>::iterator bi;
    
    ranlib::Uniform<double> runi;
    runi.seed((unsigned int)time(0));

    for(int ns=0; ns<nStiff; ns++) {
      bi = bondList.begin();
      int removeit = (int)(bondList.size()*runi.random());
      for(int j=0; j<removeit; j++) {
	bi++;
      }
      (*bi)->setLin(mult);
      bondList.erase(bi);
    }
  }

  template<int N>
  void SemiflexibleGel<N>::moveCLNodes(Filament * f) {
    int nNodes = f->nodes.size();
    int dn = 0;
    while(_crosslinkNodes.find(f->nodes[dn]) != _crosslinkNodes.end()) dn++;
    assert(dn<nNodes);
    VectorND ref;
    ref = f->nodes[dn]->point();
    for(dn = 0; dn<nNodes; dn++) {     
      if(_crosslinkNodes.find(f->nodes[dn]) != _crosslinkNodes.end()) {
        VectorND diff;
        diff = f->nodes[dn]->point() - ref;
	_box->mapDistance(diff);
	diff += ref;
	f->nodes[dn]->setPoint(diff);
      } 
    }
  }

  template<int N>
  void SemiflexibleGel<N>::compute( bool f0, bool f1, bool f2 ) {

    // Predictor/corrector approach for constraint
    int nConstraints = _constraints.size();

#ifdef _OPENMP	
#pragma omp parallel default(shared)
#endif
    {
#ifdef _OPENMP
#pragma omp for schedule(static) nowait
#endif
      for(int ic=0; ic<nConstraints; ic++) {
	// if(ic%1000==0) std::cout << "predicting with constraint " << ic << std::endl;
	_constraints[ic]->predict();
      }
    } 

    if( f0 ) _energy = 0.0;
    
    // compute energy and forces
    int nFils = _filaments.size();

#ifdef _OPENMP	
#pragma omp parallel default(shared)
#endif
    {
#ifdef _OPENMP
#pragma omp for schedule(static) nowait
#endif
      for(int i=0; i<nFils; i++) {
	// if(i%1000==0) std::cout << "computing on filament " << i << std::endl;
	Filament * f= filament(i);
	//moveCLNodes(f);
	for( BondIterator b = f->bonds.begin(); b!= f->bonds.end(); b++ ) {
	  (*b)->compute(f0,f1,f2);
	}
	// 	for( RodIterator r = f->rods.begin(); r!= f->rods.end(); r++ ) {
	// 	  (*r)->compute(f0,f1,f2);
	// 	}
	for( AngleIterator a = f->angles.begin(); a!= f->angles.end(); a++ ) {
	  (*a)->compute(f0,f1,f2);
	}
      }
    }   

    for( CrosslinkIterator c=_crosslinks.begin(); c!=_crosslinks.end(); c++) {
      (*c)->compute(f0,f1,f2);
    }

    for( MotorIterator m=_motors.begin(); m!=_motors.end(); m++) {
      if((*m)->isAttached()) (*m)->compute(f0,f1,f2);
    }

    int nPinches = _pinches.size();

#ifdef _OPENMP	
#pragma omp parallel default(shared)
#endif
    {
#ifdef _OPENMP
#pragma omp for schedule(static) nowait
#endif
      for(int pn=0; pn<nPinches; pn++) {
        pinch(pn)->compute(f0,f1,f2);
      }
    }

    int ntbp = _tbp.size();
    double tbpenergy = 0.0;
    if(ntbp!=0) {
      std::map< Filament*,std::set<Filament*> > & filpairs = _grid->getNeighbors();
      for(typename std::map< Filament*,std::set<Filament*> >::iterator fp = filpairs.begin(); fp!=filpairs.end(); fp++) {
	Filament* fil1 = fp->first;
	for(typename std::set<Filament*>::iterator partners=fp->second.begin(); partners!=fp->second.end(); partners++) {
	  Filament* fil2 = *partners;
	  if(fil1<fil2) {
	    for(int tb=0; tb<ntbp; tb++) {
	      tbpenergy += _tbp[tb]->compute(fil1->nodes,fil2->nodes,f0,f1,f2);
	    }
	  }
	}
      }
    }

    if(_viscReg!=0) {
      _viscReg->compute(f0,f1,f2);
    }

    //checkParallelForces();
    
    // sum energy
    if( f0 ) {
      double tmpenergy = 0.0;
#ifdef _OPENMP	
#pragma omp parallel default(shared)
#endif
      {
#ifdef _OPENMP
#pragma omp for schedule(static) nowait reduction(+:tmpenergy)
#endif
	for(int i=0; i<nFils; i++) {
	  // if(i%1000==0) std::cout << "computing on filament " << i << std::endl;
	  Filament * f = filament(i);
	  for( BondIterator b = f->bonds.begin(); b!= f->bonds.end(); b++ ) {
	    tmpenergy += (*b)->energy();
	  }
	  for( AngleIterator a = f->angles.begin(); a!= f->angles.end(); a++ ) {
	    tmpenergy += (*a)->energy();
	  }
	}
      }
      
      for(CrosslinkIterator c=_crosslinks.begin(); c!=_crosslinks.end(); c++) {
        tmpenergy += (*c)->energy();
      }


#ifdef _OPENMP	
#pragma omp parallel default(shared)
#endif
      {
#ifdef _OPENMP
#pragma omp for schedule(static) nowait reduction(+:tmpenergy)
#endif
        for(int pn=0; pn<nPinches; pn++) {
	  tmpenergy += pinch(pn)->energy();
        }
      }

      if(_viscReg!=0) tmpenergy += _viscReg->energy();

      _energy = tmpenergy + tbpenergy;

      
    } 

    // Predictor/corrector approach for constraint

#ifdef _OPENMP	
#pragma omp parallel default(shared)
#endif
    {
#ifdef _OPENMP
#pragma omp for schedule(static) nowait
#endif
      for(int ic=0; ic<nConstraints; ic++) {
	_constraints[ic]->correct();
      }
    }

  }

  template<int N>
  void SemiflexibleGel<N>::printParaview(const std::string name) const {

    //     //     std::cout << "SemiflexibleGel<N>::printParaview()." << std::endl;
    //     //
    //     // open file
    //     //
    //     std::string fileName = name + ".vtk";
    //     std::ofstream ofs(fileName.c_str());
    //     if (!ofs) {
    //       std::cout << "Error: can not open paraview output file "
    // 		<< fileName
    // 		<< std::endl;
    //       return;
    //     }
    
    //     //
    //     //    Node position data
    //     //
    
    //     std::map<DefNode*,int> nodeIDMap;
    //     std::vector<DefNode*> printNodes;
    //     std::set<DefNode*> imageNodes;
    //     std::vector< std::pair<DefNode*,DefNode*> > mainPairs;
    //     std::vector< std::pair<DefNode*,DefNode*> > imgPairs;
    //     int nodeCount = 0;

    //     //double shear = _box->shear();
    //     double shear = 0.0;
    //     _box->setShear(0.0);
    //     int nodeID = 0;
    //     for(FilamentIterator fi=_filaments.begin(); fi!=_filaments.end(); fi++) {
    //       Filament* f1 = *fi;
    //       int nfNodes = f1->nodes.size();
    //       for(int nn=0; nn<nfNodes-1; nn++) {
    // 	VectorND mapPos1;
    // 	mapPos1 = f1->nodes[nn]->position();
    // 	_box->mapPoint(mapPos1);
    // // 	VectorND def1;
    // // 	def1 = f1->nodes[nn]->point() - mapPos1;
    // // 	_box->setShear(shear);
    // // 	_box->mapDistance(def1);
    // // 	_box->setShear(0.0);
    // // 	def1 += mapPos1;
    // // 	DefNode* newNode1 = new BrownianNode<2>(nodeID,f1->nodes[nn]->index(),mapPoint,def1);
    // 	nodeIDMap.insert(pair<DefNode*,int>(f1->nodes[nn],nodeID));
    // 	nodeID++;
    // 	nodeCount++;
    // 	printNodes.push_back(f1->nodes[nn]);
    // 	VectorND mapPos2;
    // 	mapPos2 = f1->nodes[nn+1]->position();
    // 	_box->mapPoint(mapPos2);
    // 	VectorND diff;
    // 	diff = mapPos2 - mapPos1;
    // 	double candist = norm2(diff);
    // 	_box->mapDistance(diff);
    // 	double dist = norm2(diff);
    // 	// if bond crosses boundary, make image nodes //
    // 	if(fabs(dist-candist) > 1.0e-6) {
    // 	  VectorND img1pos;
    // 	  img1pos = mapPos2 - diff;
    // 	  VectorND disp;
    // 	  disp = f1->nodes[nn]->point() - img1pos;
    // 	  _box->setShear(shear);
    // 	  _box->mapDistance(disp);
    // 	  _box->setShear(0.0);
    // 	  disp += img1pos;
    // 	  DefNode* imgNode1 = new BrownianNode<2>(nodeID,f1->nodes[nn]->index(),img1pos,disp);
    // 	  nodeIDMap.insert(pair<DefNode*,int>(imgNode1,nodeID));
    // 	  nodeID++;
    // 	  nodeCount++;
    // 	  printNodes.push_back(imgNode1);
    // 	  imageNodes.insert(imgNode1);
    // 	  imgPairs.insert(pair<DefNode*,DefNode*>(imgNode1,f1->nodes[nn+1]));
    // 	  VectorND img2pos;
    // 	  img2pos = mapPos1 + diff;
    // 	  VectorND disp2;
    // 	  disp2 = f1->nodes[nn+1]->point() - img2pos;
    // 	  _box->setShear(shear);
    // 	  _box->mapDistance(disp2);
    // 	  _box->setShear(0.0);
    // 	  disp2 += img2pos;
    // 	  DefNode* imgNode2 = new BrownianNode<2>(f1->nodes[nn+1]->id(),f1->nodes[nn+1]->index(),img2pos,disp2);
    // 	  nodeIDMap.insert(pair<DefNode*,int>(imgNode2,nodeID));
    // 	  nodeID++;
    // 	  nodeCount++;
    // 	  printNodes.push_back(imgNode2);
    // 	  imageNodes.insert(imgNode2);
    // 	  mainPairs.insert(pair<DefNode*,DefNode*>(f1->nodes[nn],imgNode2));
    // 	}
    // 	// if not, just add node pair //
    // 	else {
    // 	  mainPairs.insert(pair<DefNode*,DefNode*>(f1->nodes[nn],f1->nodes[nn+1]));
    // 	}
    //       }
    //       // now add last node //
    //       nodeIDMap.insert(pair<DefNode*,int>(f1->nodes[nfNodes-1],nodeID));
    //       nodeID++;
    //       nodeCount++;
    //       printNodes.push_back(f1->nodes[nfNodes-1]);
    //     }

    //     // count up all filament nodes
    //     int nNodes = nodeCount;

    //     // now do same image thingy with motors/pinches... //
    //     //nNodes += _motors.size()*2;
    //     //nNodes += _pinches.size()*2;

    //     //Mo
    //     for( ConstCrosslinkIterator c=_crosslinks.begin(); c!=_crosslinks.end(); c++ ) {
    //       const DefNodeContainer & crosslinknodes = (*c)-> getNodes();
    //       nNodes += crosslinknodes.size();
    //     }

    //     assert(nNodes == printNodes.size());
    
    //     ofs << "# vtk DataFile Version 2.0\n"
    // 	<< "Test example" << std::endl
    // 	<< "ASCII" << std::endl
    // 	<< "DATASET POLYDATA" << std::endl
    // 	<< "POINTS  " << nNodes << "  double" << std::endl;
    

    //     // output nodal postions
    //     for(DefNodeIterator nid=printNodes.begin(); nid!=printNodes.end(); nid++ ) {
    //       Vector2D & nodalPos = (*nid)->position();
    //       // if the node is NOT an image node, map its position //
    //       if(imageNodes.find(*nid) == imageNodes.end()) {
    // 	_box->setShear(0.0);
    // 	_box->mapPoint(nodalPos);       
    //       }
    //       ofs << std::setprecision(16) 
    // 	  << nodalPos(0) << "  "
    // 	  << 0.0 << "  "
    // 	  << nodalPos(1) << std::endl;
    //     }

    // //     for (ConstMotorIterator m=_motors.begin(); m!=_motors.end(); m++) {
    // //       const Vector2D & nodalPos1 = (*m)->getStartPoint();
    // //       const Vector2D & nodalPos2 = (*m)->getStartPoint();
    // //       ofs << std::setprecision(16)
    // // 	  << nodalPos1(0) << "  "
    // // 	  << 0.0 << "  "
    // //           << nodalPos1(1) <<std::endl;
    // //       ofs << std::setprecision(16)
    // // 	  << nodalPos2(0) << "  "
    // // 	  << 0.0 << "  "
    // //           << nodalPos2(1) <<std::endl;
    // //     }

    // //     //Mo
    // //     for( ConstCrosslinkIterator c=_crosslinks.begin(); c!=_crosslinks.end(); c++ ) {
    // //       const DefNodeContainer & crosslinknodes = (*c)-> getNodes();
    // //       ConstDefNodeIterator pn = crosslinknodes.begin();
    // //       for ( ; pn!= crosslinknodes.end(); pn ++) {
    // //         const Vector2D & nodalPos = (*pn)->position();
    // //         ofs << std::setprecision(16) 
    // // 	    << nodalPos(0) << "  "
    // // 	    << 0.0 << "  "
    // // 	    << nodalPos(1) << std::endl;
    // //       }
    // //     }

    //     //
    //     // segment connectivity data
    //     //

    //     int nSegments = mainPairs.size() + imgPairs.size();

    //     int nSegsMeas = 0;
    //     for( ConstFilamentIterator f=_filaments.begin(); f!=_filaments.end(); f++ ) {
    //       nSegsMeas += (*f)->bonds.size();
    //     }
    //     assert(nSegsMeas == mainPairs.size());

    // //     nSegments += _motors.size();

    // //     //Mo
    // //     for( ConstCrosslinkIterator c=_crosslinks.begin(); c!=_crosslinks.end(); c++ ) {
    // //       nSegments++;
    // //     }

    //     ofs << "LINES  " << nSegments << "  "
    // 	<< 3*nSegments << std::endl;
    //     for( typename std::vector< pair<DefNode*,DefNode*> >::iterator np=mainPairs.begin(); np!=mainPairs.end(); np++ ) {
    //       DefNode* n1 = np->first;
    //       DefNode* n2 = np->second;
    //       int indx1 = nodeIDMap[n1];
    //       int indx2 = nodeIDMap[n2];

    //       ofs << 2 << "  "
    // 	  << std::setw(10) << indx1
    // 	  << std::setw(10) << indx2
    // 	  << std::endl;
     
    //     }

    //     for( typename std::vector< pair<DefNode*,DefNode*> >::iterator np=imgPairs.begin(); np!=imgPairs.end(); np++ ) {
    //       DefNode* n1 = np->first;
    //       DefNode* n2 = np->second;
    //       int indx1 = nodeIDMap[n1];
    //       int indx2 = nodeIDMap[n2];

    //       ofs << 2 << "  "
    // 	  << std::setw(10) << indx1
    // 	  << std::setw(10) << indx2
    // 	  << std::endl;
     
    //     }
    // //     for( ConstMotorIterator m=_motors.begin(); m!=_motors.end(); m++ ) {
    // //       ofs << 2 << "  "
    // // 	  << std::setw(10) << nodeID
    // // 	  << std::setw(10) << nodeID+1
    // // 	  << std::endl;
    // //       nodeID += 2;
    // //     }
     	
    // //     //Mo
    // //     for( ConstCrosslinkIterator c=_crosslinks.begin(); c!=_crosslinks.end(); c++ ) {
    // //       ofs << 2 << "  "
    // // 	  << std::setw(10) << nodeID
    // // 	  << std::setw(10) << nodeID+1
    // // 	  << std::endl;
    // //       nodeID+=2;
    // //     }

    //     //
    //     //  output energy for each segment
    //     //
    // //     ofs << "CELL_DATA    " << nSegments << std::endl;

    // //     ofs << "SCALARS    Energy    double    1" << std::endl;
    // //     ofs << "LOOKUP_TABLE default" << std::endl;
    // //     for( ConstFilamentIterator f=_filaments.begin(); f!=_filaments.end(); f++ ) {
    // //       int firstAngle=0;
    // //       int lastAngle=(*f)->angles.size()-1;   //What happened to those two variables???  --Mo
    // //       for(int a=0; a < (*f)->bonds.size(); a++) {
    // // 	double energy = (*f)->bonds[a]->energy();
    // // 	// 	energy += 0.5*(*f)->bonds[std::max(a-1,firstAngle)]->energy();
    // // 	// 	energy += 0.5*(*f)->bonds[std::min(a,lastAngle)]->energy();
    // // 	ofs << energy << std::endl;
    // //       }
    // //     }
    // //     for( ConstMotorIterator m=_motors.begin(); m!=_motors.end(); m++ ) {
    // //       ofs << (*m)->energy() << std::endl;
    // //     }
    // //     ofs << std::endl;

    // //     //Mo
    // //     for( ConstCrosslinkIterator c=_crosslinks.begin(); c!=_crosslinks.end(); c++ ) {
    // //       double energy = (*c)->energy();
    // //       ofs << energy << std::endl;
    // //     }
      
    // //     ofs << std::endl;

    //     ofs << "SCALARS    Energy    double    1" << std::endl;
    //     ofs << "LOOKUP_TABLE default" << std::endl;
    //     for( ConstFilamentIterator f=_filaments.begin(); f!=_filaments.end(); f++ ) {
    //       int nAngles = (*f)->angles.size();   //What happened to those two variables???  --Mo
    //       for(int a=0; a < (*f)->bonds.size(); a++) {
    // 	double energy = (*f)->bonds[a]->energy();
    // 	if(a==0 && nAngles>0) energy += .5*(*f)->angles[0]->energy();
    // 	else if(a==(*f)->bonds.size()-1 && nAngles>0) energy += .5*(*f)->angles[nAngles-1]->energy();
    // 	else if(nAngles>0) {
    // 	  energy += 0.5*(*f)->angles[a]->energy();
    // 	  energy += 0.5*(*f)->angles[a-1]->energy();
    // 	}
    // 	ofs << energy << std::endl;
    //       }
    //     }

    //     for(int iip=0; iip<imgPairs.size(); iip++) ofs << -1.0 << std::endl;
 
    // //     for( ConstMotorIterator m=_motors.begin(); m!=_motors.end(); m++ ) {
    // //       ofs << (*m)->energy() << std::endl;
    // //     }
    // //     ofs << std::endl;

    // //     //Mo
    // //     for( ConstCrosslinkIterator c=_crosslinks.begin(); c!=_crosslinks.end(); c++ ) {
    // //       double energy = (*c)->energy();
    // //       ofs << energy << std::endl;
    // //     }
      
    //     ofs << std::endl;

    //     ofs << "SCALARS    BendEnergy    double    1" << std::endl;
    //     ofs << "LOOKUP_TABLE default" << std::endl;
    //     for( ConstFilamentIterator f=_filaments.begin(); f!=_filaments.end(); f++ ) {
    //       int nAngles = (*f)->angles.size();   //What happened to those two variables???  --Mo
    //       for(int a=0; a < (*f)->bonds.size(); a++) {
    // 	double energy = 0.0;
    // 	if(a==0 && nAngles>0) energy += .5*((*f)->angles[0]->energy());
    // 	else if(a==(*f)->bonds.size()-1 && nAngles>0) energy += 0.5*((*f)->angles[nAngles-1]->energy());
    // 	else if(nAngles>0) {
    // 	  energy += 0.5*((*f)->angles[a]->energy());
    // 	  energy += 0.5*((*f)->angles[a-1]->energy());
    // 	}
    // 	ofs << energy << std::endl;
    //       }
    //     }

    //     for(int iip=0; iip<imgPairs.size(); iip++) ofs << -1.0 << std::endl;

    //     for( ConstMotorIterator m=_motors.begin(); m!=_motors.end(); m++ ) {
    //       ofs << 0.0 << std::endl;
    //     }
    //     ofs << std::endl;

    //     //Mo
    //     for( ConstCrosslinkIterator c=_crosslinks.begin(); c!=_crosslinks.end(); c++ ) {
    //       double energy = (*c)->energy();
    //       ofs << 0.0 << std::endl;
    //     }
      
    //     ofs << std::endl;

    //     ofs << "SCALARS    StretchEnergy    double    1" << std::endl;
    //     ofs << "LOOKUP_TABLE default" << std::endl;
    //     for( ConstFilamentIterator f=_filaments.begin(); f!=_filaments.end(); f++ ) {
    //       for(int a=0; a < (*f)->bonds.size(); a++) {
    // 	double energy = (*f)->bonds[a]->energy();
    // 	ofs << energy << std::endl;
    //       }
    //     }
    //     for(int iip=0; iip<imgPairs.size(); iip++) ofs << -1.0 << std::endl;

    //     for( ConstMotorIterator m=_motors.begin(); m!=_motors.end(); m++ ) {
    //       ofs << (*m)->energy() << std::endl;
    //     }
    //     ofs << std::endl;

    //     //Mo
    //     for( ConstCrosslinkIterator c=_crosslinks.begin(); c!=_crosslinks.end(); c++ ) {
    //       double energy = (*c)->energy();
    //       ofs << energy << std::endl;
    //     }
      
    //     ofs << std::endl;

    //     ofs << "SCALARS    Angle    double    1" << std::endl;
    //     ofs << "LOOKUP_TABLE default" << std::endl;
    //     for( ConstFilamentIterator f=_filaments.begin(); f!=_filaments.end(); f++ ) {
    //       for(int a=0; a < (*f)->bonds.size(); a++) {
    // 	VectorND sep;
    // 	sep = (*f)->nodes[a+1]->position() - (*f)->nodes[a]->position();
    // 	double ang = atan2(sep[1],sep[0]);
    // 	if(ang < -M_PI/2.0) ang += M_PI;
    // 	else if(ang >= M_PI/2.0) ang -= M_PI;
    // 	ofs << ang << std::endl;
    //       }
    //     }

    //     for(int iip=0; iip<imgPairs.size(); iip++) ofs << -1.0 << std::endl;

    //     for( ConstMotorIterator m=_motors.begin(); m!=_motors.end(); m++ ) {
    //       ofs << 0.0 << std::endl;
    //     }
    //     ofs << std::endl;

    //     //Mo
    //     for( ConstCrosslinkIterator c=_crosslinks.begin(); c!=_crosslinks.end(); c++ ) {
    //       double energy = (*c)->energy();
    //       ofs << 0.0 << std::endl;
    //     }
      
    //     ofs << std::endl;

    //     ofs << "SCALARS    FilLen    double    1" << std::endl;
    //     ofs << "LOOKUP_TABLE default" << std::endl;
    //     for( ConstFilamentIterator f=_filaments.begin(); f!=_filaments.end(); f++ ) {
    //       VectorND e2e;
    //       int nNodes = (*f)->nodes.size();
    //       e2e = (*f)->nodes[nNodes-1]->position() - (*f)->nodes[0]->position();
    //       double fl = norm2(e2e);
    //       for(int a=0; a < (*f)->bonds.size(); a++) {
    // 	ofs << fl << std::endl;
    //       }
    //     }

    //     for(int iip=0; iip<imgPairs.size(); iip++) ofs << -1.0 << std::endl;

    //     for( ConstMotorIterator m=_motors.begin(); m!=_motors.end(); m++ ) {
    //       ofs << 0.0 << std::endl;
    //     }
    //     ofs << std::endl;

    //     //Mo
    //     for( ConstCrosslinkIterator c=_crosslinks.begin(); c!=_crosslinks.end(); c++ ) {
    //       double energy = (*c)->energy();
    //       ofs << 0.0 << std::endl;
    //     }
      
    //     ofs << std::endl;

    //     ofs << std::endl << "POINT_DATA " << nNodes << std::endl
    // 	<< "VECTORS displacements double" << std::endl;

    //     // output nodal displacements
    //     for(DefNodeIterator nid=printNodes.begin(); nid!=printNodes.end(); nid++ ) {
    //       Vector2D & nodalPos = (*nid)->position();
    //       Vector2D nodalDisp;
    //       // if the node is NOT an image node, map its point //
    //       if(imageNodes.find(*nid) == imageNodes.end()) {
    // 	_box->setShear(0.0);
    // 	_box->mapPoint(nodalPos);
    // 	nodalDisp = (*nid)->point() - nodalPos;
    // 	_box->setShear(shear);
    // 	_box->mapDistance(nodalDisp);
    // 	_box->setShear(0.0);
    //       }
    //       else nodalDisp = (*nid)->point() - (*nid)->position();
      
    //       ofs << std::setprecision(16) 
    // 	  << nodalDisp(0) << '\t' 
    // 	  << 0.0 << '\t' 
    // 	  << nodalDisp(1)  << std::endl;
      
    //     }
    //     for (ConstMotorIterator m=_motors.begin(); m!=_motors.end(); m++) {
    //       Vector2D nodalPos1; 
    //       nodalPos1 = (*m)->getEndPoint1()-(*m)->getStartPoint();
    //       Vector2D nodalPos2;
    //       nodalPos2 = (*m)->getEndPoint2()-(*m)->getStartPoint();
    //       ofs << std::setprecision(16)
    // 	  << nodalPos1(0) << "  "
    // 	  << 0.0 << "  "
    //           << nodalPos1(1) <<std::endl;
    //       ofs << std::setprecision(16)
    // 	  << nodalPos2(0) << "  "
    // 	  << 0.0 << "  "
    //           << nodalPos2(1) <<std::endl;
    //     }
    
    //     //Mo
    //     for( ConstCrosslinkIterator c=_crosslinks.begin(); c!=_crosslinks.end(); c++ ) {
    //       const DefNodeContainer & crosslinknodes = (*c)-> getNodes();
    //       ConstDefNodeIterator pn = crosslinknodes.begin();
    //       for ( ; pn!= crosslinknodes.end(); pn ++) {
    //         Vector2D nodalDisp;
    //         nodalDisp = (*pn)->point() - (*pn)->position();
    //         ofs << std::setprecision(16) 
    // 	    << nodalDisp(0) << '\t'
    // 	    << 0.0 << '\t'
    // 	    << nodalDisp(1) << std::endl;
    // 	//cout << " semiflexible " << (*pn) <<' ' << (*pn)->point() <<endl;
    //       }
      
    //     }

    //     ofs << std::endl << "VECTORS forces double" << std::endl;
    //     // output nodal forces
    //     for(DefNodeIterator nid=printNodes.begin(); nid!=printNodes.end(); nid++ ) {
    // //       Vector2D & nodalPos = (*nid)->position();
    // //       Vector2D nodalDisp;
    // //       // if the node is NOT an image node, map its point //
    // //       if(imageNodes.find(*nid) == imageNodes.end()) {
    // // 	_box->setShear(0.0);
    // // 	_box->mapPoint(nodalPos);
    // // 	nodalDisp = (*nid)->point() - nodalPos;
    // // 	_box->setShear(shear);
    // // 	_box->mapDistance(nodalDisp);
    // // 	_box->setShear(0.0);
    // //       }
    // //       else nodalDisp = (*nid)->point() - (*nid)->position();

    //       const Vector2D & nodalForce = (*nid)->force();
      
    //       ofs << std::setprecision(16) 
    // 	  << nodalForce(0) << '\t' 
    // 	  << 0.0 << '\t' 
    // 	  << nodalForce(1)  << std::endl;
      
    //     }

    //     for (ConstMotorIterator m=_motors.begin(); m!=_motors.end(); m++) {
    //       ofs << std::setprecision(16)
    // 	  << 0.0 << '\t'
    // 	  << 0.0 << '\t'
    // 	  << 0.0 << std::endl;
    //       ofs << std::setprecision(16)
    // 	  << 0.0 << '\t'
    // 	  << 0.0 << '\t'
    // 	  << 0.0 << std::endl;
    //     }


    //     //Mo
    //     for( ConstCrosslinkIterator c=_crosslinks.begin(); c!=_crosslinks.end(); c++ ) {
    //       const DefNodeContainer & crosslinknodes = (*c)-> getNodes();
    //       ConstDefNodeIterator pn = crosslinknodes.begin();
    //       for ( ; pn!= crosslinknodes.end(); pn ++) {
    //         const Vector2D & nodalForce = (*pn)->force();
    //         ofs << std::setprecision(16) 
    // 	    << nodalForce(0) << '\t'
    // 	    << 0.0 << '\t'
    // 	    << nodalForce(1) << std::endl;
    //       }
    //     }
    
    //     ofs.close();

    //     printNodes.clear();
    //     imageNodes.clear();
    //     mainPairs.clear();
    //     imgPairs.clear();
    //     nodeIDMap.clear();

    return;

  }
  
  template<int N>
  void SemiflexibleGel<N>::storeGel(std::string fileName) {
    int intSize = sizeof(int);
    int doubleSize = sizeof(double);

    std::ofstream outFile(fileName.data(), ios::out | ios::binary);
    VectorND sysSize(_box->size());
    for(int i=0; i<N; i++) {
      double curSS = sysSize[i];
      outFile.write((char *)(&curSS),doubleSize);
    }
    int nFils = _filaments.size();
    outFile.write((char *)(&nFils),intSize);
    
    std::vector<intPair> slaveCLs(_constraints.size());
    std::vector<intPair> tmpMastCLs(_constraints.size());
    std::vector<intPair> mastCLs(_constraints.size());
    std::multimap<DefNode*, int> slaveInds;
    int sn = 0;
    int mn = 0;
    
    for(int j=0; j<nFils; j++) {
      Filament * f = filament(j);
      int nNodesHere = f->nodes.size();
      outFile.write((char *)(&nNodesHere),intSize);
      for(int k=0; k<nNodesHere; k++) {
	DefNode * curNode = f->nodes[k];
	VectorND curPos(curNode->point());
	VectorND refPos(curNode->position());
	for(int kdof=0; kdof<N; kdof++) {
	  double cpdof = curPos[kdof];
	  outFile.write((char *)(&cpdof),doubleSize);
	}
	for(int kdof=0; kdof<N; kdof++) {
	  double rpdof = refPos[kdof];
	  outFile.write((char *)(&rpdof),doubleSize);
	}
	
	CLNMiter cnmi = _crossNodeMap.find(curNode);
	if(cnmi != _crossNodeMap.end()) {
	  DefNode * mast = cnmi->second;
	  
	  if(mast != curNode) {
	    slaveInds.insert(pair< DefNode*, int >(mast,sn));
	    slaveCLs[sn] = pair< int, int >(j,k);
	    sn++;
	  }
	  
	  else if(mast == curNode) {
	    tmpMastCLs[mn] = pair< int, int >(j,k);
	    mn++;
	  }
	}
      }
    }

    // write the number of crosslinks to the file //
    int nCL = _constraints.size();
    outFile.write((char *)(&nCL),intSize);
    
    // now go back and put master nodes in the right order //
    std::vector<intPair>::iterator pairIter;
    for(pairIter=tmpMastCLs.begin(); pairIter!=tmpMastCLs.end(); pairIter++) {
      DefNode * curMast = filament(pairIter->first)->nodes[pairIter->second];
      std::pair<SNiter, SNiter> sniter; 
      // SNiter sniter;
      sniter = slaveInds.equal_range(curMast);
      // assert(sniter != slaveInds.end());
      SNiter sni;
      for(sni=sniter.first; sni!=sniter.second; sni++) {
        int slaveInd = sni->second;
	mastCLs[slaveInd] = *pairIter;
      }
      // int slaveInd = sniter->second; 
      // mastCLs[slaveInd] = *pairIter;
    }
    
    std::cout << "Gel storage consistency check: # of constraints in gel = " << nCL << ", # of slave nodes = " << slaveCLs.size() << ", # of master nodes = " << mastCLs.size() << "." << std::endl;
    
    for(int cl=0; cl<nCL; cl++) {
      outFile.write((char *)(&(slaveCLs[cl].first)),intSize);
      outFile.write((char *)(&(slaveCLs[cl].second)),intSize);
      outFile.write((char *)(&(mastCLs[cl].first)),intSize);
      outFile.write((char *)(&(mastCLs[cl].second)),intSize);
    }

    // now write out pinches //
    int nPinches = _pinches.size();
    assert(2.0*nPinches == _pinchNodes.size());
    outFile.write((char *)(&nPinches),intSize);

    std::map<DefNode*,DefNode*> pinchPartners;
    for(PinchIterator pi=_pinches.begin(); pi!=_pinches.end(); pi++) {
      std::pair<DefNode*,DefNode*> newPair = (*pi)->getNodes();
      pinchPartners.insert(pair<DefNode*,DefNode*>(newPair));
    }

    std::map< DefNode*,pair<int,int> > partIDs;
    for(int j=0; j<nFils; j++) {
      Filament * ftmp = filament(j);
      int nnds = ftmp->nodes.size();
      for(int k=0; k<nnds; k++) {
	DefNode* nodetmp = ftmp->nodes[k];
	if(_pinchNodes.find(nodetmp) != _pinchNodes.end()) {
	  std::pair<int,int> newIDPair = pair<int,int>(j,k);
	  partIDs.insert(pair< DefNode*,pair<int,int> >(nodetmp,newIDPair));
	}
      }
    }

    int nPinchesWritten = 0;
    for(int j=0; j<nFils; j++) {
      Filament * ftmp = filament(j);
      int nnds = ftmp->nodes.size();
      for(int k=0; k<nnds; k++) {
	DefNode* nodetmp = ftmp->nodes[k];
	if(_pinchNodes.find(nodetmp) != _pinchNodes.end()) {
	  if(pinchPartners.find(nodetmp) != pinchPartners.end()) { 
	    outFile.write((char *)(&j),intSize);
	    outFile.write((char *)(&k),intSize);
	    std::pair<int,int> idPair = partIDs[pinchPartners[nodetmp]];
	    int partj = idPair.first;
	    int partk = idPair.second;
	    outFile.write((char *)(&partj),intSize);
	    outFile.write((char *)(&partk),intSize);
	    nPinchesWritten++;
	  }
	}
      }
    }

    assert(nPinchesWritten == nPinches);
    
    
    std::cout << "Finished storing gel to file " << fileName << "; current file pointer position is " << outFile.tellp() << "." << std::endl;

    outFile.close();
  }

  template<int N>
  void SemiflexibleGel<N>::storeSparseGel(std::string fileName, TempFilamentContainer & tmpFils) {
    int intSize = sizeof(int);
    int doubleSize = sizeof(double);

    std::ofstream outFile(fileName.data(), ios::out | ios::binary);
    VectorND sysSize(_box->size());
    for(int i=0; i<N; i++) {
      double curSS = sysSize[i];
      outFile.write((char *)(&curSS),doubleSize);
    }
    int nFils = tmpFils.size();
    outFile.write((char *)(&nFils),intSize);
    
    int totalCrosslinks = 0;
    for(int j=0; j<nFils; j++) {
      for(int i=0; i<N; i++) {
	double posi = tmpFils[j]->start[i];
	outFile.write((char *)(&posi),doubleSize);
      }
      for(int i=0; i<N; i++) {
	double posi = tmpFils[j]->end[i];
	outFile.write((char *)(&posi),doubleSize);
      }
      typename multimap<double,TempCrosslink*>::iterator cls = tmpFils[j]->crossFils.begin();
      for(cls; cls!=tmpFils[j]->crossFils.end(); cls++) {
        if(cls->second->active && cls->second->baseFil == j) totalCrosslinks++;
      }
    }
	
    //assert(totalCrosslinks%2 == 0);
    //totalCrosslinks /= 2;
	
    outFile.write((char *)(&totalCrosslinks),intSize);
    int writtenCrosslinks = 0;
    for(int j=0; j<nFils; j++) {
      typename multimap<double,TempCrosslink*>::iterator cls = tmpFils[j]->crossFils.begin();
      for(cls; cls!=tmpFils[j]->crossFils.end(); cls++) {
	if(cls->second->active && cls->second->baseFil == j) {
          int nCLFils = cls->second->otherFils.size();
	  outFile.write((char *)(&nCLFils),intSize);
	  typename map< int, VectorND >::iterator ofs = cls->second->otherFils.begin();
	  for(ofs; ofs!=cls->second->otherFils.end(); ofs++) {
	    int filind = ofs->first;
            outFile.write((char *)(&filind),intSize);
	    VectorND cllocalpos;
	    cllocalpos = ofs->second;
	    for(int i=0; i<N; i++) {
	      double clposi = cllocalpos[i];
	      outFile.write((char *)(&clposi),doubleSize);
	    }
          }
	  //VectorND clpos = cls->second->location;
	  //for(int i=0; i<N; i++) {
	  //double clposi = clpos[i];
	  //outFile.write((char *)(&clposi),doubleSize);
	  //}
	  writtenCrosslinks++;
	}
      }
    }

    assert(writtenCrosslinks == totalCrosslinks);
    
    std::cout << "Finished storing gel to file " << fileName << " with " << nFils << " filaments and " << writtenCrosslinks << " crosslinks; current file pointer position is " << outFile.tellp() << "." << std::endl;

    outFile.close();
  }

  template<int N>
  void SemiflexibleGel<N>::printforAbaqus(std::string fileName, double mu, double lB, double minLength, int method) {
    _box->setShear(0.0);
    _box->setShearY(0.0);

    std::ofstream abaqusFile(fileName.c_str());

    // first print out necessary header info //

    abaqusFile << "**BEGIN ABAQUS INPUT FILE" << std::endl << "**" << std::endl
	       << "*HEADING" << std::endl
	       << "BUCKLING ANALYSIS OF A SEMIFLEXIBLE GEL" << std::endl << "**" << std::endl
	       << "*PREPRINT, ECHO=NO, HISTORY=NO, MODEL=NO" << std::endl << "**" << std::endl
	       << "*RESTART, WRITE, FREQ=1" << std::endl << "**" << std::endl
	       << "*FILE FORMAT, ZERO INCREMENT" << std::endl << "**" << std::endl;

    
    // now we must print out the node data //

    abaqusFile << "*NODE" << std::endl;

    std::map<DefNode*,int> nodeIDMap;

    std::vector< std::vector<DefNode*> > tmpNetwork;

    std::vector<int> topNodes;
    std::vector<int> bottomNodes;

    std::vector<int> leftNodes;
    std::vector<int> rightNodes;

    int nid = 1;
    int topCross,botCross,leftCross,rightCross,doubleCross;
    topCross = 0;
    botCross = 0;
    leftCross = 0;
    rightCross = 0;
    doubleCross = 0;

    for(int fn=0; fn<_filaments.size(); fn++) {
      std::vector<DefNode*> tmpFil;
      for(int nb=0; nb<filament(fn)->bonds.size(); nb++) {
	DefNode* curNode = filament(fn)->nodes[nb];
	DefNode* nextNode = filament(fn)->nodes[nb+1];

	VectorND p1;
	p1 = curNode->position();
	if(_crossNodeMap.find(curNode) != _crossNodeMap.end()) {
	  // if master node //
	  if(_crossNodeMap[curNode] == curNode) {
	    tmpFil.push_back(curNode);
	    nodeIDMap.insert(pair<DefNode*,int>(curNode,nid));
	    // print node to file //
	    if(method == 1) {
	      _box->mapPointY(p1);
	    }
	    abaqusFile << nid << ",\t" << p1[0] << ",\t" << p1[1] << std::endl;
	    nid++;
	  }
	  // if slave node //
	  else {
	    tmpFil.push_back(curNode);
	    // comment out next four lines if only writing master node... //
	    nodeIDMap.insert(pair<DefNode*,int>(curNode,nid));
	    if(method == 1) {
	      _box->mapPointY(p1);
	    }
	    abaqusFile << nid << ",\t" << p1[0] << ",\t" << p1[1] << std::endl;
	    nid++;
	  }
	}
	else {
	  tmpFil.push_back(curNode);
	  nodeIDMap.insert(pair<DefNode*,int>(curNode,nid));
	  if(method == 1) {
	    _box->mapPointY(p1);
	  }
	  abaqusFile << nid << ",\t" << p1[0] << ",\t" << p1[1] << std::endl;
	  nid++;
	}
	
	// now check to see whether bond crosses boundary/boundaries //

	if(method == 1) {
	  VectorND p2;
	  p1 = curNode->position();
	  p2 = nextNode->position();
	  VectorND p1map,p2map;
	  p1map = p1;
	  p2map = p2;
	  _box->mapPoint(p1map);
	  _box->mapPoint(p2map);
	  VectorND rawsep;
	  rawsep = p2 - p1;
	  VectorND mapsep;
	  mapsep = p2map - p1map;
	  double draw = norm2(rawsep);
	  double dmap = norm2(mapsep);
	  if(fabs(draw-dmap)>1.0e-6) {
	    // determine crossing points and make new nodes //

	    VectorND r;
	    r = rawsep/draw;
	    // crosses top border //
	    if(fabs(mapsep[1]) > _box->size()[1]/2.0 && fabs(mapsep[0]) <= _box->size()[0]/2.0 && (p1[1] >= _box->size()[1] || p2[1] >= _box->size()[1])) {
	      topCross++;
	      double s;
	      s = (_box->size()[1]-p1[1])/r[1];
	      VectorND crossPt;
	      crossPt = p1 + s*r;
	      //_box->mapPointX(crossPt);
	      DefNode* newNode = new BrownianNode<N>(nid,curNode->index(),crossPt,crossPt);
	      tmpFil.push_back(newNode);
	      nodeIDMap.insert(pair<DefNode*,int>(newNode,nid));
	      abaqusFile << nid << ",\t" << crossPt[0] << ",\t" << crossPt[1] << std::endl;
	      topNodes.push_back(nid);
	      nid++;
	      tmpNetwork.push_back(tmpFil);
	      tmpFil.clear();
	      crossPt[1] = 0.0;
	      newNode = new BrownianNode<N>(nid,curNode->index(),crossPt,crossPt);
	      tmpFil.push_back(newNode);
	      nodeIDMap.insert(pair<DefNode*,int>(newNode,nid));
	      abaqusFile << nid << ",\t" << crossPt[0] << ",\t" << crossPt[1] << std::endl;
	      bottomNodes.push_back(nid);
	      nid++;
	    }
	    // crosses bottom border //
	    else if(fabs(mapsep[1]) > _box->size()[1]/2.0 && fabs(mapsep[0]) <= _box->size()[0]/2.0 && (p1[1] < 0.0 || p2[1] < 0.0)) {
	      botCross++;
	      double s;
	      s = -p1[1]/r[1];
	      VectorND crossPt;
	      crossPt = p1 + s*r;
	      //_box->mapPointX(crossPt);
	      DefNode* newNode = new BrownianNode<N>(nid,curNode->index(),crossPt,crossPt);
	      tmpFil.push_back(newNode);
	      nodeIDMap.insert(pair<DefNode*,int>(newNode,nid));
	      abaqusFile << nid << ",\t" << crossPt[0] << ",\t" << crossPt[1] << std::endl;
	      bottomNodes.push_back(nid);
	      nid++;
	      tmpNetwork.push_back(tmpFil);
	      tmpFil.clear();
	      crossPt[1] = _box->size()[1];
	      newNode = new BrownianNode<N>(nid,curNode->index(),crossPt,crossPt);
	      tmpFil.push_back(newNode);
	      nodeIDMap.insert(pair<DefNode*,int>(newNode,nid));
	      abaqusFile << nid << ",\t" << crossPt[0] << ",\t" << crossPt[1] << std::endl;
	      topNodes.push_back(nid);
	      nid++;
	    }
	  
	    // crosses right border //
	    else if(fabs(mapsep[0]) > _box->size()[0]/2.0 && fabs(mapsep[1]) <= _box->size()[1]/2.0 && (p1[0] >= _box->size()[0] || p2[0] >= _box->size()[0])) {
	      rightCross++;
	      // 	    double s;
	      // 	    s = (_box->size()[0]-p1[0])/r[0];
	      // 	    VectorND crossPt;
	      // 	    crossPt = p1 + s*r;
	      // 	    _box->mapPointY(crossPt);
	      // 	    DefNode* newNode = new BrownianNode<N>(nid,curNode->index(),crossPt,crossPt);
	      // 	    tmpFil.push_back(newNode);
	      // 	    nodeIDMap.insert(pair<DefNode*,int>(newNode,nid));
	      // 	    abaqusFile << nid << ",\t" << crossPt[0] << ",\t" << crossPt[1] << std::endl;
	      // 	    rightNodes.push_back(nid);
	      // 	    nid++;
	      // 	    tmpNetwork.push_back(tmpFil);
	      // 	    tmpFil.clear();
	      // 	    crossPt[0] = 0.0;
	      // 	    newNode = new BrownianNode<N>(nid,curNode->index(),crossPt,crossPt);
	      // 	    tmpFil.push_back(newNode);
	      // 	    nodeIDMap.insert(pair<DefNode*,int>(newNode,nid));
	      // 	    abaqusFile << nid << ",\t" << crossPt[0] << ",\t" << crossPt[1] << std::endl;
	      // 	    leftNodes.push_back(nid);
	      // 	    nid++;
	    }
	    // crosses left border //
	    else if(fabs(mapsep[0]) > _box->size()[0]/2.0 && fabs(mapsep[1]) <= _box->size()[0]/2.0 && (p1[0] < 0.0 || p2[0] < 0.0)) {
	      leftCross++;
	      // 	    double s;
	      // 	    s = -p1[0]/r[0];
	      // 	    VectorND crossPt;
	      // 	    crossPt = p1 + s*r;
	      // 	    _box->mapPointY(crossPt);
	      // 	    DefNode* newNode = new BrownianNode<N>(nid,curNode->index(),crossPt,crossPt);
	      // 	    tmpFil.push_back(newNode);
	      // 	    nodeIDMap.insert(pair<DefNode*,int>(newNode,nid));
	      // 	    abaqusFile << nid << ",\t" << crossPt[0] << ",\t" << crossPt[1] << std::endl;
	      // 	    leftNodes.push_back(nid);
	      // 	    nid++;
	      // 	    tmpNetwork.push_back(tmpFil);
	      // 	    tmpFil.clear();
	      // 	    crossPt[0] = _box->size()[0];
	      // 	    newNode = new BrownianNode<N>(nid,curNode->index(),crossPt,crossPt);
	      // 	    tmpFil.push_back(newNode);
	      // 	    nodeIDMap.insert(pair<DefNode*,int>(newNode,nid));
	      // 	    abaqusFile << nid << ",\t" << crossPt[0] << ",\t" << crossPt[1] << std::endl;
	      // 	    rightNodes.push_back(nid);
	      // 	    nid++;
	    }
	  
	    else {
	      doubleCross++;
	      std::cout << "Segment crosses two borders; add new code!" << std::endl;
	    }
	  }
	}
      }
      // now do last node in filament //

      DefNode* curNode = filament(fn)->nodes[filament(fn)->nodes.size()-1];

      VectorND p1;
      p1 = curNode->position();
      if(_crossNodeMap.find(curNode) != _crossNodeMap.end()) {
	// if master node //
	if(_crossNodeMap[curNode] == curNode) {
	  tmpFil.push_back(curNode);
	  nodeIDMap.insert(pair<DefNode*,int>(curNode,nid));
	  // print node to file //
	  if(method == 1) {
	    _box->mapPointY(p1);
	  }
	  abaqusFile << nid << ",\t" << p1[0] << ",\t" << p1[1] << std::endl;
	  nid++;
	}
	// if slave node //
	else {
	  tmpFil.push_back(curNode);
	  // comment out next four lines if only writing master node... //
	  nodeIDMap.insert(pair<DefNode*,int>(curNode,nid));
	  if(method == 1) {
	    _box->mapPointY(p1);
	  }
	  abaqusFile << nid << ",\t" << p1[0] << ",\t" << p1[1] << std::endl;
	  nid++;
	}
      }
      else {
	tmpFil.push_back(curNode);
	nodeIDMap.insert(pair<DefNode*,int>(curNode,nid));
	if(method == 1) {
	  _box->mapPointY(p1);
	}
	abaqusFile << nid << ",\t" << p1[0] << ",\t" << p1[1] << std::endl;
	nid++;
      }
      
      tmpNetwork.push_back(tmpFil);
    }

    int ghostNodeID;
    if(method == 2) {
      // print ghost node //
      abaqusFile << nid << ",\t" << 0.0 << ",\t" << 0.0 << std::endl;
      abaqusFile << "**" << std::endl
		 <<"*NSET, NSET=GHOSTNODE, UNSORTED" << std::endl;
      abaqusFile << nid << std::endl;
      ghostNodeID = nid;
      nid++;
    }

    if(method == 1) {
      std::cout << topCross << " segments crossed top border," << std::endl
		<< botCross << " segments crossed bottom border," << std::endl
		<< leftCross << " segments crossed left border," << std::endl
		<< rightCross << " segments crossed right border," << std::endl
		<< doubleCross << "segments crossed two borders." << std::endl;
    
      // make boundary node sets //
      // ostringstream boundNodes;

      abaqusFile << "**" << std::endl
		 << "*NSET, NSET=TOPNODES, UNSORTED" << std::endl;
      for(int ti=0; ti<topNodes.size(); ti++) {
	abaqusFile << topNodes[ti] << std::endl;
	//       if(boundNodes.tellp() < 128) {
	// 	boundNodes << topNodes[ti] << ", ";
	//       }
	//       else {
	// 	boundNodes << topNodes[ti];
	// 	abaqusFile << boundNodes.str() << std::endl;
	// 	boundNodes.str("");
	//       }
      }
      //     boundNodes << topNodes[topNodes.size()-1];
      //     abaqusFile << boundNodes.str() << std::endl;
      //     boundNodes.str("");

      abaqusFile << "**" << std::endl
		 << "*NSET, NSET=BOTTOMNODES, UNSORTED" << std::endl;

      for(int bi=0; bi<bottomNodes.size(); bi++) {
	abaqusFile << bottomNodes[bi] << std::endl;
	//       if(boundNodes.tellp() < 128) {
	// 	boundNodes << bottomNodes[bi] << ", ";
	//       }
	//       else {
	// 	boundNodes << bottomNodes[bi];
	// 	abaqusFile << boundNodes.str() << std::endl;
	// 	boundNodes.str("");
	//       }
      }
      //     boundNodes << bottomNodes[bottomNodes.size()-1];
      //     abaqusFile << boundNodes.str() << std::endl;

      //     abaqusFile << "**" << std::endl
      // 	       << "*NSET, NSET=LEFTNODES, UNSORTED" << std::endl;
    
      //     for(int li=0; li<leftNodes.size(); li++) {
      //       abaqusFile << leftNodes[li] << std::endl;
      //     }

      //     abaqusFile << "**" << std::endl
      // 	       << "*NSET, NSET=RIGHTNODES, UNSORTED" << std::endl;
    
      //     for(int ri=0; ri<rightNodes.size(); ri++) {
      //       abaqusFile << rightNodes[ri] << std::endl;
      //     }
    
    }
    // now write connectivites //

    abaqusFile << "**" << std::endl
	       << "*ELEMENT, TYPE=B23, ELSET=ACTIN_SEGS" << std::endl;

    int elemNum = 1;
    int nNewFils = tmpNetwork.size();
    for(int nnf=0; nnf<nNewFils; nnf++) {
      int nNewNodes = tmpNetwork[nnf].size();
      for(int nnn=0; nnn<nNewNodes-1; nnn++) {
	DefNode* nd1 = (tmpNetwork[nnf])[nnn];
	DefNode* nd2 = (tmpNetwork[nnf])[nnn+1];
	abaqusFile << elemNum << ", ";
	int n2r1,n2r2;
	if(nodeIDMap.find(nd1)!=nodeIDMap.end()) {
	  n2r1 = nodeIDMap[nd1];
	}
	else {
	  if(!isSlave(nd1)) {
	    std::cout << "Error: non-slave node not added to node ID map." << std::endl;
	  }
	  else {
	    n2r1 = nodeIDMap[_crossNodeMap[nd1]];
	  }
	}

	if(nodeIDMap.find(nd2)!=nodeIDMap.end()) {
	  n2r2 = nodeIDMap[nd2];
	}
	else {
	  if(!isSlave(nd2)) {
	    std::cout << "Error: non-slave node not added to node ID map." << std::endl;
	  }
	  else {
	    n2r2 = nodeIDMap[_crossNodeMap[nd2]];
	  }
	}

	abaqusFile << n2r1 << ", " << n2r2 << std::endl;

	elemNum++;
      }
    }
    //     for(int nnf=0; nnf<nNewFils; nnf++) {
    //       std::ostringstream nodeList;
    //       nodeList << nnf+1 << ", ";
    //       int nNewNodes = tmpNetwork[nnf].size();
    //       for(int nnn=0; nnn<nNewNodes-1; nnn++) {
    // 	int n2r;
    // 	if(nodeIDMap.find((tmpNetwork[nnf])[nnn])!=nodeIDMap.end()) {
    // 	  n2r = nodeIDMap[(tmpNetwork[nnf])[nnn]];
    // 	}
    // 	else {
    // 	  if(!isSlave((tmpNetwork[nnf])[nnn])) {
    // 	    std::cout << "Error: non-slave node not added to node ID map." << std::endl;
    // 	  }
    // 	  else {
    // 	    n2r = nodeIDMap[_crossNodeMap[(tmpNetwork[nnf])[nnn]]];
    // 	  }
    // 	}
    // 	if(nodeList.tellp() < 128) {
    // 	  nodeList << n2r << ", ";
    // 	}
    // 	else {
    // 	  nodeList << n2r << ",";
    // 	  abaqusFile << nodeList.str() << std::endl;
    // 	  nodeList.str("");	  
    // 	}
    //       }
      
    //       int n2r;
    //       if(nodeIDMap.find((tmpNetwork[nnf])[nNewNodes-1])!=nodeIDMap.end()) {
    // 	n2r = nodeIDMap[(tmpNetwork[nnf])[nNewNodes-1]];
    //       }
    //       else {
    // 	if(!isSlave((tmpNetwork[nnf])[nNewNodes-1])) {
    // 	  std::cout << "Error: non-slave node not added to node ID map." << std::endl;
    // 	}
    // 	else {
    // 	  n2r = nodeIDMap[_crossNodeMap[(tmpNetwork[nnf])[nNewNodes-1]]];
    // 	}
    //       }
    //       nodeList << n2r;
    //       abaqusFile << nodeList.str() << std::endl;
    //     }


    // now we define the element type //
    double rcross = 2.0*lB;
    double Y = mu/(M_PI*sqr(rcross));

    abaqusFile << "**" << std::endl
	       << "*BEAM GENERAL SECTION, ELSET=ACTIN_SEGS, SECTION=CIRC" << std::endl
	       << rcross << std::endl
	       << 0 << ", " << 0 << ", " << -1 << std::endl
	       << Y << std::endl;

    // write info on ties //
    // comment out of writing tied nodes as one node //
    //     abaqusFile << "**" << std::endl
    // 	       << "*ELEMENT, TYPE=CONN2D2, ELSET=PIN_CONSTRAINTS" << std::endl;
    
    //     CLNMiter cli = _crossNodeMap.begin();
    //     int tieNum  = elemNum;
    //     for(cli; cli!=_crossNodeMap.end(); cli++) {
    //       if(cli->first != cli->second) {
    // 	abaqusFile << tieNum << ", " << nodeIDMap[cli->first] << ", " << nodeIDMap[cli->second] << std::endl;
    // 	tieNum++;
    //       }
    //     }
    
    //     abaqusFile << "**" << std::endl
    // 	       << "*CONNECTOR SECTION, ELSET=PIN_CONSTRAINTS" << std::endl
    // 	       << "join" << std::endl;

    // end tie info //

    // instead of ties, specify constraint equations //
    abaqusFile << "**" << std::endl;
    CLNMiter cli = _crossNodeMap.begin();
    for(cli; cli!=_crossNodeMap.end(); cli++) {
      if(cli->first != cli->second) {
	if(method == 1) {
	  abaqusFile << "*EQUATION" << std::endl
		     << 2 << std::endl
		     << nodeIDMap[cli->first] << ", 1, 1.0, " << nodeIDMap[cli->second] << ", 1, -1.0" << std::endl;
	  abaqusFile << "*EQUATION" << std::endl
		     << 2 << std::endl
		     << nodeIDMap[cli->first] << ", 2, 1.0, " << nodeIDMap[cli->second] << ", 2, -1.0" << std::endl;
	}
	else if(method == 2) {
	  // determine proper constraint equation //
	  VectorND tieNodeSep;
	  tieNodeSep = cli->second->position() - cli->first->position();
	  if(fabs(tieNodeSep[1]) > 1.0e-6) {
	    if(cli->second->position()[1] > cli->first->position()[1]) {
	      abaqusFile << "*EQUATION" << std::endl
			 << 3 << std::endl
			 << nodeIDMap[cli->second] << ", 1, 1.0, " << nodeIDMap[cli->first] << ", 1, -1.0, " << ghostNodeID << ", 1, -1.0" << std::endl;
	    }
	    else {
	      abaqusFile << "*EQUATION" << std::endl
			 << 3 << std::endl
			 << nodeIDMap[cli->first] << ", 1, 1.0, " << nodeIDMap[cli->second] << ", 1, -1.0, " << ghostNodeID << ", 1, -1.0" << std::endl;
	    }
	    abaqusFile << "*EQUATION" << std::endl
		       << 2 << std::endl
		       << nodeIDMap[cli->second] << ", 2, 1.0, " << nodeIDMap[cli->first] << ", 2, -1.0" << std::endl;
	    
	  }
	  else {
	    abaqusFile << "*EQUATION" << std::endl
		       << 2 << std::endl
		       << nodeIDMap[cli->first] << ", 1, 1.0, " << nodeIDMap[cli->second] << ", 1, -1.0" << std::endl;
	    abaqusFile << "*EQUATION" << std::endl
		       << 2 << std::endl
		       << nodeIDMap[cli->first] << ", 2, 1.0, " << nodeIDMap[cli->second] << ", 2, -1.0" << std::endl;
	  }
	}
      }
    }
    
   
    // end constraint equations //

    // boundary conditions //

    if(method == 1) {
      abaqusFile << "**" << std::endl
		 << "*BOUNDARY" << std::endl
		 << "BOTTOMNODES, 2, 6" << std::endl
		 << "TOPNODES, 2, 6" << std::endl;
      // 	       << "LEFTNODES, 2" << std::endl
      // 	       << "RIGHTNODES, 2" << std::endl;
    }

    else if(method == 2) {
      abaqusFile << "**" << std::endl
		 << "*BOUNDARY" << std::endl
		 << "GHOSTNODE, 2" << std::endl;
    }




    abaqusFile.close();

  }

  template<int N>
  void SemiflexibleGel<N>::attachMotor(MolMot * mot, const Filament * f1, const Filament * f2) {
    int nNodesFil1 = f1->nodes.size();
    int nNodesFil2 = f2->nodes.size();
    DefNodeIterator node1Iter = f1->nodes.begin();
    DefNodeIterator node2Iter = f2->nodes.begin();
    DefNode * node1A = *node1Iter;
    DefNode * node2A = *node2Iter;
    DefNode * node1B = *(f1->nodes.end()-1);
    DefNode * node2B = *(f2->nodes.end()-1);
    VectorND x1A = node1A->point();
    VectorND x1B = node1B->point();
    VectorND x2A = node2A->point();
    VectorND x2B = node2B->point();
    VectorND xintersect1;
    VectorND xintersect2;
    double end_to_end1 = norm2(x1B-x1A);
    double end_to_end2 = norm2(x2B-x1A);
    double tol = (end_to_end1+end_to_end2)/2.0;

    double a1,a2;
    if(abs(x1B[0]-x1A[0]) > 1.0e-6 && abs(x2B[0]-x2A[0]) > 1.0e-6) {
      a1 = (x1B[1]-x1A[1])/(x1B[0]-x1A[0]);
      a2 = (x2B[1]-x2A[1])/(x2B[0]-x2A[0]);
      xintersect1[0] = (x1A[1]-x2A[1]+a2*x2A[0]-a1*x1A[0])/(a2-a1);
      xintersect1[1] = (a2*(x1A[1]-a1*x1A[0])-a1*(x2A[1]-a2*x2A[0]))/(a2-a1);
    }
    else if(abs(x1B[0]-x1A[0]) <= 1.0e-6 && abs(x2B[0]-x2A[0]) > 1.0e-6){
      xintersect1[0] = x1A[0];
      a2 = (x2B[1]-x2A[1])/(x2B[0]-x2A[0]);
      xintersect1[1] = a2*x1A[0] + x2A[1] - a2*x2A[0];
    }
    else if(abs(x2B[0]-x2A[0]) <= 1.0e-6 && abs(x1B[0]-x1A[0]) > 1.0e-6) {
      xintersect1[0] = x2A[0];
      a1 = (x1B[1]-x1A[1])/(x1B[0]-x1A[0]);
      xintersect1[1] = x1A[1] - a1*(x1A[0] - x2A[0]);
    }
    else {
      xintersect1[0] = (x1A[0]+x2A[0])/2.0;
      xintersect1[1] = 1.0e30;
    }

    int node_jump1 = min((int)(nNodesFil1*norm2(xintersect1-x1A)/end_to_end1),nNodesFil1-2);
    int node_jump2 = min((int)(nNodesFil2*norm2(xintersect1-x2A)/end_to_end2),nNodesFil2-2);

    if(dot(x1B-x1A,xintersect1-x1A)<0.0) {
      node_jump1 = 0;
    }

    if(dot(x2B-x2A,xintersect1-x2A)<0.0) {
      node_jump2 = 0;
    }
      
    bool intersected = false;
    int rad = 1;
    int curRadCounter = 0;
    int totCounter = 0;
    int node1_offset = node_jump1;
    int node2_offset = node_jump2;
      
    while(intersected == false && totCounter < (nNodesFil1-1)*(nNodesFil2-1)) {
      if(node1_offset >= 0 && node2_offset >= 0 && node1_offset < nNodesFil1 - 1 && node2_offset < nNodesFil2 - 1 && (abs(node1_offset-node_jump1) >= (rad-1)/2 || abs(node2_offset-node_jump2) >= (rad-1)/2)) {
	node1A = *(node1Iter + node1_offset);
	node1B = *(node1Iter + node1_offset + 1);
	node2A = *(node2Iter + node2_offset);
	node2B = *(node2Iter + node2_offset + 1);
	x1A = node1A->point();
	x1B = node1B->point();
	x2A = node2A->point();
	x2B = node2B->point();
	intersected = IntersectionFinder<N>::checkIntersection(x1A,x1B,x2A,x2B,xintersect1,xintersect2,tol,_box);
	if(intersected == true) {
	  mot->setPosition(f1->nodes,node1_offset,f2->nodes,node2_offset,xintersect1,xintersect2);
	  _motors.push_back(mot);
	}
	totCounter++;
      }
      curRadCounter++;
      if(curRadCounter >= sqr(rad)) {
	rad += 2;
	curRadCounter = 0;
      }
	
      node2_offset = node_jump2 - ((rad-1)/2) + curRadCounter%rad;
      node1_offset = node_jump1 - ((rad-1)/2) + curRadCounter/rad;
    }
  }
  
  template<int N>
  void SemiflexibleGel<N>::addPinch(DefNode* node1, DefNode* node2, double f0) {
    Pinch * newPinch = new PinchForce<N>(node1,node2,f0,_box);
    _pinches.push_back(newPinch);
    _pinchNodes.insert(node1);
    _pinchNodes.insert(node2);
  }
  
  template<int N>
  void SemiflexibleGel<N>::addPinch(double a, double tol, double f0) {
    
  }

  template<int N>
  void SemiflexibleGel<N>::addPinches(int nPinches, double a, double tol, double f0, bool sameFilament) {
    if(!sameFilament) {
      int nAdded = 0;

      std::set<DefNode*> pinchNodes;

      //       std::set<int> testedFils;

      //       std::set<int> untestedFils;

      //       for(int nf=0;nf<_filaments.size(); nf++) {
      // 	untestedFils.insert(nf);
      //       }

      int nTrials = 0;
      int maxTrials = _filaments.size()*(_filaments.size()-1)*10;
      
      int nBoxesX = (int)(_box->size()[0]/(a+tol));
      int nBoxesY = (int)(_box->size()[1]/(a+tol));

      VectorND boxSize;
      boxSize[0] = _box->size()[0]/nBoxesX;
      boxSize[1] = _box->size()[1]/nBoxesY;

      struct boxofbonds {
	typename std::vector< std::pair<int,int> > bs;
      };

      boxofbonds* bondsets[nBoxesX][nBoxesY];

      for(int nbx=0;nbx<nBoxesX;nbx++) {
	for(int nby=0;nby<nBoxesY;nby++) {
	  (bondsets[nbx])[nby] = new boxofbonds();
	}
      }

      for(int fnum=0; fnum<_filaments.size(); fnum++) {
	Filament* fi = filament(fnum);
	int nNodes = fi->nodes.size();
	for(int nn=0; nn<nNodes-1; nn++) {
	  VectorND bondPos;
	  bondPos = 0.5*(fi->nodes[nn]->position() + fi->nodes[nn+1]->position());
	  bondPos[0] = fmod(bondPos[0]+_box->size()[0],_box->size()[0]);
	  bondPos[1] = fmod(bondPos[1]+_box->size()[1],_box->size()[1]);
	  int xbox,ybox;
	  xbox = (int)(bondPos[0]/boxSize[0]);
	  ybox = (int)(bondPos[1]/boxSize[1]);
	  std::pair<int,int> newPair = pair<int,int>(fnum,nn);
	  ((bondsets[xbox])[ybox]->bs).push_back(newPair);
	}
      }

      while(nAdded<nPinches && nTrials<maxTrials) {
	nTrials++;
	ranlib::Uniform<double> runi;
	runi.seed((unsigned int)(time(0) + nTrials));


	bool pickedFirst = false;
	int x1,y1;
	std::pair<int,int> bond1;
	while(!pickedFirst) {
	  x1 = (int)(runi.random()*nBoxesX);
	  y1 = (int)(runi.random()*nBoxesY);
	  
	  int nBond = (int)(runi.random()*((bondsets[x1])[y1]->bs.size()));
	  
	  if((bondsets[x1])[y1]->bs.size() > 0) {
	    bond1 = (bondsets[x1])[y1]->bs[nBond];
	  
	    if(pinchNodes.find(filament(bond1.first)->nodes[1+bond1.second]) == pinchNodes.end()) {
	      pickedFirst = true;
	    }
	  }
	}
	VectorND p1,e1;
	e1 = filament(bond1.first)->nodes[1+bond1.second]->position() - filament(bond1.first)->nodes[bond1.second]->position();
	double len1 = norm2(e1);
	e1 /= len1;
	p1 = 0.5*(filament(bond1.first)->nodes[1+bond1.second]->position() + filament(bond1.first)->nodes[bond1.second]->position());

	std::map< double,std::pair<int,int> > nearbyBonds;

	for(int dx=-1;dx<=1;dx++) {
	  int x2 = x1 + dx;
	  x2 = (x2+nBoxesX)%nBoxesX;
	  for(int dy=-1;dy<=1;dy++) {
	    int y2 = y1 + dy;
	    y2 = (y2+nBoxesY)%nBoxesY;
	    typename std::vector< pair<int,int> >::iterator bi2 = (bondsets[x2])[y2]->bs.begin();
	    for(bi2; bi2!=(bondsets[x2])[y2]->bs.end(); bi2++) {
	      if(bi2->first != bond1.first) { // make sure they're not on the same filament //
		double rn = runi.random();
		nearbyBonds.insert(pair< double, pair<int,int> >(rn,*bi2));
	      }
	    }
	  }
	}

	int nPotentialPartners = nearbyBonds.size();
	int npp = 0;
	bool added = false;
	typename std::map< double,pair<int,int> >::iterator ppi = nearbyBonds.begin();
	while(npp<nPotentialPartners && !added) {
	  int f2,b2;
	  f2 = (ppi->second).first;
	  b2 = (ppi->second).second;

	  VectorND p2,e2;
	  e2 = filament(f2)->nodes[1+b2]->position() - filament(f2)->nodes[b2]->position();
	  double len2 = norm2(e2);
	  e2 /= len2;
	  p2 = 0.5*(filament(f2)->nodes[1+b2]->position() + filament(f2)->nodes[b2]->position());

	  // check for orientation //
	  if(dot(e1,e2)<0.0) {
	    VectorND sep;
	    sep = p2 - p1;
	    _box->mapDistance(sep);
	    double sepdist = norm2(sep);
	    // check for distance //
	    if(fabs(sepdist-a)<tol) {
	      VectorND motorSep;
	      motorSep = filament(f2)->nodes[b2+1]->position() - filament(bond1.first)->nodes[1+bond1.second]->position();
	      double mslen = norm2(motorSep);
	      motorSep /= mslen;
	      // check for proper positioning //
	      if(dot(e1,motorSep)<0.0) {
		// must check whether these segments are crosslinked and whether nodes are used //
		if(pinchNodes.find(filament(f2)->nodes[b2+1]) == pinchNodes.end()) {
		  DefNode* mast1;
		  DefNode* mast2;
		  bool segsCL = false;
		  if(_crossNodeMap.find(filament(bond1.first)->nodes[1+bond1.second]) != _crossNodeMap.end()) {
		    mast1 = _crossNodeMap[ filament(bond1.first)->nodes[1+bond1.second] ];
		    if(_crossNodeMap.find(filament(f2)->nodes[1+b2]) != _crossNodeMap.end()) {
		      if(_crossNodeMap[ filament(f2)->nodes[1+b2] ] == mast1) segsCL = true;
		    }
		    if(_crossNodeMap.find(filament(f2)->nodes[b2]) != _crossNodeMap.end()) {
		      if(_crossNodeMap[ filament(f2)->nodes[b2] ] == mast1) segsCL = true;
		    }
		  }
		  if(_crossNodeMap.find(filament(bond1.first)->nodes[bond1.second]) != _crossNodeMap.end()) {
		    mast2 = _crossNodeMap[ filament(bond1.first)->nodes[bond1.second] ];
		    if(_crossNodeMap.find(filament(f2)->nodes[1+b2]) != _crossNodeMap.end()) {
		      if(_crossNodeMap[ filament(f2)->nodes[1+b2] ] == mast2) segsCL = true;
		    }
		    if(_crossNodeMap.find(filament(f2)->nodes[b2]) != _crossNodeMap.end()) {
		      if(_crossNodeMap[ filament(f2)->nodes[b2] ] == mast2) segsCL = true;
		    }
		  }

		  if(!segsCL) {
		    // if all tests are passed, make pinch //
		    nAdded++;
		    added = true;
		    pinchNodes.insert(filament(bond1.first)->nodes[1+bond1.second]);
		    pinchNodes.insert(filament(f2)->nodes[1+b2]);
		    addPinch(filament(bond1.first)->nodes[1+bond1.second],filament(f2)->nodes[1+b2],f0);
		  }
		}
	      }
	    }
	  }
	  
	  npp++;
	  ppi++;
	}
      }
      
      if(nAdded != nPinches) {
	std::cout << nPinches << " pinches requested, but only " << nAdded << " pinches added." << std::endl;
      }
      
      else {
	assert(_pinches.size() == nPinches);
	std::cout << "Added " << nAdded << " pinches to system." << std::endl;
      }

      
    }
    
    
    //       while(nAdded<nPinches && nTrials<maxTrials) {
    // 	nTrials++;
	
    // 	ranlib::Uniform<double> runi;
    // 	runi.seed((unsigned int)(time(0) + nTrials));
    // 	int i = (int)(runi.random()*_filaments.size());
	
    // 	VectorND start1;
    // 	start1 = filament(i)->nodes[0]->position();
    // 	VectorND end1;
    // 	end1 = filament(i)->nodes[filament(i)->nodes.size()-1]->position();
    // 	VectorND endtoend1;
    // 	endtoend1 = end1 - start1;
    // 	double len1 = norm2(endtoend1);

    // 	int j = (int)(runi.random()*_filaments.size());
    // 	while(j==i) {
    // 	  j = (int)(runi.random()*_filaments.size());
    // 	}
	
	
    // 	VectorND start2;
    // 	start2 = filament(j)->nodes[0]->position();
    // 	VectorND end2;
    // 	end2 = filament(j)->nodes[filament(j)->nodes.size()-1]->position();
    // 	VectorND endtoend2;
    // 	endtoend2 = end2 - start2;
    // 	double len2 = norm2(endtoend2);
	
	
    // 	VectorND sep;
    // 	sep = start1-start2;
    // 	_box->mapDistance(sep);
    // 	double dist = norm2(sep);
    // 	if(dist <= len1+len2+a+tol) {
    // 	  double dotprod = dot(endtoend1,endtoend2);
    // 	  if(dotprod < 0.0) {
    // 	    double de1 = runi.random()*len1;
    // 	    double distalong1 = 0.0;
    // 	    double prevdistalong1 = -1.0;
    // 	    int nBond = 0;
    // 	    while(distalong1 < de1) {
    // 	      prevdistalong1 = distalong1;
    // 	      distalong1 += filament(i)->bonds[nBond]->getLength();
    // 	      nBond++;
    // 	    }
    // 	    assert(nBond <= filament(i)->bonds.size());
    // 	    int nNode1;
    // 	    if(fabs(prevdistalong1-de1) < fabs(distalong1-de1)) nNode1 = nBond - 1;
    // 	    else nNode1 = nBond;
	    
    // 	    if(pinchNodes.find(filament(i)->nodes[nNode1]) == pinchNodes.end()) {
	      
    // 	      VectorND p1;
    // 	      p1 = filament(i)->nodes[nNode1]->position();
	      
    // 	      // now look for node on other filament within tolerance //
    // 	      int nNode2 = 0;
    // 	      bool added = false;
    // 	      while(nNode2<filament(j)->nodes.size() && !added) {
    // 		VectorND p2;
    // 		p2 = filament(j)->nodes[nNode2]->position();
    // 		VectorND nodeSep;
    // 		nodeSep = p2 - p1;
    // 		_box->mapDistance(nodeSep);
    // 		if(dot(nodeSep,endtoend1) > 0.0) {
    // 		  if(fabs(norm2(nodeSep)-a) < tol) {
    // 		    if(pinchNodes.find(filament(j)->nodes[nNode2]) == pinchNodes.end()) {
    // 		      // attach //
    // 		      nAdded++;
    // 		      added = true;
    // 		      pinchNodes.insert(filament(i)->nodes[nNode1]);
    // 		      pinchNodes.insert(filament(j)->nodes[nNode2]);
    // 		      addPinch(filament(i)->nodes[nNode1],filament(j)->nodes[nNode2],f0);
    // 		    }
    // 		  }
    // 		}
    // 		nNode2++;
    // 	      }
    // 	    }
    // 	  }
    // 	}
    //       }

   


      

    else {
      // if we want pinch forces at adjacent crosslinks on same filament, use different method //
      std::vector< std::pair<DefNode*,DefNode*> > potentialPairs;
      int nFils = _filaments.size();
      for(int i=0; i<nFils; i++) {
	Filament * fcur = filament(i);
	double curDist;
	bool hitFirstCL = false;
	int nNodesHere = fcur->nodes.size();
	DefNode* lastCL;
	for(int fn=0; fn<nNodesHere; fn++) {
	  DefNode* dn = fcur->nodes[fn];
	  if(_crossNodeMap.find(dn) != _crossNodeMap.end() || _crosslinkNodes.find(dn) != _crosslinkNodes.end()) {
	    if(hitFirstCL) {
	      if(fabs(curDist-a)<tol && _crossNodeMap[dn] == dn && _crossNodeMap[lastCL] == lastCL) {
		std::pair<DefNode*,DefNode*> newPair = pair<DefNode*,DefNode*>(lastCL,dn);
		potentialPairs.push_back(newPair);
	      }
	      if(fn!=nNodesHere-1) curDist = fcur->bonds[fn]->getLength();
	      lastCL = dn;
	    }
	    else {
	      if(fn!=nNodesHere-1) curDist = fcur->bonds[fn]->getLength();
	      hitFirstCL = true;
	      lastCL = dn;
            }
	  }
	  else {
	    if(hitFirstCL) {
	      if(fn!=nNodesHere-1) curDist += fcur->bonds[fn]->getLength();
	    }
	  }
	}
      }

      ranlib::Uniform<double> rnguni;
      int nPairs = potentialPairs.size();
      int nAdded = 0;
      while(nAdded<nPinches && nPairs>0) {
	rnguni.seed((unsigned int)(time(0)+nAdded));
	bool added = false;
	while(!added && nPairs>0) {
	  int rn = (int)(rnguni.random()*nPairs);
	  if(_pinchNodes.find(potentialPairs[rn].first) == _pinchNodes.end() && _pinchNodes.find(potentialPairs[rn].second) == _pinchNodes.end()) {
	    addPinch(potentialPairs[rn].first,potentialPairs[rn].second,f0); 
	    typename std::vector< pair<DefNode*,DefNode*> >::iterator ppi = potentialPairs.begin();
	    for(int cd=0; cd<rn; cd++) ppi++;
	    potentialPairs.erase(ppi);
	    nPairs--;
	    assert(nPairs == potentialPairs.size());
	    added = true;
	    nAdded++;
	  }
	  else {
	    typename std::vector< pair<DefNode*,DefNode*> >::iterator ppi = potentialPairs.begin();
	    for(int cd=0; cd<rn; cd++) ppi++;
	    potentialPairs.erase(ppi);
	    nPairs--;
	    assert(nPairs == potentialPairs.size()); 
	  }
	}
      }
      
      if(nAdded != nPinches) {
	std::cout << "Only added " << nAdded << " motors, not " << nPinches << " as requested." << std::endl;
	nPinches = nAdded;
      }
      else std::cout << "Added " << nPinches << " pinches to system." << std::endl;
      
      assert(nPinches == _pinches.size());
      
    }
  }

  template<int N>
  void SemiflexibleGel<N>::addPinches(double pinchDensity, double a, double tol, double f0, bool sameFilament) {
    double vol = 1.0;
    for(int i=0; i<N; i++) vol *= _box->size()[i];
    int nPinches = (int)(pinchDensity*vol);
    addPinches(nPinches,a,tol,f0,sameFilament);
  }

  //   template<int N>
  //   void SemiflexibleGel<N>::addPinch(DefNode * n1, DefNode * n2, double f0, bool springy) {
  //     Pinch * newPinch = new PinchForce<N>(n1,n2,f0,_box,springy);
  //     _pinches.push_back(newPinch);
  //   }
  
  //   template<int N>
  //   void SemiflexibleGel<N>::addPinch(double a, double f0, bool springy) {
  //     const VectorND & sysSize = _box->size();
  //     double tol = sysSize(0)/10.0;
  //     CLNMiter cni = _crossNodeMap.begin();
  //     bool foundFirst = false;
  //     bool foundPair = false;
  //     DefNode * firstNode;
  //     while(foundPair==false && cni!=_crossNodeMap.end()) {
  //       DefNode * curMaster = cni->second;
  //       if(foundFirst==false && norm2(curMaster->point()-(sysSize/2.0)) <= tol) {
  // 	foundFirst = true;
  // 	firstNode = curMaster;
  // 	std::cout << "Found first pinch site: " << firstNode->point()[0] << ", " << firstNode->point()[1] << std::endl;
  //       }
  //       else if(foundFirst==true && curMaster!=firstNode && fabs(norm2(firstNode->point()-curMaster->point())-a) < 5.0e-1) {
  // 	addPinch(firstNode,curMaster,f0,springy);
  // 	foundPair = true;
  // 	std::cout << "Found second pinch site: " << curMaster->point()[0] << ", " << curMaster->point()[1] << std::endl;
  //       }
  //       cni++;
  //     }
    
  //   }

  //   template<int N>
  //   void SemiflexibleGel<N>::addPinch(double f0, bool springy, DefNodeContainer & dNodes, double kBond, double kAngle, double visc, double kT, double dt, double kcl) {
  //     const VectorND & sysSize = _box->size();
  //     double rodLen = norm2(filament(0)->nodes[0]->point() - filament(0)->nodes[1]->point());
  //     int nNodesPF = filament(0)->nodes.size();
  //     int nFils = _filaments.size();
  //     int id;
  //     double ang = _rnguni->random()*2.0*3.14159;
  //     NodeBase::DofIndexMap idx(N);
  //     DefNode * newDN;
  //     VectorND startPos;
  //     VectorND curPos;
  //     startPos = sysSize/2.0;
  //     VectorND rodVec;
  //     DefNodeContainer tmpDNC(nNodesPF);
  //     DefNodeContainer tmpDNC2(nNodesPF);
  //     for(int i=0; i<nNodesPF; i++) {
  //       id = nFils*nNodesPF + i;
  //       for(int k=0; k<N; k++) {
  // 	idx[k] = N*id + k;
  //       }
  //       curPos[0] = startPos[0] + i*cos(ang)*rodLen;
  //       curPos[1] = startPos[1] + i*sin(ang)*rodLen;
  //       newDN = new BrownianNode<N>(id,idx,curPos,curPos);
  //       newDN->setId(id);
  //       tmpDNC[i] = newDN;
  //       dNodes.push_back(newDN);
  //       id += nNodesPF;
  //       for(int k=0; k<N; k++) {
  // 	idx[k] = N*id + k;
  //       }
  //       curPos[0] -= rodLen*6*sin(ang);
  //       curPos[1] += rodLen*6*cos(ang);
  //       newDN = new BrownianNode<N>(id,idx,curPos,curPos);
  //       newDN->setId(id);
  //       tmpDNC2[i] = newDN;
  //       dNodes.push_back(newDN);
  //     }
  //     FilamentContainer tmpFC;
  //     addFilament(tmpDNC,kBond,kAngle,visc,kT,dt);
  //     addFilament(tmpDNC2,kBond,kAngle,visc,kT,dt);
  //     Filament * f1 = filament(nFils);
  //     Filament * f2 = filament(nFils+1);
  //     for(int l=0; l<nFils; l++) {
  //       Filament * fold = filament(l);
  //       VectorND sep;
  //       bool twoAtt = false;
  //       sep = ((fold->nodes)[0])->point() - ((f1->nodes)[0])->point();
  //       _box->mapDistance(sep);
  //       if(norm2(sep) <= 2.0*rodLen*(nNodesPF-1)) {
  // 	bool att = false;
  // 	att = attachCrosslink(f1,fold,kcl);
  // 	if(att) twoAtt = true;
  //       }
      
  //       sep = ((fold->nodes)[0])->point() - ((f2->nodes)[0])->point();
  //       _box->mapDistance(sep);
  //       if(norm2(sep) <= 2.0*rodLen*(nNodesPF-1)) {
  // 	bool att = false;
  // 	att = attachCrosslink(f2,fold,kcl);
  // 	if(att==false && twoAtt==true) twoAtt = false;
  //       }
  //       else twoAtt = false;

  //       if(twoAtt) tmpFC.push_back(fold);
  //     }

  //     bool foundclinkpts = false;
  //     int i = 3;
  //     int d1,d2;
  //     while(!foundclinkpts && i < nNodesPF-3) {
  //       i++;
  //       d1 = 0;
  //       d2 = 0;
  //       if(_crossNodeMap.find(f1->nodes[i]) == _crossNodeMap.end() && _crossNodeMap.find(f2->nodes[i]) == _crossNodeMap.end()) {
  // 	d1 = 1;
  // 	while(i-d1>0 && _crossNodeMap.find(f1->nodes[i-d1]) == _crossNodeMap.end()) {
  // 	  d1++;
  // 	}
  // 	if(d1>1 && i-d1>0) {
  // 	  d2 = 1;
  // 	  while(i+d2<nNodesPF-1 && _crossNodeMap.find(f2->nodes[i+d2]) == _crossNodeMap.end()) {
  // 	    d2++;
  // 	  }
  // 	  if(d2>1 && i+d2<nNodesPF-1) {
  // 	    DefNode * mast1 = (_crossNodeMap.find(f1->nodes[i-d1]))->second;
  // 	    DefNode * mast2 = (_crossNodeMap.find(f2->nodes[i+d2]))->second;
  // 	    addPinch(mast1,mast2,f0,springy);
  // 	    foundclinkpts = true;
  // 	    std::cout << "Added pinches at " << mast1->point()[0] << ", " << mast1->point()[1] << " and " << mast2->point()[0] << ", " << mast2->point()[1] << std::endl;
  // 	  }	
  // 	}
  //       }
  //     }
  //   }

  template<int N>
  void SemiflexibleGel<N>::attachCrosslink(Clink * cl, const Filament * f1, const Filament * f2) {
    int nNodesFil1 = f1->nodes.size();
    int nNodesFil2 = f2->nodes.size();
    DefNodeIterator node1Iter = f1->nodes.begin();
    DefNodeIterator node2Iter = f2->nodes.begin();
    DefNode * node1A = *node1Iter;
    DefNode * node2A = *node2Iter;
    DefNode * node1B = *(f1->nodes.end()-1);
    DefNode * node2B = *(f2->nodes.end()-1);
    VectorND x1A = node1A->point();
    VectorND x1B = node1B->point();
    VectorND x2A = node2A->point();
    VectorND x2B = node2B->point();
    VectorND xintersect1;
    VectorND xintersect2;
    double end_to_end1 = norm2(x1B-x1A);
    double end_to_end2 = norm2(x2B-x1A);
    double tol = (end_to_end1+end_to_end2)/2.0;

    double a1,a2;
    if(abs(x1B[0]-x1A[0]) > 1.0e-6 && abs(x2B[0]-x2A[0]) > 1.0e-6) {
      a1 = (x1B[1]-x1A[1])/(x1B[0]-x1A[0]);
      a2 = (x2B[1]-x2A[1])/(x2B[0]-x2A[0]);
      xintersect1[0] = (x1A[1]-x2A[1]+a2*x2A[0]-a1*x1A[0])/(a2-a1);
      xintersect1[1] = (a2*(x1A[1]-a1*x1A[0])-a1*(x2A[1]-a2*x2A[0]))/(a2-a1);
    }
    else if(abs(x1B[0]-x1A[0]) <= 1.0e-6 && abs(x2B[0]-x2A[0]) > 1.0e-6){
      xintersect1[0] = x1A[0];
      a2 = (x2B[1]-x2A[1])/(x2B[0]-x2A[0]);
      xintersect1[1] = a2*x1A[0] + x2A[1] - a2*x2A[0];
    }
    else if(abs(x2B[0]-x2A[0]) <= 1.0e-6 && abs(x1B[0]-x1A[0]) > 1.0e-6) {
      xintersect1[0] = x2A[0];
      a1 = (x1B[1]-x1A[1])/(x1B[0]-x1A[0]);
      xintersect1[1] = x1A[1] - a1*(x1A[0] - x2A[0]);
    }
    else {
      xintersect1[0] = (x1A[0]+x2A[0])/2.0;
      xintersect1[1] = 1.0e30;
    }

    int node_jump1 = min((int)(nNodesFil1*norm2(xintersect1-x1A)/end_to_end1),nNodesFil1-2);
    int node_jump2 = min((int)(nNodesFil2*norm2(xintersect1-x2A)/end_to_end2),nNodesFil2-2);

    if(dot(x1B-x1A,xintersect1-x1A)<0.0) {
      node_jump1 = 0;
    }

    if(dot(x2B-x2A,xintersect1-x2A)<0.0) {
      node_jump2 = 0;
    }
      
    bool intersected = false;
    int rad = 1;
    int curRadCounter = 0;
    int totCounter = 0;
    int node1_offset = node_jump1;
    int node2_offset = node_jump2;
      
    while(intersected == false && totCounter < (nNodesFil1-1)*(nNodesFil2-1)) {
      if(node1_offset >= 0 && node2_offset >= 0 && node1_offset < nNodesFil1 - 1 && node2_offset < nNodesFil2 - 1 && (abs(node1_offset-node_jump1) >= (rad-1)/2 || abs(node2_offset-node_jump2) >= (rad-1)/2)) {
	node1A = *(node1Iter + node1_offset);
	node1B = *(node1Iter + node1_offset + 1);
	node2A = *(node2Iter + node2_offset);
	node2B = *(node2Iter + node2_offset + 1);
	x1A = node1A->point();
	x1B = node1B->point();
	x2A = node2A->point();
	x2B = node2B->point();
	intersected = IntersectionFinder<N>::checkIntersection(x1A,x1B,x2A,x2B,xintersect1,xintersect2,tol,_box);
	if(intersected == true) {
	  double eps1 = norm2(xintersect1-x1A)/end_to_end1;
	  double eps2 = norm2(xintersect2-x2A)/end_to_end2;
	  cl->setPosition(node1A,node1B,node2A,node2B,eps1,eps2);
	  addCrosslink(cl);
	}
	totCounter++;
      }
      curRadCounter++;
      if(curRadCounter >= sqr(rad)) {
	rad += 2;
	curRadCounter = 0;
      }
	
      node2_offset = node_jump2 - ((rad-1)/2) + curRadCounter%rad;
      node1_offset = node_jump1 - ((rad-1)/2) + curRadCounter/rad;
    }
  }

  template<int N>
  bool SemiflexibleGel<N>::attachCrosslink(Filament * f1, Filament * f2, double kcl, double relax) {
    bool doRelax = false;
    if(relax > 0.0) {
      doRelax = true;
    }
    bool attachedCL = false;
    int nNodesFil1 = f1->nodes.size();
    int nNodesFil2 = f2->nodes.size();
    DefNodeContainer & f1nodes = f1->nodes;
    DefNodeContainer & f2nodes = f2->nodes;
    DefNode * node1A = f1nodes[0];
    DefNode * node2A = f2nodes[0];
    DefNode * node1B = f1nodes[nNodesFil1-1];
    DefNode * node2B = f2nodes[nNodesFil2-1];
    VectorND x1A = node1A->point();
    VectorND x1B = node1B->point();
    VectorND x2A = node2A->point();
    VectorND x2B = node2B->point();
    VectorND xintersect1;
    VectorND xintersect2;
    double end_to_end1 = norm2(x1B-x1A);
    double end_to_end2 = norm2(x2B-x2A);
    double tol = (end_to_end1+end_to_end2)/2.0;

    double a1,a2;
    if(abs(x1B[0]-x1A[0]) > 1.0e-6 && abs(x2B[0]-x2A[0]) > 1.0e-6) {
      a1 = (x1B[1]-x1A[1])/(x1B[0]-x1A[0]);
      a2 = (x2B[1]-x2A[1])/(x2B[0]-x2A[0]);
      xintersect1[0] = (x1A[1]-x2A[1]+a2*x2A[0]-a1*x1A[0])/(a2-a1);
      xintersect1[1] = (a2*(x1A[1]-a1*x1A[0])-a1*(x2A[1]-a2*x2A[0]))/(a2-a1);
    }
    else if(abs(x1B[0]-x1A[0]) <= 1.0e-6 && abs(x2B[0]-x2A[0]) > 1.0e-6){
      xintersect1[0] = x1A[0];
      a2 = (x2B[1]-x2A[1])/(x2B[0]-x2A[0]);
      xintersect1[1] = a2*x1A[0] + x2A[1] - a2*x2A[0];
    }
    else if(abs(x2B[0]-x2A[0]) <= 1.0e-6 && abs(x1B[0]-x1A[0]) > 1.0e-6) {
      xintersect1[0] = x2A[0];
      a1 = (x1B[1]-x1A[1])/(x1B[0]-x1A[0]);
      xintersect1[1] = x1A[1] - a1*(x1A[0] - x2A[0]);
    }
    else {
      xintersect1[0] = (x1A[0]+x2A[0])/2.0;
      xintersect1[1] = 1.0e30;
    }

    int node_jump1 = min((int)(nNodesFil1*norm2(xintersect1-x1A)/end_to_end1),nNodesFil1-2);
    int node_jump2 = min((int)(nNodesFil2*norm2(xintersect1-x2A)/end_to_end2),nNodesFil2-2);

    if(dot(x1B-x1A,xintersect1-x1A)<0.0) {
      node_jump1 = 0;
    }

    if(dot(x2B-x2A,xintersect1-x2A)<0.0) {
      node_jump2 = 0;
    }
    
    bool intersected = false;
    int ctr1 = 0;
    int node1_offset = node_jump1;
    
    while(intersected == false && ctr1 < (nNodesFil1-1)) {
      int ctr2 = 0;
      int node2_offset = node_jump2;
      while(intersected == false && ctr2 < (nNodesFil2-1)) {
	node1A = f1nodes[node1_offset];
	node1B = f1nodes[node1_offset+1];
	node2A = f2nodes[node2_offset];
	node2B = f2nodes[node2_offset+1];
	x1A = node1A->point();
	x1B = node1B->point();
	x2A = node2A->point();
	x2B = node2B->point();
	end_to_end1 = norm2(x1B-x1A);
	end_to_end2 = norm2(x2B-x2A);
	tol = (end_to_end1+end_to_end2)/2.0;
	intersected = IntersectionFinder<N>::checkIntersection(x1A,x1B,x2A,x2B,xintersect1,xintersect2,tol,_box);
	if(intersected == true) {
	  double eps1 = norm2(xintersect1-x1A)/end_to_end1;
	  double eps2 = norm2(xintersect2-x2A)/end_to_end2;
	  if(kcl >= 0.0) { // if the crosslink spring constant is non-negative, add real crosslink //
	    attachedCL = true;
	    Clink * cl = new Crosslink<N>(node1A,node1B,node2A,node2B,eps1,eps2,kcl,_box,doRelax);
	    addCrosslink(cl);
	    
	    int clposlow = 0;
	    int clposhigh = f1->clinks.size();
	    while(clposhigh - clposlow > 1) {
	      int clposcur = (clposhigh + clposlow)/2;
	      if(node1_offset + eps1 >= f1->clinks[clposcur]) clposlow = clposcur;
	      else clposhigh = clposcur;
	    }
	    if(clposhigh == 0) f1->clinks.push_back(node1_offset+eps1);
	    else if(f1->clinks.size() == 1) {
	      if(node1_offset + eps1 < f1->clinks[0]) {
		std::vector< double >::iterator clq = f1->clinks.begin();
		f1->clinks.insert(clq,node1_offset+eps1);
	      }
	      else f1->clinks.push_back(node1_offset+eps1);
	    }
	    else if(clposlow == 0) {
	      if(node1_offset + eps1 < f1->clinks[0]) {
		std::vector< double >::iterator clq = f1->clinks.begin();
		f1->clinks.insert(clq,node1_offset+eps1);
	      }
	      else {
		std::vector< double >::iterator clq = f1->clinks.begin();
		f1->clinks.insert(clq+1,node1_offset+eps1);
	      }
	    }
	    else if(clposhigh == f1->clinks.size()) {
	      if(node1_offset + eps1 >= f1->clinks[clposhigh-1]) f1->clinks.push_back(node1_offset+eps1);
	      else {
		std::vector< double >::iterator clq = f1->clinks.end();
		f1->clinks.insert(clq-1,node1_offset+eps1);
	      }
	    }
	    else {
	      std::vector< double >::iterator clq = f1->clinks.begin();
	      f1->clinks.insert(clq+clposhigh,node1_offset+eps1);
	    }

	    clposlow = 0;
	    clposhigh = f2->clinks.size();
	    while(clposhigh - clposlow > 1) {
	      int clposcur = (clposhigh + clposlow)/2;
	      if(node2_offset + eps2 >= f2->clinks[clposcur]) clposlow = clposcur;
	      else clposhigh = clposcur;
	    }
	    if(clposhigh == 0) f2->clinks.push_back(node2_offset+eps2);
	    else if(f2->clinks.size() == 1) {
	      if(node2_offset + eps2 < f2->clinks[0]) {
		std::vector< double >::iterator clq = f2->clinks.begin();
		f2->clinks.insert(clq,node2_offset+eps2);
	      }
	      else f2->clinks.push_back(node2_offset+eps2);
	    }
	    else if(clposlow == 0) {
	      if(node2_offset + eps2 < f2->clinks[0]) {
		std::vector< double >::iterator clq = f2->clinks.begin();
		f2->clinks.insert(clq,node2_offset+eps2);
	      }
	      else {
		std::vector< double >::iterator clq = f2->clinks.begin();
		f2->clinks.insert(clq+1,node2_offset+eps2);
	      }
	    }
	    else if(clposhigh == f2->clinks.size()) {
	      if(node2_offset + eps2 >= f2->clinks[clposhigh-1]) f2->clinks.push_back(node2_offset+eps2);
	      else {
		std::vector< double >::iterator clq = f2->clinks.end();
		f2->clinks.insert(clq-1,node2_offset+eps2);
	      }
	    }
	    else {
	      std::vector< double >::iterator clq = f2->clinks.begin();
	      f2->clinks.insert(clq+clposhigh,node2_offset+eps2);
	    }
	  }
	  else { // a negative crosslink spring constant means we glue nodes together //
	    VectorND AA,BB,AB,BA;
	    AA = x1A - x2A;
	    BB = x1B - x2B;
	    AB = x1A - x2B;
	    BA = x1B - x2A;
	    _box->mapDistance(AA);
	    _box->mapDistance(BB);
	    _box->mapDistance(AB);
	    _box->mapDistance(BA);
	    double AAlen,BBlen,ABlen,BAlen;
	    AAlen = norm2(AA);
	    BBlen = norm2(BB);
	    ABlen = norm2(AB);
	    BAlen = norm2(BA);
	    // create a map to put distance/node pair pairs in so that they are sorted //
	    std::multimap < double, pair<DefNode*,DefNode*> > CLpairs;
	    CLpairs.insert(pair<double,pair<DefNode*,DefNode*> >(AAlen,pair<DefNode*,DefNode*>(node1A,node2A)));
	    CLpairs.insert(pair<double,pair<DefNode*,DefNode*> >(ABlen,pair<DefNode*,DefNode*>(node1A,node2B)));
	    CLpairs.insert(pair<double,pair<DefNode*,DefNode*> >(BAlen,pair<DefNode*,DefNode*>(node1B,node2A)));
	    CLpairs.insert(pair<double,pair<DefNode*,DefNode*> >(BBlen,pair<DefNode*,DefNode*>(node1B,node2B)));
	    typename multimap< double,pair<DefNode*,DefNode*> >::iterator mi = CLpairs.begin();
	    while(!attachedCL && mi!=CLpairs.end()) {
	      //std::vector< pair<DefNode*,DefNode*> > pinPairs;
	      //if(_crossNodeMap.find((mi->second).first) == _crossNodeMap.end() && _crossNodeMap.find((mi->second).second) != _crossNodeMap.end()) {
 	      //  pinPairs.push_back(pair<DefNode*,DefNode*>((mi->second).first,_crossNodeMap[(mi->second).second])); 
	      //}
	      //else if(_crossNodeMap.find((mi->second).first) != _crossNodeMap.end() && _crossNodeMap.find((mi->second).second) == _crossNodeMap.end()) {
              //  pinPairs.push_back(pair<DefNode*,DefNode*>((mi->second).second,_crossNodeMap[(mi->second).first]));
	      //}
	      //else if(_crossNodeMap.find((mi->second).first) == _crossNodeMap.end() && _crossNodeMap.find((mi->second).second) == _crossNodeMap.end()) {
              //  pinPairs.push_back(pair<DefNode*,DefNode*>((mi->second).second,(mi->second).first));
	      //pinPairs.push_back(pair<DefNode*,DefNode*>((mi->second).first,(mi->second).first));
	      //}	

  	      //if(relax>0.0 && pinPairs.size()!=0) {
	      // check to make sure induced bending isn't too much; if it is, clear out pinPairs //
	      //VectorND smdiff;
	      //smdiff = (pinPairs[0].second)->point() - (pinPairs[0].first)->point();
	      //_box->mapDistance(smdiff);
	      //smdiff += (pinPairs[0].first)->point();
	      //(pinPairs[0].first)->setPoint(smdiff);
	      //double energycost = 0.0;
	      //for(AngleIterator ai=f1->angles.begin(); ai!=f1->angles.end(); ai++) {
	      //  (*ai)->compute(true,false,false);
	      //  energycost += (*ai)->energy();
	      //}
	      //for(BondIterator bi=f1->bonds.begin(); bi!=f1->bonds.end(); bi++) {
	      //  (*bi)->compute(true,false,false);
	      //  energycost += (*bi)->energy();
	      //}
	      //for(AngleIterator ai=f2->angles.begin(); ai!=f2->angles.end(); ai++) {
	      //  (*ai)->compute(true,false,false);
	      //  energycost += (*ai)->energy();
	      //}
	      //for(BondIterator bi=f2->bonds.begin(); bi!=f2->bonds.end(); bi++) {
	      //  (*bi)->compute(true,false,false);
	      //  energycost += (*bi)->energy();
	      //}
	      //
	      //(pinPairs[0].first)->setPoint((pinPairs[0].first)->position());
		
	      //	if(energycost > relax) {
	      //	  pinPairs.clear();
	      //	  std::cout << "Crosslink would force excessive bending prestress (" << energycost << " > " << relax << "); deleting." << std::endl;
	      //	}
	      //    }
	      
	      //if(pinPairs.size()!=0) {
	      //  PeriodicTie<N> * pt = new PeriodicTie<N>(pinPairs[0].second,pinPairs[0].first,_box,true);
	      //addConstraint(pt);
	      //for(int pct=0; pct<pinPairs.size(); pct++) {
	      //  _crossNodeMap.insert(pinPairs[pct]);
	      //}
	      //attachedCL = true;
	      //}
	
	      if(_crossNodeMap.find((mi->second).first) == _crossNodeMap.end() && _crossNodeMap.find((mi->second).second) == _crossNodeMap.end()) {
	        PeriodicTie<N> * pt = new PeriodicTie<N>((mi->second).first,(mi->second).second,_box,doRelax);
		addConstraint(pt);
		_crossNodeMap.insert(pair<DefNode*,DefNode*>((mi->second).second,(mi->second).first));
		_crossNodeMap.insert(pair<DefNode*,DefNode*>((mi->second).first,(mi->second).first));
		attachedCL = true;
	      }
       
	      mi++;
	    }
	    // 	    if(_crossNodeMap.find(node1A) == _crossNodeMap.end() && _crossNodeMap.find(node2A) == _crossNodeMap.end()) {
	    // 	      PeriodicTie<N> * pt = new PeriodicTie<N>(node1A,node2A,_box);
	    // 	      addConstraint(pt);
	    // 	      _crossNodeMap.insert(pair< DefNode*, DefNode* >(node2A,node1A));
	    // 	      _crossNodeMap.insert(pair< DefNode*, DefNode* >(node1A,node1A));
	    // // 	      std::cout << "Added crosslink # " << _constraints.size() << std::endl;
	    // 	      attachedCL = true;
	    // 	    }
	    // 	    else if(_crossNodeMap.find(node1A) == _crossNodeMap.end() && _crossNodeMap.find(node2B) == _crossNodeMap.end()) {
	    // 	      PeriodicTie<N> * pt = new PeriodicTie<N>(node1A,node2B,_box);
	    // 	      addConstraint(pt);
	    // 	      _crossNodeMap.insert(pair< DefNode*, DefNode* >(node2B,node1A));
	    // 	      _crossNodeMap.insert(pair< DefNode*, DefNode* >(node1A,node1A));
	    // // 	      std::cout << "Added crosslink # " << _constraints.size() << std::endl;
	    // 	      attachedCL = true;
	    // 	    }
	    // 	    else if(_crossNodeMap.find(node1B) == _crossNodeMap.end() && _crossNodeMap.find(node2B) == _crossNodeMap.end()) {
	    // 	      PeriodicTie<N> * pt = new PeriodicTie<N>(node1B,node2B,_box);
	    // 	      addConstraint(pt);
	    // 	      _crossNodeMap.insert(pair< DefNode*, DefNode* >(node2B,node1B));
	    // 	      _crossNodeMap.insert(pair< DefNode*, DefNode* >(node1B,node1B));
	    // // 	      std::cout << "Added crosslink # " << _constraints.size() << std::endl;
	    // 	      attachedCL = true;
	    // 	    }
	    // 	    else if(_crossNodeMap.find(node1B) == _crossNodeMap.end() && _crossNodeMap.find(node2A) == _crossNodeMap.end()) {
	    // 	      PeriodicTie<N> * pt = new PeriodicTie<N>(node1B,node2A,_box);
	    // 	      addConstraint(pt);
	    // 	      _crossNodeMap.insert(pair< DefNode*, DefNode* >(node2A,node1B));
	    // 	      _crossNodeMap.insert(pair< DefNode*, DefNode* >(node1B,node1B));
	    // // 	      std::cout << "Added crosslink # " << _constraints.size() << std::endl;
	    // 	      attachedCL = true;
	    // 	    }
	  }
	}
	ctr2++;
	node2_offset = (node_jump2+ctr2)%(nNodesFil2-1);
      }
      ctr1++;
      node1_offset = (node_jump1+ctr1)%(nNodesFil1-1);
    }
    
    return attachedCL;
  }
  
  template<int N>
  double SemiflexibleGel<N>::crosslinkenergy() {
    double clen = 0.0;
    for(ConstCrosslinkIterator c=_crosslinks.begin(); c!=_crosslinks.end(); c++) {
      clen += (*c)->energy();
    }
    return clen;
  }

  template<int N>
  double SemiflexibleGel<N>::bendingenergy() {
    double ben = 0.0;
    for(ConstFilamentIterator f=_filaments.begin(); f!=_filaments.end(); f++) {
      for(ConstAngleIterator a=((*f)->angles).begin(); a!=((*f)->angles).end(); a++) {
	ben += (*a)->energy();
      }
    }
    return ben;
  }
  
  template<int N>
  double SemiflexibleGel<N>::stretchingenergy() {
    double sten = 0.0;
    for(ConstFilamentIterator f=_filaments.begin(); f!=_filaments.end(); f++) {
      for(ConstBondIterator b=((*f)->bonds).begin(); b!=((*f)->bonds).end(); b++) {
	sten += (*b)->energy();
      }
    }
    return sten;
  }

  template<int N>
  double SemiflexibleGel<N>::motorenergy() {
    double moten = 0.0;
    for(MotorIterator mi=_motors.begin(); mi!=_motors.end(); mi++) {
      moten += (*mi)->energy();
    }
    return moten;
  }

  template<int N>
  double SemiflexibleGel<N>::pinchenergy() {
    double pinchen = 0.0;
    for(PinchIterator pi=_pinches.begin(); pi!=_pinches.end(); pi++) {
      pinchen += (*pi)->energy();
    }
    return pinchen;
  }

  template<int N>
  double SemiflexibleGel<N>::parallelenergy() {
    double paren = 0.0;
    for(ConstFilamentIterator f=_filaments.begin(); f!=_filaments.end(); f++) {
      int nNodes = (*f)->nodes.size();
      VectorND diff;
      diff = (*f)->nodes[nNodes-1]->position() - (*f)->nodes[0]->position();
      double ang = atan2(diff[1],diff[0]);
      if(abs(cos(ang)) > abs(sin(ang))) {
	for(ConstBondIterator b=((*f)->bonds).begin(); b!=((*f)->bonds).end(); b++) {
	  paren += (*b)->energy();
	}
	for(ConstAngleIterator a=((*f)->angles).begin(); a!=((*f)->angles).end(); a++) {
	  paren += (*a)->energy();
	}
      }
    }
    return paren;
  }

  template<int N>
  double SemiflexibleGel<N>::perpenergy() {
    double perpen = 0.0;
    for(ConstFilamentIterator f=_filaments.begin(); f!=_filaments.end(); f++) {
      int nNodes = (*f)->nodes.size();
      VectorND diff;
      diff = (*f)->nodes[nNodes-1]->position() - (*f)->nodes[0]->position();
      double ang = atan2(diff[1],diff[0]);
      if(abs(cos(ang)) <= abs(sin(ang))) {
	for(ConstBondIterator b=((*f)->bonds).begin(); b!=((*f)->bonds).end(); b++) {
	  perpen += (*b)->energy();
	}
	for(ConstAngleIterator a=((*f)->angles).begin(); a!=((*f)->angles).end(); a++) {
	  perpen += (*a)->energy();
	}
      }
    }
    return perpen;
  }

  template<int N>
  void SemiflexibleGel<N>::cutOffEndsandCCD(double kcl, DefNodeContainer & dNodes) {
    // compute crosslink dist. and cut off ends //
    int totalCLseps = 0;
    int nNodesBefore = dNodes.size();
    dNodes.clear();
    int nNodesCutOff = 0;
    int id = 0;
    NodeBase::DofIndexMap idx(N);
    if(kcl  > 0.0) {
      int nFils = _filaments.size();
      std::cerr << "Cutting off dangling ends with springy crosslinks not implemented yet!" << std::endl;
      //      for(int i=0; i<nFils; i++) {
      // 	Filament * fcur = filament(i);
      // 	for(std::vector< double >::iterator cls = fcur->clinks.begin()+1; cls!=fcur->clinks.end(); cls++) {
      // 	  double pos_prev = *(cls-1);
      // 	  double pos_cur = *(cls);
      // 	  int curSep = ((int)pos_cur) - ((int)pos_prev);
      // 	  if(_crossDistFreqs.find(curSep) == _crossDistFreqs.end()) {
      // 	    _crossDistFreqs.insert(pair< int, int >(curSep,1));
      // 	  }
      // 	  else {
      // 	    _crossDistFreqs[curSep] += 1;
      // 	  }
      // 	  totalCLseps++;
      // 	  _meanCLsep += (pos_cur - pos_prev);
      // 	}
      //       }
    }
    else {
      int i = 0;
      int nFils = _filaments.size();
      while(i<nFils) {
	Filament * fcur = filament(i);
	bool hitFirstCL = false;
	bool cutOffFirst = false;

	// erase nodes before first crosslink, and also erase angle springs, etc. from filaments //
	while(fcur->nodes.size() > 0 && _crossNodeMap.find(*(fcur->nodes.begin())) == _crossNodeMap.end()) {
	  (fcur->nodes).erase(fcur->nodes.begin());
	  nNodesCutOff++;
	  if(cutOffFirst) {
	    if(fcur->bonds.size() > 0) {
	      fcur->bonds.erase(fcur->bonds.begin());
	    }
	    if(fcur->rods.size() > 0) {
	      fcur->rods.erase(fcur->rods.begin());
	    }
	    if(fcur->angles.size() > 0) {
	      fcur->angles.erase(fcur->angles.begin());
	    }
	  }
	  else cutOffFirst = true;
	}
	if(cutOffFirst) {
	  if(fcur->bonds.size() > 0) {
	    fcur->bonds.erase(fcur->bonds.begin());
	  }
	  if(fcur->rods.size() > 0) {
	    fcur->rods.erase(fcur->rods.begin());
	  }
	  if(fcur->angles.size() > 0) {
	    fcur->angles.erase(fcur->angles.begin());
	  }
	}

	// now erase stuff after last crosslink //
	cutOffFirst = false;
	while(fcur->nodes.size() > 0 && _crossNodeMap.find(*(fcur->nodes.end()-1)) == _crossNodeMap.end()) {
	  (fcur->nodes).erase(fcur->nodes.end()-1);
	  nNodesCutOff++;
	  if(cutOffFirst) {
	    if(fcur->bonds.size() > 0) {
	      fcur->bonds.erase(fcur->bonds.end()-1);
	    }
	    if(fcur->rods.size() > 0) {
	      fcur->rods.erase(fcur->rods.end()-1);
	    }
	    if(fcur->angles.size() > 0) {
	      fcur->angles.erase(fcur->angles.end()-1);
	    }
	  }
	  else cutOffFirst = true;
	}
	if(cutOffFirst) {
	  if(fcur->bonds.size() > 0) {
	    fcur->bonds.erase(fcur->bonds.end()-1);
	  }
	  if(fcur->rods.size() > 0) {
	    fcur->rods.erase(fcur->rods.end()-1);
	  }
	  if(fcur->angles.size() > 0) {
	    fcur->angles.erase(fcur->angles.end()-1);
	  }
	}
	i++;
      }
      
      // now repopulate node container (for solver) with remaining nodes and reset node IDs //
      i = 0;
      while(i<nFils) {
	Filament * fcur = filament(i);
	for(DefNodeIterator fn=fcur->nodes.begin(); fn!=fcur->nodes.end(); fn++) {
	  if(_crossNodeMap.find(*fn) == _crossNodeMap.end() || _crossNodeMap[*fn] == *fn) {
	    dNodes.push_back(*fn);
	    for(int k=0; k<N; k++) {
	      idx[k] = N*id + k;
	    }
	    (*fn)->setId(id);
	    (*fn)->setIndex(idx);
	    id++;
	  }
	  else {
	    DefNode * mastNode = _crossNodeMap[*fn];
	    (*fn)->setId(mastNode->id());
	    (*fn)->setIndex(mastNode->index());
	  }
	}
	if(fcur->nodes.size() > 1) {
	  i++;
	  // check consistency of filament //
	  if(fcur->angles.size() != fcur->nodes.size()-2 || fcur->rods.size() != fcur->nodes.size()-1 || fcur->bonds.size() != fcur->nodes.size()-1) {
	    std::cerr << "# of angles/rods/bonds in filament incorrect after end chop!" << std::endl;
	  }
	  else {
	    int nn = 0;
	    for(AngleIterator ai = fcur->angles.begin(); ai != fcur->angles.end(); ai++) {
	      if((*ai)->baseNodes()[0] != fcur->nodes[nn] || (*ai)->baseNodes()[1] != fcur->nodes[nn+1] || (*ai)->baseNodes()[2] != fcur->nodes[nn+2]) {
		std::cerr << "Angle springs are messed up" << std::endl;
	      }
	      nn++;
	    }
	    nn = 0;
	    for(BondIterator bi = fcur->bonds.begin(); bi != fcur->bonds.end(); bi++) {
	      if((*bi)->baseNodes()[0] != fcur->nodes[nn] || (*bi)->baseNodes()[1] != fcur->nodes[nn+1]) {
		std::cerr << "Bond springs are messed up" << std::endl;
	      }
	      nn++;
	    }
	    nn = 0;
	    for(RodIterator ri = fcur->rods.begin(); ri != fcur->rods.end(); ri++) {
	      if((*ri)->baseNodes()[0] != fcur->nodes[nn] || (*ri)->baseNodes()[1] != fcur->nodes[nn+1]) {
		std::cerr << "Brownian rods are messed up" << std::endl;
	      }
	      nn++;
	    }
	  }
	}
	else {
	  if(fcur->nodes.size()==0) {
	    std::cout << "Filament with 0 nodes encountered; removing filament." << std::endl;
	    nFils--;
	    FilamentIterator fi = _filaments.begin();
	    _filaments.erase(fi+i);
	  }
	  else {
	    if(fcur->angles.size() !=0 || fcur->bonds.size()!=0 || fcur->rods.size()!=0) {
	      std::cerr << "# of angles/rods/bonds in filament incorrect after end chop!" << std::endl;
	    }
	    std::cout << "Filament with 1 node encountered; keeping filament." << std::endl;
	    i++;
	  }
	}
      }
    }
    std::cout << "Consistency check: beginning # of nodes = " << nNodesBefore << ", # of nodes cut off = " << nNodesCutOff << ", so expected size of container = " 
	      << nNodesBefore-nNodesCutOff << "; actual size of container = " << dNodes.size() << "." << std::endl;
  }


  template<int N>
  std::map< std::pair<double,double>, std::pair<double,double> > SemiflexibleGel<N>::getAngularEnergyDistro() {
    compute(true,false,false);
    std::cout << "Energy check: gel energy = " << _energy << std::endl;
    double minl = 0.0;
    double maxl = M_PI;
    double stdd = 0.0;
    double avgAng = 0.0;
    int nFils = _filaments.size();
    std::multimap<double, Filament *> filAngles;
    //std::multimap<double,double> angEnergies;
    for(int i=0; i<nFils; i++) {
      Filament * fil = filament(i);
      VectorND e2e;
      e2e = fil->nodes[fil->nodes.size()-1]->position() - fil->nodes[0]->position();
      double ang = atan2(e2e[1],e2e[0]);
      if(ang<0.0) ang += M_PI;
      //double filEner = 0.0;
      //for(BondIterator bi=fil->bonds.begin(); bi!=fil->bonds.end(); bi++) {
      //filEner += (*bi)->energy();
      //}
      //for(AngleIterator ai=fil->angles.begin(); ai!=fil->angles.end(); ai++) {
      //filEner += (*ai)->energy();
      //}
      //filEner /= _energy;
      ///angEnergies.insert(pair<double,double>(ang,filEner));
      filAngles.insert(pair<double,Filament *>(ang,fil));
      avgAng += ang/nFils;
      stdd += sqr(ang)/nFils;
    }
    stdd = stdd - sqr(avgAng);
    stdd = sqrt(stdd);
    //double binwidth = 3.49*stdd/pow(nFils,1.0/3.0);
    //int nBins = (int)(floor((maxl-minl)/binwidth)+.5);
    int nBins = 18;
    double checkEner = 0.0;
    double binwidth = (maxl-minl)/nBins;
    double minVal = minl;
    std::map< doublePair, doublePair > angEnergyMap;
    for(int i=0; i<nBins; i++) {
      typename std::multimap<double,Filament*>::iterator lenIt;
      typename std::multimap<double,Filament*>::iterator lenItHigh;
      double curHigh = minVal + (i+1.0)*binwidth;
      lenItHigh = filAngles.lower_bound(curHigh);
      double meanAng = 0.0;
      double totEner = 0.0;
      double bendEner = 0.0;
      double stretchEner = 0.0;
      int nPts = 0;
      for(lenIt = filAngles.begin(); lenIt!=lenItHigh; lenIt++) {
	meanAng += lenIt->first;
	double filEner = 0.0;
	for(BondIterator bi=lenIt->second->bonds.begin(); bi!=lenIt->second->bonds.end(); bi++) {
	  filEner += (*bi)->energy();
	  stretchEner +=(*bi)->energy();
	}
	for(AngleIterator ai=lenIt->second->angles.begin(); ai!=lenIt->second->angles.end(); ai++) {
	  filEner += (*ai)->energy();
	  bendEner += (*ai)->energy();
	}
	totEner += filEner;
	nPts++;
      }
      meanAng /= nPts;
      double dnPts = (double)(nPts);
      doublePair angPair = pair<double, double>(meanAng,totEner);
      doublePair enerPair = pair<double, double>(bendEner,stretchEner);
      angEnergyMap.insert(pair<doublePair,doublePair>(angPair,enerPair));
      filAngles.erase(filAngles.begin(),lenItHigh);
    }

    assert(filAngles.size()==0);

    return angEnergyMap;
  }

  template<int N>
  std::multimap< double, std::vector<double> > SemiflexibleGel<N>::getDensityEnergyDistro(double scale) {
    VectorND sysSize;
    sysSize = _box->size();
    int nBoxesX = (int)(sysSize[0]/scale);
    int nBoxesY = (int)(sysSize[1]/scale);
    VectorND gridSizes;
    gridSizes[0] = sysSize[0]/nBoxesX;
    gridSizes[1] = sysSize[1]/nBoxesY;
    
    double lengthdens[nBoxesX][nBoxesY];
    double bendenergs[nBoxesX][nBoxesY];
    double stretchenergs[nBoxesX][nBoxesY];
    for(int nx=0; nx<nBoxesX; nx++) {
      for(int ny=0; ny<nBoxesY;ny++) {
	lengthdens[nx][ny] = 0.0;
	bendenergs[nx][ny] = 0.0;
	stretchenergs[nx][ny] = 0.0;
      }
    }
    
    multimap< double, vector<double> > finalData;

    int nF = _filaments.size();
    for(int i=0; i<nF; i++) {
      Filament * f = filament(i);
      int nNodes = f->nodes.size();
      for(int j=0; j<nNodes-1; j++) {
	DefNode * node1 = f->nodes[j];
	DefNode * node2 = f->nodes[j+1];
	VectorND com;
	com = .5*(node1->position() + node2->position());
	int nxbox = (int)(com[0]/gridSizes[0]);
	int nybox = (int)(com[1]/gridSizes[1]);
	if(nxbox<nBoxesX && nybox<nBoxesY) {
	  double bondLength = norm2(node1->position()-node2->position());
	  lengthdens[nxbox][nybox] += bondLength;
	  stretchenergs[nxbox][nybox] += f->bonds[j]->energy();
	}
      }
      for(int j=1; j<nNodes-1; j++) {
	DefNode * node1 = f->nodes[j];
	DefNode * node2 = f->nodes[j+1];
	VectorND com;
	com = node1->position();
	int nxbox = (int)(com[0]/gridSizes[0]);
	int nybox = (int)(com[1]/gridSizes[1]);
	if(nxbox<nBoxesX && nybox<nBoxesY) {
	  bendenergs[nxbox][nybox] += f->angles[j-1]->energy();
	}
      }
    }
    
    for(int nx=0; nx<nBoxesX; nx++) {
      for(int ny=0; ny<nBoxesY;ny++) {
	std::vector<double> ens;
	double totalE = bendenergs[nx][ny] + stretchenergs[nx][ny];
	ens.push_back(totalE);
	ens.push_back(bendenergs[nx][ny]);
	ens.push_back(stretchenergs[nx][ny]);
	double lengthDens = lengthdens[nx][ny]/(gridSizes[0]*gridSizes[1]);
	finalData.insert(pair< double, vector<double> >(lengthDens,ens));
      }
    }

    return finalData;
  }

  template<int N>
  std::vector< std::pair<double, double> > SemiflexibleGel<N>::energyCorrelationFunction(double boxs, double maxlen) {
    std::vector< std::pair<double, double> > enCorrs;

    VectorND boxsize;
    for(int i=0; i<N; i++) boxsize[i] = boxs;
    tvmet::Vector<int,N> nCells;
    int nBoxes = 1;
    for(int i=0; i<N; i++) {
      nCells[i] = (int)(_box->size()[i]/boxsize[i]);
      boxsize[i] = _box->size()[i]/nCells[i];
      nBoxes *= nCells[i];
    }
    
    tvmet::Vector<int,N> mults;
    int curMult = nBoxes;
    for(int i=0; i<N; i++) {
      curMult /= nCells[i];
      mults[i] = curMult;
    }
    
    std::vector<double> energies(nBoxes);
    for(FilamentIterator f=_filaments.begin(); f!=_filaments.end(); f++) {
      int nNodes = (*f)->nodes.size();
      for(int b=0; b<nNodes-1; b++) {
	VectorND com;
	com = .5*((*f)->nodes[b]->position() + (*f)->nodes[b+1]->position());
	_box->mapPoint(com);
	tvmet::Vector<int,N> coords;
	int idx = 0;
	for(int i=0; i<N; i++) {
	  coords[i] = (int)(com[i]/boxsize[i]);
	  coords[i] = coords[i]%nCells[i];
	  idx += mults[i]*coords[i];
	}
	// 	std::cout << "Troubleshoot: coords = (" 
	// 		  << coords[0] << ", " << coords[1] << "); index = " 
	// 		  << idx << "; grid dimensions = ("
	// 		  << nCells[0] << ", " << nCells[1] << ")."
	// 		  << std::endl;
	assert(idx < nBoxes);
	assert(idx >= 0);
	energies[idx] += (*f)->bonds[b]->energy();
      }
      for(int a=1; a<nNodes-1; a++) {
	VectorND com;
	com = (*f)->nodes[a]->position();
	_box->mapPoint(com);
	tvmet::Vector<int,N> coords;
	int idx = 0;
	for(int i=0; i<N; i++) {
	  coords[i] = (int)(com[i]/boxsize[i]);
	  coords[i] = coords[i]%nCells[i];
	  idx += mults[i]*coords[i];
	}
	assert(idx < nBoxes);
	assert(idx >= 0);
	energies[idx] += (*f)->angles[a-1]->energy();
      }
    }

    double minr = 0.0;
    double maxr = maxlen;
    double stepr = 2.0*max(boxsize[0],boxsize[1]);
    int nSteps = (int)((maxr-minr)/stepr);
    VectorND curGridSize;
    VectorND oldGridSize;
    for(int k=0; k<N; k++) curGridSize[k] = stepr + 0.5*max(boxsize[0],boxsize[1]);
    oldGridSize = curGridSize;

    std::map<DefNode*,double> enmap;

    NodeGrid* nodegrid = new Grid<DefNode,BaseDefNode,2>();
    nodegrid->setBox(_box);
    nodegrid->setPosFunc(&DeformationNode<2>::position);
    nodegrid->setGridSpace(curGridSize);
    nodegrid->setComputeNeighbors(false);

    curGridSize = nodegrid->gridSpace();

    NodeBase::DofIndexMap doidx(N);

    double meanen = 0.0;
    double corrval = 0.0;
    for(int nn=0; nn<nBoxes; nn++) {
      tvmet::Vector<int,N> coords;
      VectorND centpos;
      int nnleft = nn;
      for(int k=0; k<N; k++) {
	doidx[k] = nn*N + k;
	coords[k] = nnleft/mults[k];
	nnleft = nnleft - mults[k]*coords[k];
	centpos[k] = (coords[k]+.5)*boxsize[k];
      }
      meanen += energies[nn];

      //       std::cout << "Troubleshoot: index = "
      // 		<< nn << "; coords = ("
      // 		<< coords[0] << ", " << coords[1] << ")."
      // 		<< std::endl;

      DefNode * newNode = new BrownianNode<N>(nn,doidx,centpos,centpos);
      newNode->setId(nn);
      enmap.insert(pair<DefNode*,double>(newNode,energies[nn]));
      nodegrid->addElem(newNode);
    }
    meanen /= nBoxes;

    for(int nn=0; nn<nBoxes; nn++) corrval += sqr(energies[nn]-meanen);
    corrval /= nBoxes;
    
    std::pair<double, double> firstPair = pair<double, double>(0.0,corrval);
    enCorrs.push_back(firstPair);
    
    // get pairs, compute corrval, repeat with different grid sizes
    for(int ns=1; ns<=nSteps; ns++) {
      int nSamps = 0;
      corrval = 0.0;
      oldGridSize = curGridSize;
      double curdist = ns*stepr;
      for(int k=0; k<N; k++) curGridSize[k] = curdist + 0.5*max(boxsize[0],boxsize[1]);
      nodegrid->resetGridSpace(curGridSize);
      curGridSize = nodegrid->gridSpace();
      std::cout << "Current desired node separation = " << curdist << "; current grid size = (" << curGridSize[0] << ", " << curGridSize[1] << ")." << std::endl;
      assert(min(curGridSize[0],curGridSize[1]) >= curdist + 0.5*max(boxsize[0],boxsize[1]));
      int nGridBoxes = nodegrid->nBoxes();
      for(int nb=0; nb<nGridBoxes; nb++) {
	std::map< DefNode*, std::set<DefNode*> > pairs = nodegrid->getNeighbors(nb);
	for(typename map< DefNode*, set<DefNode*> >::iterator pairit=pairs.begin(); pairit!=pairs.end(); pairit++) {
	  DefNode* node1 = pairit->first;
	  for(typename set<DefNode*>::iterator partit=pairit->second.begin(); partit!=pairit->second.end(); partit++) {
	    DefNode* node2 = *partit;
	    if(node1<node2) {
	      VectorND sep;
	      sep = node1->position() - node2->position();
	      _box->mapDistance(sep);
	      if(fabs(norm2(sep)-curdist) < 0.5*max(boxsize[0],boxsize[1])) {
		nSamps++;
		corrval += (enmap[node1]-meanen)*(enmap[node2]-meanen);
	      }
	    }
	  }
	}
      }
      corrval /= nSamps;
      std::pair<double,double> curPair = pair<double,double>(curdist,corrval);
      enCorrs.push_back(curPair);
    }
    
    for(typename map<DefNode*,double>::iterator ni=enmap.begin(); ni!=enmap.end(); ni++) {
      delete ni->first;
    }

    return enCorrs;
  }

  template<int N>
  void SemiflexibleGel<N>::computeCrossDistro(double kcl) {
    _meanCLsep = 0.0;
    double stdd = 0.0;
    int totalCLseps = 0;
    _crossDistFreqs.clear();
    int nFils = _filaments.size();
    if(kcl  > 0.0) {
      for(int i=0; i<nFils; i++) {
	Filament * fcur = filament(i);
	for(std::vector< double >::iterator cls = fcur->clinks.begin()+1; cls!=fcur->clinks.end(); cls++) {
	  double pos_prev = *(cls-1);
	  double pos_cur = *(cls);
	  int curSep = ((int)pos_cur) - ((int)pos_prev);
	  if(_crossDistFreqs.find(curSep) == _crossDistFreqs.end()) {
	    _crossDistFreqs.insert(pair< int, int >(curSep,1));
	  }
	  else {
	    _crossDistFreqs[curSep] += 1;
	  }
	  totalCLseps++;
	  _meanCLsep += (pos_cur - pos_prev);
	}
      }
    }
    else {
      std::multiset<double> clLengths;
      double maxl = -1.0;
      double minl = 1.0e30;
      for(int i=0; i<nFils; i++) {
	Filament * fcur = filament(i);
	double curDist;
	bool hitFirstCL = false;
	int nNodesHere = fcur->nodes.size();
	for(int fn=0; fn<nNodesHere; fn++) {
	  DefNode* dn = fcur->nodes[fn];
	  if(_crossNodeMap.find(dn) != _crossNodeMap.end() || _crosslinkNodes.find(dn) != _crosslinkNodes.end()) {
	    if(hitFirstCL) {
	      _meanCLsep += curDist;
	      stdd += sqr(curDist);
	      clLengths.insert(curDist);
	      if(curDist < minl) minl = curDist;
	      if(curDist > maxl) maxl = curDist;
	      if(fn!=nNodesHere-1) curDist = fcur->bonds[fn]->getLength();
	      if(dn == _crossNodeMap[dn]) {
                int nclsHere = _nSlavesMap[dn]-1;
		for(int icl=0; icl<nclsHere; icl++) clLengths.insert(0.0);
              }
	    }
	    else {
	      if(fn!=nNodesHere-1) curDist = fcur->bonds[fn]->getLength();
	      hitFirstCL = true;
	      if(dn == _crossNodeMap[dn]) {
                int nclsHere = _nSlavesMap[dn]-1;
		for(int icl=0; icl<nclsHere; icl++) clLengths.insert(0.0);
              }
            }
	  }
	  else {
	    if(hitFirstCL) {
	      if(fn!=nNodesHere-1) curDist += fcur->bonds[fn]->getLength();
	    }
	  }
	}
      }
      totalCLseps = clLengths.size();
      stdd /= totalCLseps;
      stdd = stdd - sqr(_meanCLsep/totalCLseps);
      stdd = sqrt(stdd);
      double binwidth = 3.49*stdd/pow(totalCLseps,1.0/3.0);
      int nBins = (int)((maxl-minl)/binwidth) + 2;
      double minVal = minl-.5*binwidth;
      for(int i=0; i<nBins; i++) {
        multiset<double>::iterator lenItHigh;
        double curHigh = minVal + (i+1.0)*binwidth;
        lenItHigh = clLengths.lower_bound(curHigh);
        int numPts = clLengths.size();
        clLengths.erase(clLengths.begin(),lenItHigh);
        _crossDistFreqs.insert(pair<double,int>(curHigh-.5*binwidth,numPts-clLengths.size()));
      }

      assert(clLengths.size()==0);

    }
    _meanCLsep /= totalCLseps;
  }

  template<int N>
  void SemiflexibleGel<N>::computeFilLenDistro() {
    _filLenFreqs.clear();
    _meanFilLen = 0.0;
    double stdd = 0.0;
    double minl = 1.0e30;
    double maxl = -1.0;
    int nFils = _filaments.size();
    std::multiset<double> filLengths;
    for(int i=0; i<nFils; i++) {
      Filament * fil = filament(i);
      double dist = 0.0;
      for(BondIterator bi=fil->bonds.begin(); bi!=fil->bonds.end(); bi++) {
	dist += (*bi)->getLength();
      }
      filLengths.insert(dist);
      if(dist < minl) minl = dist;
      if(dist > maxl) maxl = dist;
      _meanFilLen += dist/nFils;
      stdd += sqr(dist)/nFils;
    }
    stdd = stdd - sqr(_meanFilLen);
    stdd = sqrt(stdd);
    double binwidth = 3.49*stdd/pow(nFils,1.0/3.0);
    int nBins = (int)((maxl-minl)/binwidth) + 2;
    double minVal = minl-.5*binwidth;
    for(int i=0; i<nBins; i++) {
      multiset<double>::iterator lenItHigh;
      double curHigh = minVal + (i+1.0)*binwidth;
      lenItHigh = filLengths.lower_bound(curHigh);
      int numPts = filLengths.size();
      filLengths.erase(filLengths.begin(),lenItHigh);
      _filLenFreqs.insert(pair<double,int>(curHigh-.5*binwidth,numPts-filLengths.size()));
    }

    //assert(filLengths.size()==0);
  }

  template<int N>
  void SemiflexibleGel<N>::computeNematicOP() {
    double nemOP;
    VectorND nemDirector;
    if(N==2) {
      Tensor2D nemTensor(0.0);
      int nFils = _filaments.size();
      for(int i=0; i<nFils; i++) {
	Filament * fil = filament(i);
	VectorND e2e;
	e2e = fil->nodes[fil->nodes.size()-1]->point() - fil->nodes[0]->point();
	double ang = atan2(e2e[1],e2e[0]);
	nemTensor(0,0) += (2.0*sqr(cos(ang)) - 1.0)/nFils;
	nemTensor(1,1) += (2.0*sqr(sin(ang)) - 1.0)/nFils;
	nemTensor(0,1) += (2.0*cos(ang)*sin(ang))/nFils;
      }
      nemTensor(1,0) = nemTensor(0,1);
      
      // now solve for largest eigenvalue and associated eigenvector //
      double lam1 = .5*(nemTensor(0,0)+nemTensor(1,1) + sqrt(sqr(nemTensor(0,0)-nemTensor(1,1))+sqr(2.0*nemTensor(0,1))));
      //double lam2 = .5*(nemTensor(0,0)+nemTensor(1,1) - sqrt(sqr(nemTensor(0,0)-nemTensor(1,1))+sqr(2.0*nemTensor(0,1))));
      nemOP = lam1;
      double v1 = 1.0/sqrt(1.0 + sqr((nemTensor(0,0)+nemTensor(0,1)-lam1)/(nemTensor(1,1)+nemTensor(0,1)-lam1)));
      double v2 = -v1*(nemTensor(0,0)+nemTensor(0,1)-lam1)/(nemTensor(1,1)+nemTensor(0,1)-lam1);
      nemDirector[0] = v1;
      nemDirector[1] = v2;
    }

    _nematicOP = nemOP;
    _nemDirector = nemDirector;
  }

  template<int N>
  void SemiflexibleGel<N>::computeNematicDistro(double nemAngle) {
    _nematicFreqs.clear();
    _nematicOP = 0.0;
    double avgAng = 0.0;
    double stdd = 0.0;
    double minl = -M_PI;
    double maxl = M_PI;
    int nFils = _filaments.size();
    std::multiset<double> filAngles;
    for(int i=0; i<nFils; i++) {
      Filament * fil = filament(i);
      VectorND e2e;
      e2e = fil->nodes[fil->nodes.size()-1]->point() - fil->nodes[0]->point();
      double ang = atan2(e2e[1],e2e[0]);
      ang -= nemAngle;
      if(ang <= -M_PI) ang += 2.0*M_PI;
      else if(ang > M_PI) ang -= 2.0*M_PI;
      assert(fabs(ang) <= M_PI);
      filAngles.insert(ang);
      _nematicOP += cos(2.0*ang)/nFils;
      avgAng += ang/nFils;
      stdd += sqr(ang)/nFils;
    }
    stdd = stdd - sqr(avgAng);
    stdd = sqrt(stdd);
    double binwidth = 3.49*stdd/pow(nFils,1.0/3.0);
    int nBins = (int)(floor((maxl-minl)/binwidth)+.5);
    binwidth = (maxl-minl)/nBins;
    double minVal = minl;
    for(int i=0; i<nBins; i++) {
      multiset<double>::iterator lenItHigh;
      double curHigh = minVal + (i+1.0)*binwidth;
      lenItHigh = filAngles.lower_bound(curHigh);
      int numPts = filAngles.size();
      filAngles.erase(filAngles.begin(),lenItHigh);
      _nematicFreqs.insert(pair<double,int>(curHigh-.5*binwidth,numPts-filAngles.size()));
    }

    assert(filAngles.size()==0);
  }

  //   template<int N>
  //   bool SemiflexibleGel<N>::checkCrosslinks() {
  //     // make sure filaments are not doubly-crosslinked //
  //     bool err = false;
  //     int totCL = 0;
  //     for(int i=0; i<_filaments.size(); i++) {
  //       Filament* f1 = filament(i);
  //       DefNodeContainer mastNodes;
  //       for(int n1=0; n1<f1->nodes.size(); n1++) {
  // 	if(_crossNodeMap.find(f1->nodes[n1]) != _crossNodeMap.end()) {
  // 	  mastNodes.push_back(_crossNodeMap[f1->nodes[n1]]);
  // 	}
  //       }
  //       for(int j=i+1; j<_filaments.size(); j++) {
  // 	Filament* f2 = filament(j);
  // 	int nConnex = 0; // number of crosslinks between filaments //
  // 	for(int n2=0; n2<f2->nodes.size(); n2++) {
  // 	  DefNode* curMast;
  // 	  if(_crossNodeMap.find(f2->nodes[n2]) != _crossNodeMap.end()) {
  // 	    curMast = _crossNodeMap[f2->nodes[n2]];
  // 	    for(int ncl=0; ncl<mastNodes.size(); ncl++) {
  // 	      if(mastNodes[ncl] == curMast) {
  // 		nConnex++;
  // 		totCL++;
  // 	      }
  // 	    }
  // 	  }
  // 	}
  // 	if(nConnex>1) {
  // 	  std::cout << "Error: filaments " << i << " and " << j << " are crosslinked " << nConnex << " times." << std::endl;
  // 	  err = true;
  // 	}
  // 	else if(nConnex==1) std::cout << "Filaments " << i << " and " << j << " are crosslinked " << nConnex << " times." << std::endl;
  //       }
  //     }
  //     if(!err) {
  //       std::cout << "All filaments linked 0 or 1 times!" << std::endl << "Total # of crosslinks = " << totCL << "." << std::endl;
  //     }
  //     return err;
  //   }
  //   template<int N>
  //   std::vector< pair< double, double > > & SemiflexibleGel<N>::getAffinityMeasure(double step, double max) {
  //     int nFils = _filaments.size();
  //     std::vector< pair< double, double > > affins;
  //     affins.reserve(max/step+1);
  //     for(int count=0; count<=max/step; count++) {
  //       affins.push_back(pair< double, double >(count*step,0.0));
  //     }
  //     for(int i=0; i<nFils; i++) {
  //       Filament * fcur = filament(i);
  //       for(int j=0; j<=i; j++) {
  // 	Filament * fcur2 = filament(j);
  // 	for(DefNodeIterator fn1=fcur->nodes.begin(); fn1!=fcur->nodes.end(); fn1++) {
  // 	  for(DefNodeIterator fn2=fcur2->nodes.begin(); fn2!=fcur2->nodes.end(); fn2++) {
  // 	    bool sepHit = false;
  // 	    while(!sepHit) {
	      
  // 	    }
  // 	  }
  // 	}
  //       }
  //     }
  //   }

  template<int N>
  void SemiflexibleGel<N>::printAngles(std::string & angleFile) {
    std::vector<double> angs;
    for(FilamentIterator fi=_filaments.begin(); fi!=_filaments.end(); fi++) {
      if((*fi)->nodes.size() > 1) {
	int nNodes = (*fi)->nodes.size();
	VectorND e2e;
	e2e = (*fi)->nodes[nNodes-1]->position() - (*fi)->nodes[0]->position();
	double ang = atan2(e2e[1],e2e[0]);
	angs.push_back(ang);
      }
    }
    std::ofstream angFile(angleFile.c_str());
    for(vector<double>::iterator ai=angs.begin(); ai!=angs.end(); ai++) {
      angFile << *ai << std::endl;
    }
    angFile.close();
  }

  //   template<int N>
  //   std::vector< pair<double,double> > SemiflexibleGel<N>::affineMeasurement(double minLength, double stepSize, double maxLength, double shear, std::string measureType) {
  //     double affrot = shear/2.0;
  //     double affshear = shear/2.0;
  //     doublePairContainer affmeas;
  //     DefNodeContainer nodes4triangulation;
  //     // add nodes to container for triangulation //
  //     Vector2D maxPos(_box->size());
  //     Vector2D minPos(0.0);
  //     for(FilamentIterator fi=_filaments.begin(); fi!=_filaments.end(); fi++) {
  //       for(DefNodeIterator dni=(*fi)->nodes.begin(); dni!=(*fi)->nodes.end(); dni++) {
  // 	if((*dni)->position()[0] > maxPos[0]) maxPos[0] = (*dni)->position()[0];
  // 	if((*dni)->position()[1] > maxPos[1]) maxPos[1] = (*dni)->position()[1];
  // 	if((*dni)->position()[0] < minPos[0]) minPos[0] = (*dni)->position()[0];
  // 	if((*dni)->position()[1] < minPos[1]) minPos[1] = (*dni)->position()[1];
  //       }
  //     }

  //     for(FilamentIterator fi=_filaments.begin(); fi!=_filaments.end(); fi++) {
  //       for(DefNodeIterator dni=(*fi)->nodes.begin(); dni!=(*fi)->nodes.end(); dni++) {
  // // 	if(isMaster(*dni)) {
  // // 	  Vector2D tmpPos;
  // // 	  Vector2D tmpDef;
  // // 	  tmpPos = (*dni)->position();
  // // 	  tmpDef = (*dni)->point() - (*dni)->position();
  // // 	  _box->mapPoint(tmpPos);
  // // 	  tmpDef += tmpPos;
  // // 	  DefNode* newNode = new BrownianNode<2>((*dni)->id(),(*dni)->index(),tmpPos,tmpDef);
  // // 	  newNode->setId((*dni)->id());
  // // 	  nodes4triangulation.push_back(newNode);
  // // 	}
  // 	if(!isSlave(*dni)) {
  // 	  Vector2D tmpPos;
  // 	  Vector2D tmpDef;
  // // 	  tmpPos = (*dni)->position() - minPos;
  // // 	  tmpDef = (*dni)->point() - minPos;
  // 	  tmpPos = (*dni)->position();
  // 	  _box->setShear(0.0);
  // 	  _box->mapPoint(tmpPos);
  // 	  tmpDef = (*dni)->point() - tmpPos;
  // 	  _box->setShear(shear);
  // 	  _box->mapDistance(tmpDef);
  // 	  tmpDef += tmpPos;
  // 	  DefNode* newNode = new BrownianNode<2>((*dni)->id(),(*dni)->index(),tmpPos,tmpDef);
  // 	  newNode->setId((*dni)->id());
  // 	  nodes4triangulation.push_back(newNode);
  // 	}
  //       }
  //     }
  //     _box->setShear(0.0);
    
  //     // do triangulation with original set of nodes //
  //     AffinityMeasure* am = new AffinityMeasure(nodes4triangulation);
  //     am->triangulate();
  //     //StrainField sf;
  //     //sf = am->getStrainField();

  //     am->printParaview("mesh-0.0");
    
  //     // compute non-affinity measure for this coarse-graining scale //
  //     if(measureType == "strain") {
  //       affmeas.push_back(pair<double, double>(0.0,am->strainMeasure(shear,_box->size()[0]*_box->size()[1])));
  //     }
  //     else if(measureType == "rotation") {
  //       affmeas.push_back(pair<double, double>(0.0,am->rotationMeasure(affrot,_box->size()[0]*_box->size()[1])));
  //     }
    
  //     // figure out how many different box sizes to use //
  //     //int nSteps = (int)(log2(syssize/(2.0*minLength)));
  //     int nSteps = (int)((maxLength-minLength)/stepSize);

  //     // create new grid with nodes' position (not point) as relevant location //
  //     Vector2D gridSpace;
  //     gridSpace[0] = minLength;
  //     gridSpace[1] = minLength;
  //     NodeGrid* nodegrid = new Grid<DefNode,BaseDefNode,2>();
  //     PeriodicBox tmpBox(0.0,0.0);
  //     Vector2D boxSize;
  //     boxSize = maxPos - minPos;
  //     tmpBox.setSize(boxSize);
  //     nodegrid->setBox(_box);
  //     //nodegrid->setBox(&tmpBox);
  //     nodegrid->setPosFunc(&DeformationNode<2>::position);
  //     nodegrid->setGridSpace(gridSpace);
  //     nodegrid->setComputeNeighbors(false);
  //     nodegrid->addElems(nodes4triangulation);
    

  //     double oldGridSize = 0.0;
  //     Vector2D oldGridSpace(0.0);
  //     bool printOut;
  //     for(int j=0; j<nSteps; j++) {
  //       // get new grid size, reset grid spacing, and add new elements //
  //       //double gridSize = minLength*pow(2.0,j);
  //       double gridSize = minLength + j*stepSize;
  //       for(int i=0; i<2; i++) gridSpace[i] = gridSize;
  //       std::cout << "Resetting grid spacing...";
  //       nodegrid->resetGridSpace(gridSpace);
  //       gridSpace = nodegrid->gridSpace();
  //       gridSize = gridSpace[0];
  //       if(abs(gridSpace[0]-oldGridSpace[0]) < 1.0e-6 || abs(gridSpace[1]-oldGridSpace[1]) < 1.0e-6) printOut = false;
  //       else printOut = true;
  //       oldGridSize = gridSize;
  //       oldGridSpace = gridSpace;
  //       std::cout << "new grid size = (" << gridSpace[0] << ", " << gridSpace[1] << ")" << std::endl;
  //       //nodegrid->addElems(nodes4triangulation);
  //       // get vector of boxes //
  //       std::vector< std::set<DefNode*> > & nodeBoxes = nodegrid->elemBoxes();
  //       int nBoxes = nodeBoxes.size();
  //       DefNodeContainer tmpContainer;
  //       // for each box, compute mean position and mean displacement vector and create new node //
  //       for(int boxit=0; boxit<nBoxes; boxit++) {
  // 	Vector2D newPos(0.0,0.0);
  // 	Vector2D newPoint(0.0,0.0);
  // 	int nNodesHere = nodeBoxes[boxit].size();
  // 	if(nNodesHere>0) {
  // 	  for(typename std::set<DefNode*>::iterator nodeit=nodeBoxes[boxit].begin(); nodeit!=nodeBoxes[boxit].end(); nodeit++) {
  // 	    newPos += (*nodeit)->position();
  // 	    newPoint += (*nodeit)->point();
  // 	  }
  // 	  newPos /= nNodesHere;
  // 	  newPoint /= nNodesHere;
  // 	  NodeBase::DofIndexMap idx(N);
  // 	  for(int k=0; k<N; k++) idx[k] = boxit*N + k;
  // 	  DefNode* newNode = new BrownianNode<2>(boxit,idx,newPos,newPoint);
  // 	  newNode->setId(boxit);
  // 	  tmpContainer.push_back(newNode);
  // 	}
  //       }
      
  //       // now pass new vector of nodes to triangulation routine //
  //       //am->resetNodes(tmpContainer);
  //       //am->triangulate();
  //       //sf = am->getStrainField();

  //       am->resetNodes(tmpContainer);
  //       am->triangulate();
  //       //sf = am2.getStrainField();
  //       char fname[128];
  //       sprintf(fname,"mesh-%g",gridSize);
  //       am->printParaview(fname);
      
  //       // compute non-affinity measure for this coarse-graining scale //
  //       double avgGridSize = .5*(gridSpace[0] + gridSpace[1]);
  //       if(measureType == "strain" && printOut) {
  // 	affmeas.push_back(pair<double, double>(avgGridSize,am->strainMeasure(shear,100.0*gridSpace[0]*gridSpace[1])));
  //       }
  //       else if(measureType == "rotation" && printOut) {
  // 	affmeas.push_back(pair<double, double>(avgGridSize,am->rotationMeasure(affrot,100.0*gridSpace[0]*gridSpace[1])));
  //       }
      
  //       // delete temporary nodes //
  //       for(DefNodeIterator dni=tmpContainer.begin(); dni!=tmpContainer.end(); dni++) delete *dni;
  //     }
    

  //     for(DefNodeIterator dni2=nodes4triangulation.begin(); dni2!=nodes4triangulation.end(); dni2++) delete *dni2;

  //     return affmeas;
  //   }

  //   template<int N>
  //   void SemiflexibleGel<N>::computeNonaffinityLengthDensityCorrelation(double boxsize, double maxdist, double maxFL, double shear) {
  //     double affrot = shear/2.0;
  //     double affshear = shear/2.0;
  //     doublePairContainer affmeas;
  //     DefNodeContainer nodes4triangulation;
  //     // add nodes to container for triangulation //
  //     for(FilamentIterator fi=_filaments.begin(); fi!=_filaments.end(); fi++) {
  //       bool isLong = false;
  //       VectorND e2e;
  //       e2e = (*fi)->nodes[(*fi)->nodes.size()-1]->position() - (*fi)->nodes[0]->position();
  //       if(norm2(e2e) > maxFL) isLong = true;
  //       if(!isLong) {
  // 	for(DefNodeIterator dni=(*fi)->nodes.begin(); dni!=(*fi)->nodes.end(); dni++) {
  // 	  if(!isSlave(*dni)) {
  // 	    VectorND pos;
  // 	    pos = (*dni)->position();
  // 	    _box->setShear(0.0);
  // 	    _box->mapPoint(pos);
  // 	    VectorND dev;
  // 	    dev = (*dni)->point() - pos;
  // 	    _box->setShear(shear);
  // 	    _box->mapDistance(dev);
  // 	    _box->setShear(0.0);
  // 	    VectorND pt;
  // 	    pt = pos+dev;
	    
  // 	    DefNode* newNode = new BrownianNode<N>((*dni)->id(),(*dni)->index(),pos,pt);
  // 	    nodes4triangulation.push_back(newNode);
  // 	  }
  // 	}
  //       }
  //     }

  //     _box->setShear(0.0);
    
  //     // do triangulation with original set of nodes //
  //     AffinityMeasure* am = new AffinityMeasure(nodes4triangulation);
  //     am->triangulate();
  //     am->printParaview("mesh");
  //     //StrainField sf;
  //     //sf = am->getStrainField();

  //     //am->printParaview("mesh-0.0");
    
  //     // compute non-affinity measure for this coarse-graining scale //
  // //     if(measureType == "strain") {
  // //       affmeas.push_back(pair<double, double>(0.0,am->strainMeasure(shear,_box->size()[0]*_box->size()[1])));
  // //     }
  // //     else if(measureType == "rotation") {
  // //       affmeas.push_back(pair<double, double>(0.0,am->rotationMeasure(affrot,_box->size()[0]*_box->size()[1])));
  // //     }  


  //     double meanrot = 0.0;
  //     double stddevrot = 0.0;
  //     double totalArea = 0.0;
  //     std::vector<AffinityElement *> & els = am->getElements();
  //     for(typename vector<AffinityElement *>::iterator afi=els.begin(); afi!=els.end(); afi++) {
  //       double newval = sqr((*afi)->Rotation()-(shear/2.0));
  //       double newarea = (*afi)->Area();
  //       meanrot += newval*newarea;
  //       stddevrot += sqr(newval)*newarea;
  //       totalArea += newarea;
  //     }
  //     meanrot /= totalArea;
  //     stddevrot /= totalArea;
  //     stddevrot -= sqr(meanrot);
  //     stddevrot = sqrt(stddevrot);
  //     std::cout << "Mean squared deviation from affine rotational part = " << meanrot << "; width of distribution = " << stddevrot << "." << std::endl;

  //     std::cout << "Do you want to compute the nonaffinity-nonaffinity correlation function using the triangulated values of the rotation?\n(1) yes\n(2) no\n\n: ";
  //     int doCorrTriangle;
  //     std::cin >> doCorrTriangle;
  //     if(doCorrTriangle == 1) {
  //       double avgarea = totalArea/els.size();
  //       double minlength = 2.0*sqrt(avgarea);
  //       std::map<DefNode*,double> affTriangleMap;
  //       for(int nt=0; nt<els.size(); nt++) {
  // 	NodeBase::DofIndexMap idx(N);
  // 	for(int kdof=0; kdof<N; kdof++) idx[kdof] = nt*N + kdof;
  // 	const Vector2D & centr = els[nt]->Centroid(); 
  // 	DefNode* newNode2 = new BrownianNode<2>(nt,idx,centr,centr);
  // 	double affdev = sqr(els[nt]->Rotation()-(shear/2.0));
  // 	affTriangleMap.insert(pair<DefNode*,double>(newNode2,affdev));
  //       }

  //       std::vector< pair<double,double> > affTriangleData = computeCorrelationFunction(affTriangleMap,minlength,maxdist,2.0*minlength,minlength/2.0);
      
  //       std::cout << "Please enter the name of a file in which to put the data: ";
  //       char tricorrFN[256];
  //       std::cin >> tricorrFN;
      
  //       std::ofstream tac(tricorrFN);
  //       tac << "#r\tcorr" << std::endl;
      
  //       for(typename std::vector< pair<double,double> >::iterator trit=affTriangleData.begin(); trit!=affTriangleData.end(); trit++) {
  // 	tac << trit->first << "\t" << trit->second << std::endl;
  //       }
      
  //       tac.close();

  //       for(typename map<DefNode*,double>::iterator tempni=affTriangleMap.begin(); tempni!=affTriangleMap.end(); tempni++) {
  // 	delete tempni->first;
  //       }
  //     }
    
  //     Vector2D gridSpace;
  //     gridSpace[0] = boxsize;
  //     gridSpace[1] = boxsize;
  //     AffElementGrid * affgrid = new Grid<AffinityElement,AffinityElement,2>();
  //     affgrid->setBox(_box);
  //     //nodegrid->setBox(&tmpBox);
  //     affgrid->setPosFunc(&AffinityElement::Centroid);
  //     affgrid->setGridSpace(gridSpace);
  //     affgrid->setComputeNeighbors(false);
  //     affgrid->addElems(am->getElements());
    
  //     gridSpace = affgrid->gridSpace();

  //     tvmet::Vector<int,N> nCells;
  //     nCells = affgrid->nBoxesDim();
    
  //     tvmet::Vector<int,N> mults;
  //     int nBoxes = affgrid->nBoxes();
  //     int curMult = nBoxes;
  //     for(int i=0; i<N; i++) {
  //       curMult /= nCells[i];
  //       mults[i] = curMult;
  //     }

  //     std::vector<double> nonaffinities(nBoxes,0.0);
  //     std::vector<double> affdevs(nBoxes,0.0);
  //     for(int nb=0; nb<nBoxes; nb++) {
  //       double nonaff = 0.0;
  //       double affdev = 0.0;
  //       double totArea = 0.0;
  //       std::set<AffinityElement *> & boxAffs = affgrid->getBoxElems(nb);
  //       // calculate the integral of the off-diagonal (rotational) element of u_ij-u_ji over the box (should we divide by area?)
  //       for(typename set<AffinityElement *>::iterator aei=boxAffs.begin(); aei!=boxAffs.end(); aei++) {
  // 	double rot = (*aei)->Rotation();
  // 	affdev += (rot-(shear/2.0))*((*aei)->Area());
  // 	rot = sqr(rot-(shear/2.0));
  // 	nonaff += rot*((*aei)->Area());
  // 	totArea += (*aei)->Area();
  //       }
  //       if(totArea > 0.0) {
  // 	nonaffinities[nb] = nonaff/totArea;
  // 	affdevs[nb] = affdev/totArea;
  //       }
  //     }
    
  //     std::vector<double> longld(nBoxes,0.0);
  //     _box->setShear(0.0);
  //     for(FilamentIterator f=_filaments.begin(); f!=_filaments.end(); f++) {
  //       int nNodes = (*f)->nodes.size();
  //       bool isLong = false;
  //       VectorND fe2e;
  //       fe2e = (*f)->nodes[nNodes-1]->position() - (*f)->nodes[0]->position();
  //       double fillen = norm2(fe2e);
  //       if(fillen > maxFL) isLong = true;
  //       if(isLong) {
  // 	for(int b=0; b<nNodes-1; b++) {
  // 	  VectorND com;
  // 	  com = .5*((*f)->nodes[b]->position() + (*f)->nodes[b+1]->position());
  // 	  _box->mapPoint(com);
  // 	  tvmet::Vector<int,N> coords;
  // 	  int idx = 0;
  // 	  for(int i=0; i<N; i++) {
  // 	    coords[i] = (int)(com[i]/gridSpace[i]);
  // 	    coords[i] = coords[i]%nCells[i];
  // 	    idx += mults[i]*coords[i];
  // 	  }
  // 	  VectorND e2e;
  // 	  e2e = (*f)->nodes[b]->position() - (*f)->nodes[b+1]->position();
  // 	  double len = norm2(e2e);
  // 	  longld[idx] += len;
  // 	}
  //       }
  //     }
  //     double boxVol = 1.0;
  //     for(int dim=0; dim<N; dim++) boxVol *= gridSpace[dim];
  //     for(int nb=0; nb<nBoxes; nb++) longld[nb] /= boxVol;
    
  //     std::map<DefNode*, std::pair<double,double> > data;
  //     std::map<DefNode*, std::pair<double,double> > dataSigned;
  //     for(int k=0; k<nBoxes; k++) {
  //       NodeBase::DofIndexMap idx(N);
  //       for(int j=0; j<N; j++) idx[j] = k*N + j;
  //       if(N==2) {
  // 	VectorND cellCenter;
  // 	int row = k/nCells[1];
  // 	int column = k%nCells[1];
  // 	cellCenter[0] = (row+0.5)*gridSpace[0];
  // 	cellCenter[1] = (column+0.5)*gridSpace[1];
  // 	DefNode* newNode = new BrownianNode<2>(k,idx,cellCenter,cellCenter);
  // 	std::pair<double,double> dpr = pair<double,double>(nonaffinities[k],longld[k]);
  // 	std::pair<double,double> dprsigned = pair<double,double>(affdevs[k],longld[k]);
  // 	data.insert(pair<DefNode*, pair<double,double> >(newNode,dpr));
  // 	dataSigned.insert(pair<DefNode*, pair<double,double> >(newNode,dprsigned));
  //       }
  //     }
    
  //     double maxdim = 0.0;
  //     for(int dim=0; dim<N; dim++) {
  //       if(gridSpace[dim] > maxdim) maxdim = gridSpace[dim];
  //     }
    
  //     std::cout << "Do you want to compute the nonaffinity-length density correlation function? ";
  //     int naldc;
  //     std::cin >> naldc;
  //     if(naldc==1) {
  //       std::cout << "Please enter a file name in which to store the data: ";
  //       char naldf[256];
  //       std::cin >> naldf;

  //       std::vector< std::pair<double,double> > corr = computeCrossCorrelationFunction(data,2.0*maxdim,maxdist,2.0*maxdim,maxdim/2.0);
      
  //       std::ofstream nonAffLD(naldf);
  //       nonAffLD << "#r\tcorr" << std::endl;
      
  //       for(typename vector< pair<double,double> >::iterator datait=corr.begin(); datait!=corr.end(); datait++) {
  // 	nonAffLD << datait->first << "\t" << datait->second << std::endl;
  //       }
      
  //       nonAffLD.close();
  //     }

  //     std::cout << "Do you want to compute the nonaffinity (new measure) correlation function?\n(1) yes\n(2) no\n\n: ";
  //     int doAutoCorr;
  //     std::cin >> doAutoCorr;
  //     if(doAutoCorr==1) {
  //       std::map<DefNode *,double> autoData;
  //       for(typename map< DefNode*, pair<double,double> >::iterator diter=data.begin(); diter!=data.end(); diter++) {
  // 	autoData.insert(pair<DefNode*,double>(diter->first,diter->second.first));
  //       }
  //       std::vector< std::pair<double,double> > autocorr = computeCorrelationFunction(autoData,2.0*maxdim,maxdist,2.0*maxdim,maxdim/2.0);
      
  //       std::map<DefNode *,double> autoDataSigned;
  //       for(typename map< DefNode*, pair<double,double> >::iterator diter=dataSigned.begin(); diter!=dataSigned.end(); diter++) {
  // 	autoDataSigned.insert(pair<DefNode*,double>(diter->first,diter->second.first));
  //       }
  //       std::vector< std::pair<double,double> > autocorrSigned = computeCorrelationFunction(autoDataSigned,2.0*maxdim,maxdist,2.0*maxdim,maxdim/2.0);

  //       assert(autocorr.size() == autocorrSigned.size());
  //       int ndpts = autocorr.size();

  //       std::cout << "Please enter the name of a file in which to put the data: ";
  //       char autocorrFN[256];
  //       std::cin >> autocorrFN;
      
  //       std::ofstream ac(autocorrFN);
  //       ac << "#r\t\tcorrsigned\t\tcorr" << std::endl;
      
  // //       for(typename std::vector< pair<double,double> >::iterator datait=autocorr.begin(); datait!=autocorr.end(); datait++) {
  // // 	ac << datait->first << "\t\t" << datait->second << std::endl;
  // //       }

  //       for(int np=0; np<ndpts; np++) {
  // 	ac << autocorr[np].first << "\t\t" << autocorrSigned[np].second << "\t\t" << autocorr[np].second << std::endl;
  //       }
      
  //       ac.close();
  //     }
    
  //   }
  
  template<int N>
  
  std::vector< std::pair<double, std::pair< double, double > > > SemiflexibleGel<N>::affineMeasurementHeadLevine(double minLength, double stepSize, double maxLength, double shear, double largestFil, bool getAngularDist=false) {
    std::cout << "Beginning Head/Levine affine measurement." << std::endl;

    doublePairWErrorsContainer affdata;
    DefNodeContainer nodes4triangulation;
    // add nodes to container for triangulation //
    //     Vector2D maxPos(_box->size());
    //     Vector2D minPos(0.0);
    //     for(FilamentIterator fi=_filaments.begin(); fi!=_filaments.end(); fi++) {
    //       for(DefNodeIterator dni=(*fi)->nodes.begin(); dni!=(*fi)->nodes.end(); dni++) {
    // 	if((*dni)->position()[0] > maxPos[0]) maxPos[0] = (*dni)->position()[0];
    // 	if((*dni)->position()[1] > maxPos[1]) maxPos[1] = (*dni)->position()[1];
    // 	if((*dni)->position()[0] < minPos[0]) minPos[0] = (*dni)->position()[0];
    // 	if((*dni)->position()[1] < minPos[1]) minPos[1] = (*dni)->position()[1];
    //       }
    //     }

    for(FilamentIterator fi=_filaments.begin(); fi!=_filaments.end(); fi++) {
      bool itNodes = true;
      if(largestFil > 0.0) {
	int nNds = (*fi)->nodes.size();
	VectorND e2e;
	e2e = (*fi)->nodes[nNds-1]->position() - (*fi)->nodes[0]->position();
	if(norm2(e2e) > largestFil) itNodes = false;
      } 
      if(itNodes) {
	for(DefNodeIterator dni=(*fi)->nodes.begin(); dni!=(*fi)->nodes.end(); dni++) {
	  // 	if(isMaster(*dni)) {
	  // 	  Vector2D tmpPos;
	  // 	  Vector2D tmpDef;
	  // 	  tmpPos = (*dni)->position();
	  // 	  tmpDef = (*dni)->point() - (*dni)->position();
	  // 	  _box->mapPoint(tmpPos);
	  // 	  tmpDef += tmpPos;
	  // 	  DefNode* newNode = new BrownianNode<2>((*dni)->id(),(*dni)->index(),tmpPos,tmpDef);
	  // 	  newNode->setId((*dni)->id());
	  // 	  nodes4triangulation.push_back(newNode);
	  // 	}
	  if(!isSlave(*dni)) {
	    // 	  Vector2D tmpPos;
	    // 	  Vector2D tmpDef;
	    //  	  tmpPos = (*dni)->position() - minPos;
	    //  	  tmpDef = (*dni)->point() - minPos;
	    // 	  //tmpPos = (*dni)->position();
	    // 	  //_box->setShear(0.0);
	    // 	  //_box->mapPoint(tmpPos);
	    // 	  //tmpDef = (*dni)->point() - tmpPos;
	    // 	  //_box->setShear(shear);
	    // 	  //_box->mapDistance(tmpDef);
	    // 	  //tmpDef += tmpPos;
	    // 	  DefNode* newNode = new BrownianNode<2>((*dni)->id(),(*dni)->index(),tmpPos,tmpDef);
	    // 	  newNode->setId((*dni)->id());
	    nodes4triangulation.push_back(*dni);
	  }
	}
      }
    }

    // figure out how many different box sizes to use //
    //int nSteps = (int)(log2(syssize/(2.0*minLength)));
    int nSteps = (int)((maxLength-minLength)/stepSize);

    // create new grid with nodes' position (not point) as relevant location //
    Vector2D gridSpace;
    gridSpace[0] = minLength;
    gridSpace[1] = minLength;
    NodeGrid* nodegrid = new Grid<DefNode,BaseDefNode,2>();
    //PeriodicBox tmpBox(0.0,0.0);
    //Vector2D boxSize;
    //boxSize = maxPos - minPos;
    //if(boxSize[0] > boxSize[1]) boxSize[1] = boxSize[0];
    //else boxSize[0] = boxSize[1];
    //tmpBox.setSize(boxSize);
    nodegrid->setBox(_box);
    //nodegrid->setBox(&tmpBox);
    nodegrid->setPosFunc(&DeformationNode<2>::position);
    nodegrid->setGridSpace(gridSpace);
    nodegrid->setComputeNeighbors(false);
    nodegrid->addElems(nodes4triangulation);

    char angdistfile[256];
    if(getAngularDist) {
      std::cout << "Please enter a file name in which to put the angular distribution data for each distance: ";
      std::cin >> angdistfile;
    }

    
    double oldGridSize = 0.0;
    // for each length scale, find all pairs of points in range //
    for(int j=0; j<nSteps; j++) {
      // get new grid size, reset grid spacing, and add new elements //
      //double gridSize = minLength*pow(2.0,j);
      double gridSize = minLength + j*stepSize;
      for(int i=0; i<2; i++) gridSpace[i] = gridSize;
      nodegrid->resetGridSpace(gridSpace);
      gridSpace = nodegrid->gridSpace();
      gridSize = gridSpace[0];
      if(abs(gridSize-oldGridSize) > 1.0e-6) {
	oldGridSize = gridSize;
	std::cout << "new grid size = (" << gridSpace[0] << ", " << gridSpace[1] << ")" << std::endl;
	//nodegrid->addElems(nodes4triangulation);
	// get pairs //
	int nBoxes = nodegrid->nBoxes();
	double meandev = 0.0;
	double err = 0.0;
	int nSamps = 0;
	std::vector< std::pair<double,double> > angdata;
	std::vector<int> nAngSamps;
	if(getAngularDist) {
	  angdata.clear();
	  for(int ia=0; ia<16; ia++) {
	    double centang = (ia*M_PI/16.0) + M_PI/32.0;
	    std::pair<double,double> newPair = pair<double,double>(centang,0.0);
	    angdata.push_back(newPair);
	    nAngSamps.push_back(0);
	  }
	  ofstream angdatfile(angdistfile, ios::app);
	  angdatfile << "#r = " << gridSpace[0] << std::endl;
	  angdatfile.close();
	}
	for(int k=0; k<nBoxes; k++) {
	  //std::map< DefNode*, std::set< DefNode * > > nodePairs = nodegrid->getNeighbors(k);
	  std::set< DefNode * > & boxNodes = nodegrid->getBoxElems(k);
	  DefNodeContainer neighbNodes = nodegrid->getBoxNeighbors(k);
	  for(typename std::set< DefNode * >::iterator bn=boxNodes.begin(); bn!=boxNodes.end(); bn++) {
	    //for(int nd1=0; nd1<nBoxNodes; nd1++) {
	    //for(typename std::map< DefNode *, std::set< DefNode * > >::iterator npiter=nodePairs.begin(); npiter!=nodePairs.end(); npiter++) {
	    //DefNode * node1 = npiter->first;
	    DefNode * node1 = *bn;
	    for(typename std::set< DefNode * >::iterator bn2=bn; bn2!=boxNodes.end(); bn2++) {
	      if(bn2 != bn) {
		DefNode * node2 = *bn2;
		VectorND diff;
		diff = node1->position() - node2->position();
		if(fabs(norm2(diff)-gridSize)/gridSize < 1.0e-2) {
		  nSamps++;
		  double thetaAff = atan2(diff[1],diff[0]+(shear*diff[1]));
		  VectorND finaldiff;
		  finaldiff = node1->point() - node2->point();
		  double thetaActual = atan2(finaldiff[1],finaldiff[0]);
		  double dTheta = fabs(thetaActual-thetaAff) < M_PI ? thetaActual-thetaAff : 2.0*M_PI-fabs(thetaActual-thetaAff);
		  dTheta = sqr(dTheta);
		  meandev += dTheta;
		  err += sqr(dTheta);
		  if(getAngularDist) {
		    double tht = atan2(diff[1],diff[0]);
		    if(tht < 0) tht += M_PI;
		    int angindex = (int)(16.0*tht/M_PI);
		    angindex = angindex % 16;
		    nAngSamps[angindex]++;
		    angdata[angindex].second = angdata[angindex].second + dTheta;
		  }
		}
		else {
		  _box->setShear(0.0);
		  _box->mapDistance(diff);
		  if(fabs(norm2(diff)-gridSize)/gridSize < 1.0e-2) {
		    nSamps++;
		    double thetaAff = atan2(diff[1],diff[0]+(shear*diff[1]));
		    VectorND finaldiff;
		    finaldiff = node1->point() - node2->point();
		    _box->setShear(shear);
		    _box->mapDistance(finaldiff);
		    double thetaActual = atan2(finaldiff[1],finaldiff[0]);
		    double dTheta = fabs(thetaActual-thetaAff) < M_PI ? thetaActual-thetaAff : 2.0*M_PI-fabs(thetaActual-thetaAff);
		    dTheta = sqr(dTheta);
		    meandev += dTheta;
		    err += sqr(dTheta);  
		    _box->setShear(0.0);
		    if(getAngularDist) {
		      double tht = atan2(diff[1],diff[0]);
		      if(tht < 0) tht += M_PI;
		      int angindex = (int)(16.0*tht/M_PI);
		      angindex = angindex % 16;
		      nAngSamps[angindex]++;
		      angdata[angindex].second = angdata[angindex].second + dTheta;
		    }
		  }
		}
	      }
	    }
	    int nNeighbNodes = neighbNodes.size();
	    for(int nd2=0; nd2<nNeighbNodes; nd2++) {
	      //for(typename std::set< DefNode * >::iterator partiter=npiter->second.begin(); partiter!=npiter->second.end(); partiter++) {
	      //DefNode * node2 = *partiter;
	      DefNode * node2 = neighbNodes[nd2];
	      if(node1 < node2) {
		VectorND diff;
		diff = node1->position() - node2->position();
		if(fabs(norm2(diff)-gridSize)/gridSize < 1.0e-2) {
		  nSamps++;
		  double thetaAff = atan2(diff[1],diff[0]+(shear*diff[1]));
		  VectorND finaldiff;
		  finaldiff = node1->point() - node2->point();
		  double thetaActual = atan2(finaldiff[1],finaldiff[0]);
		  double dTheta = fabs(thetaActual-thetaAff) < M_PI ? thetaActual-thetaAff : 2.0*M_PI-fabs(thetaActual-thetaAff);
		  dTheta = sqr(dTheta);
		  meandev += dTheta;
		  err += sqr(dTheta);
		  if(getAngularDist) {
		    double tht = atan2(diff[1],diff[0]);
		    if(tht < 0) tht += M_PI;
		    int angindex = (int)(16.0*tht/M_PI);
		    angindex = angindex % 16;
		    nAngSamps[angindex]++;
		    angdata[angindex].second = angdata[angindex].second + dTheta;
		  }
		}
		else {
		  _box->setShear(0.0);
		  _box->mapDistance(diff);
		  if(fabs(norm2(diff)-gridSize)/gridSize < 1.0e-2) {
		    nSamps++;
		    double thetaAff = atan2(diff[1],diff[0]+(shear*diff[1]));
		    VectorND finaldiff;
		    finaldiff = node1->point() - node2->point();
		    _box->setShear(shear);
		    _box->mapDistance(finaldiff);
		    double thetaActual = atan2(finaldiff[1],finaldiff[0]);
		    double dTheta = fabs(thetaActual-thetaAff) < M_PI ? thetaActual-thetaAff : 2.0*M_PI-fabs(thetaActual-thetaAff);
		    dTheta = sqr(dTheta);
		    meandev += dTheta;
		    err += sqr(dTheta);  
		    _box->setShear(0.0);
		    if(getAngularDist) {
		      double tht = atan2(diff[1],diff[0]);
		      if(tht < 0) tht += M_PI;
		      int angindex = (int)(16.0*tht/M_PI);
		      angindex = angindex % 16;
		      nAngSamps[angindex]++;
		      angdata[angindex].second = angdata[angindex].second + dTheta;
		    }
		  }
		}
	      }
	    }
	  }
	}

	// compute mean and error of the mean //
	meandev /= nSamps;
	err /= nSamps;
	err = err - sqr(meandev);
	err *= (nSamps/(nSamps-1.0));
	err = sqrt(err);
	err /= sqrt(nSamps);
	meandev /= sqr(shear);
	err /= sqr(shear);
	
	// add data point to return value //
	
	std::pair<double, double> dp = pair<double,double>(meandev,err);
	doublePairWErrors newdatpt = std::pair<double, std::pair<double, double> >(gridSize,dp);
	affdata.push_back(newdatpt);
	
	if(getAngularDist) {
	  ofstream angdatfile(angdistfile, ios::app);
	  angdatfile << "#theta\tna_tot\tna_avg" << std::endl;
	  int nAngSlices = angdata.size();
	  for(int ait=0; ait<nAngSlices; ait++) {
	    angdata[ait].second = angdata[ait].second/nAngSamps[ait];
	    angdata[ait].second /= sqr(shear);
	    angdatfile << angdata[ait].first << "\t" << nAngSamps[ait]*angdata[ait].second << "\t" << angdata[ait].second << std::endl;
	  }
	  angdatfile << std::endl;
	  angdatfile.close();
	}
      }
    }
    
    return affdata;
  }

  template<int N>
  
  std::vector< std::pair<double, std::pair< double, double > > > SemiflexibleGel<N>::affineMeasurementHeadLevineInterpolated(double minLength, double stepSize, double maxLength, double shear, double largestFil) {
    std::cout << "Beginning Head/Levine affine measurement with node interpolation." << std::endl;
    
    doublePairWErrorsContainer affdata;
    FilamentContainer fils4affmeasure;
    
    for(FilamentIterator fi=_filaments.begin(); fi!=_filaments.end(); fi++) {
      bool itFil = true;
      if(largestFil > 0.0) {
	int nNds = (*fi)->nodes.size();
	VectorND e2e;
	e2e = (*fi)->nodes[nNds-1]->position() - (*fi)->nodes[0]->position();
	if(norm2(e2e) > largestFil) itFil = false;
      } 
      if(itFil) fils4affmeasure.push_back(*fi);
    }
  
      
    // figure out how many different box sizes to use //
    //int nSteps = (int)(log2(syssize/(2.0*minLength)));
    int nSteps = (int)((maxLength-minLength)/stepSize);

    int nFils4measure = fils4affmeasure.size();
    

    for(int n=0; n<nSteps; n++) {
      double cursep = minLength + n*stepSize;
      double meandev = 0.0;
      std::cout << "current length scale: " << cursep << "." << std::endl;
      double err = 0.0;
      int nSamps = 0;
      for(int i=0; i<nFils4measure; i++) {
	Filament * f1 = fils4affmeasure[i];
	int nNodes1 = f1->nodes.size();
	VectorND f1e2e;
	f1e2e = f1->nodes[nNodes1-1]->position() - f1->nodes[0]->position();
	double f1len = norm2(f1e2e);
	VectorND f1com;
	f1com = .5*(f1->nodes[nNodes1-1]->position() + f1->nodes[0]->position());
	for(int j=i; j<nFils4measure; j++) {
	  Filament * f2 = fils4affmeasure[j];
	  int nNodes2 = f2->nodes.size();
	  VectorND f2e2e;
	  f2e2e = f2->nodes[nNodes2-1]->position() - f2->nodes[0]->position();
	  double f2len = norm2(f2e2e);
	  VectorND f2com;
	  f2com = .5*(f2->nodes[nNodes2-1]->position() + f2->nodes[0]->position());
	  VectorND sep;
	  sep = f1com - f2com;
	  _box->setShear(0.0);
	  _box->mapDistance(sep);
	  if(norm2(sep) <= .5*(f1len+f2len)+(1.0+1.0e-2)*cursep) {
	    if(i==j) {
	      for(int ni=0; ni<nNodes1; ni++) {
		if(!isSlave(f1->nodes[ni])) {
		  VectorND n1pos; 
		  n1pos= f1->nodes[ni]->position();
		  VectorND dfrome;
		  dfrome = n1pos - f1->nodes[0]->position();
		  double eps = (norm2(dfrome)+cursep)/f1len;
		  if(eps < 1.0) {
		    int ilow = 0;
		    int ihigh = nNodes1-1;
		    while(ihigh-ilow > 1) {
		      int icur = (ihigh+ilow)/2;
		      VectorND n2pos;
		      n2pos = f2->nodes[icur]->position();
		      VectorND nodesep;
		      nodesep = n2pos - f1->nodes[0]->position();
		      if(norm2(nodesep)/f1len < eps) ilow = icur;
		      else ihigh = icur;
		    }
		    if(!isSlave(f2->nodes[ilow]) && !isSlave(f2->nodes[ihigh])) {
		      VectorND lowend;
		      lowend = f2->nodes[ilow]->position() - f2->nodes[0]->position();
		      double loweps = norm2(lowend)/f2len;
		      double extradist = f2len*(eps-loweps);
		      VectorND seg;
		      seg = f2->nodes[ihigh]->position() - f2->nodes[ilow]->position();
		      eps = extradist/norm2(seg);
		      assert(eps <= 1.0);
		      VectorND interpoint;
		      interpoint = eps*(f2->nodes[ihigh]->position()) + (1.0-eps)*(f2->nodes[ilow]->position());
		      VectorND initsep;
		      initsep = interpoint - n1pos;
		      assert(abs(norm2(initsep)-cursep) < 1.0e-6);
		      double thetaAff = atan2(initsep[1],initsep[0]+(shear*initsep[1]));
		      VectorND finalpoint;
		      finalpoint = eps*(f2->nodes[ihigh]->point()) + (1.0-eps)*(f2->nodes[ilow]->point());
		      VectorND finalsep;
		      finalsep = finalpoint - f1->nodes[ni]->point();
		      double thetaActual = atan2(finalsep[1],finalsep[0]);
		      double dTheta = fabs(thetaActual-thetaAff) < M_PI ? thetaActual-thetaAff : 2.0*M_PI-fabs(thetaActual-thetaAff);
		      dTheta = sqr(dTheta);
		      meandev += dTheta;
		      err += sqr(dTheta);
		      nSamps++;
		    }
		  }
		  
		}
	      }
		
	    } // end "if filaments are the same..."
	    else {
	      for(int ni=0; ni<nNodes1; ni++) {
		if(!isSlave(f1->nodes[ni])) {
		  VectorND n1pos; 
		  n1pos= f1->nodes[ni]->position();
		  VectorND a;
		  a = f2->nodes[0]->position() - n1pos;
		  _box->setShear(0.0);
		  _box->mapDistance(a);
		  double dotp = dot(f2e2e,a);
		  double inrootq = ((sqr(cursep)-sqr(norm2(a)))*sqr(f2len)) + sqr(dotp);
		  if(inrootq >= 0.0) inrootq = sqrt(inrootq);
		  double eps1 = -dotp + inrootq;
		  double eps2 = -dotp - inrootq;
		  eps1 /= sqr(f2len);
		  eps2 /= sqr(f2len);
		  int oldilow = -1;
		  if(eps1<1.0 && eps1>0.0 && inrootq>=0.0) {
		    int ilow = 0;
		    int ihigh = nNodes2-1;
		    while(ihigh-ilow > 1) {
		      int icur = (ihigh+ilow)/2;
		      VectorND n2pos;
		      n2pos = f2->nodes[icur]->position();
		      VectorND nodesep;
		      nodesep = n2pos - f2->nodes[0]->position();
		      if(norm2(nodesep)/f2len < eps1) ilow = icur;
		      else ihigh = icur;
		    }
		    assert(ilow>=0);
		    assert(ihigh<=nNodes2-1);
		    assert(ihigh-ilow==1);
		    // now compute measure with interpolated point...
		    if(!isSlave(f2->nodes[ilow]) && !isSlave(f2->nodes[ihigh])) {
		      VectorND lowend;
		      lowend = f2->nodes[ilow]->position() - f2->nodes[0]->position();
		      double loweps = norm2(lowend)/f2len;
		      double extradist = f2len*(eps1-loweps);
		      VectorND seg;
		      seg = f2->nodes[ihigh]->position() - f2->nodes[ilow]->position();
		      eps1 = extradist/norm2(seg);
		      assert(eps1 <= 1.0);
		      VectorND interpoint;
		      interpoint = eps1*(f2->nodes[ihigh]->position()) + (1.0-eps1)*(f2->nodes[ilow]->position());
		      VectorND initsep;
		      initsep = interpoint - n1pos;
		      _box->mapDistance(initsep);
		      assert(abs(norm2(initsep)-cursep) < 1.0e-6);
		      double thetaAff = atan2(initsep[1],initsep[0]+(shear*initsep[1]));
		      VectorND finalpoint;
		      finalpoint = eps1*(f2->nodes[ihigh]->point()) + (1.0-eps1)*(f2->nodes[ilow]->point());
		      VectorND finalsep;
		      finalsep = finalpoint - f1->nodes[ni]->point();
		      _box->setShear(shear);
		      _box->mapDistance(finalsep);
		      _box->setShear(0.0);
		      double thetaActual = atan2(finalsep[1],finalsep[0]);
		      double dTheta = fabs(thetaActual-thetaAff) < M_PI ? thetaActual-thetaAff : 2.0*M_PI-fabs(thetaActual-thetaAff);
		      dTheta = sqr(dTheta);
		      meandev += dTheta;
		      err += sqr(dTheta);
		      nSamps++;
		      oldilow = ilow;
		    }
		    
		  }
		  if(eps2<1.0 && eps2>0.0 && inrootq>=0.0) {
		    int ilow = 0;
		    int ihigh = nNodes2-1;
		    while(ihigh-ilow > 1) {
		      int icur = (ihigh+ilow)/2;
		      VectorND n2pos;
		      n2pos = f2->nodes[icur]->position();
		      VectorND nodesep;
		      nodesep = n2pos - f2->nodes[0]->position();
		      if(norm2(nodesep)/f2len < eps2) ilow = icur;
		      else ihigh = icur;
		    }
		    assert(ilow>=0);
		    assert(ihigh<=nNodes2-1);
		    assert(ihigh-ilow==1);
		    // now compute measure with interpolated point...
		    if(ilow != oldilow && !isSlave(f2->nodes[ilow]) && !isSlave(f2->nodes[ihigh])) {
		      VectorND lowend;
		      lowend = f2->nodes[ilow]->position() - f2->nodes[0]->position();
		      double loweps = norm2(lowend)/f2len;
		      double extradist = f2len*(eps2-loweps);
		      VectorND seg;
		      seg = f2->nodes[ihigh]->position() - f2->nodes[ilow]->position();
		      eps2 = extradist/norm2(seg);
		      assert(eps2 <= 1.0);
		      VectorND interpoint;
		      interpoint = eps2*(f2->nodes[ihigh]->position()) + (1.0-eps2)*(f2->nodes[ilow]->position());
		      VectorND initsep;
		      initsep = interpoint - n1pos;
		      _box->mapDistance(initsep);
		      assert(abs(norm2(initsep)-cursep) < 1.0e-6);
		      double thetaAff = atan2(initsep[1],initsep[0]+(shear*initsep[1]));
		      VectorND finalpoint;
		      finalpoint = eps2*(f2->nodes[ihigh]->point()) + (1.0-eps2)*(f2->nodes[ilow]->point());
		      VectorND finalsep;
		      finalsep = finalpoint - f1->nodes[ni]->point();
		      _box->setShear(shear);
		      _box->mapDistance(finalsep);
		      _box->setShear(0.0);
		      double thetaActual = atan2(finalsep[1],finalsep[0]);
		      double dTheta = fabs(thetaActual-thetaAff) < M_PI ? thetaActual-thetaAff : 2.0*M_PI-fabs(thetaActual-thetaAff);
		      dTheta = sqr(dTheta);
		      meandev += dTheta;
		      err += sqr(dTheta);
		      nSamps++;
		    }
		    
		  }
		}
	      }
	    } //end "if filaments are different..."
	  } // end "if filaments are close enough..."
	  
	}
      }
      // compute mean deviation and error
      meandev /= nSamps;
      err /= nSamps;
      err = err - sqr(meandev);
      err *= (nSamps/(nSamps-1.0));
      err = sqrt(err);
      err /= sqrt(nSamps);
      meandev /= sqr(shear);
      err /= sqr(shear);

      std::pair<double, double> dp = pair<double,double>(meandev,err);
      doublePairWErrors newdatpt = std::pair<double, std::pair<double, double> >(cursep,dp);
      affdata.push_back(newdatpt);
    }

    return affdata;
  }
  
  template<int N>
  void SemiflexibleGel<N>::affineBoxesMeasurement(VectorND & boxsize, double pairDist, double shear, double largestFil, std::string fileName, bool doCorrTest) {
    DefNodeContainer nodes4triangulation;
    for(FilamentIterator fi=_filaments.begin(); fi!=_filaments.end(); fi++) {
      bool itNodes = true;
      if(largestFil > 0.0) {
	int nNds = (*fi)->nodes.size();
	VectorND e2e;
	e2e = (*fi)->nodes[nNds-1]->position() - (*fi)->nodes[0]->position();
	if(norm2(e2e) > largestFil) itNodes = false;
      } 
      if(itNodes) {
	for(DefNodeIterator dni=(*fi)->nodes.begin(); dni!=(*fi)->nodes.end(); dni++) {
	  // 	if(isMaster(*dni)) {
	  // 	  Vector2D tmpPos;
	  // 	  Vector2D tmpDef;
	  // 	  tmpPos = (*dni)->position();
	  // 	  tmpDef = (*dni)->point() - (*dni)->position();
	  // 	  _box->mapPoint(tmpPos);
	  // 	  tmpDef += tmpPos;
	  // 	  DefNode* newNode = new BrownianNode<2>((*dni)->id(),(*dni)->index(),tmpPos,tmpDef);
	  // 	  newNode->setId((*dni)->id());
	  // 	  nodes4triangulation.push_back(newNode);
	  // 	}
	  if(!isSlave(*dni)) {
	    // 	  Vector2D tmpPos;
	    // 	  Vector2D tmpDef;
	    //  	  tmpPos = (*dni)->position() - minPos;
	    //  	  tmpDef = (*dni)->point() - minPos;
	    // 	  //tmpPos = (*dni)->position();
	    // 	  //_box->setShear(0.0);
	    // 	  //_box->mapPoint(tmpPos);
	    // 	  //tmpDef = (*dni)->point() - tmpPos;
	    // 	  //_box->setShear(shear);
	    // 	  //_box->mapDistance(tmpDef);
	    // 	  //tmpDef += tmpPos;
	    // 	  DefNode* newNode = new BrownianNode<2>((*dni)->id(),(*dni)->index(),tmpPos,tmpDef);
	    // 	  newNode->setId((*dni)->id());
	    nodes4triangulation.push_back(*dni);
	  }
	}
      }
    }

    NodeGrid* nodegrid = new Grid<DefNode,BaseDefNode,2>();
    nodegrid->setBox(_box);
    nodegrid->setPosFunc(&DeformationNode<2>::position);
    nodegrid->setGridSpace(boxsize);
    nodegrid->setComputeNeighbors(false);
    nodegrid->addElems(nodes4triangulation);

    VectorND actualGridSize;
    actualGridSize = nodegrid->gridSpace();

    std::cout << "Do you want to store the nonaffinities of all collected point pairs (1 for yes)? ";
    int collectPairs;
    std::cin >> collectPairs;
    
    int nBoxes = nodegrid->nBoxes();
    std::vector<double> affMeasures(nBoxes);
    std::vector<double> nonaffs;
    std::cout << "Computing affinity measure in " << nBoxes << " boxes." << std::endl;
    for(int k=0; k<nBoxes; k++) {
      if(k%10 == 0) std::cout << "Finished " << k << " boxes." << std::endl;
      affMeasures[k] = 0.0;
      double nSamps = 0.0;
      //std::map< DefNode*, std::set< DefNode * > > nodePairs = nodegrid->getNeighbors(k);
      std::set< DefNode * > & boxNodes = nodegrid->getBoxElems(k);
      DefNodeContainer neighbNodes = nodegrid->getBoxNeighbors(k);
      for(typename std::set< DefNode * >::iterator bn=boxNodes.begin(); bn!=boxNodes.end(); bn++) {
	//for(int nd1=0; nd1<nBoxNodes; nd1++) {
	//for(typename std::map< DefNode *, std::set< DefNode * > >::iterator npiter=nodePairs.begin(); npiter!=nodePairs.end(); npiter++) {
	//DefNode * node1 = npiter->first;
	DefNode * node1 = *bn;
	for(typename std::set< DefNode * >::iterator bn2=bn; bn2!=boxNodes.end(); bn2++) {
	  if(bn2 != bn) {
	    DefNode * node2 = *bn2;
	    VectorND diff;
	    diff = node1->position() - node2->position();
	    if(fabs(norm2(diff)-pairDist)/pairDist < 1.0e-2) {
	      nSamps += 1.0;
	      double thetaAff = atan2(diff[1],diff[0]+(shear*diff[1]));
	      VectorND finaldiff;
	      finaldiff = node1->point() - node2->point();
	      double thetaActual = atan2(finaldiff[1],finaldiff[0]);
	      double dTheta = fabs(thetaActual-thetaAff) < M_PI ? thetaActual-thetaAff : 2.0*M_PI-fabs(thetaActual-thetaAff);
	      dTheta = sqr(dTheta);
	      affMeasures[k] += dTheta;
	      if(collectPairs==1) nonaffs.push_back(dTheta/sqr(shear));
	    }
	    else {
	      _box->setShear(0.0);
	      _box->mapDistance(diff);
	      if(fabs(norm2(diff)-pairDist)/pairDist < 1.0e-2) {
		nSamps += 1.0;
		double thetaAff = atan2(diff[1],diff[0]+(shear*diff[1]));
		VectorND finaldiff;
		finaldiff = node1->point() - node2->point();
		_box->setShear(shear);
		_box->mapDistance(finaldiff);
		double thetaActual = atan2(finaldiff[1],finaldiff[0]);
		double dTheta = fabs(thetaActual-thetaAff) < M_PI ? thetaActual-thetaAff : 2.0*M_PI-fabs(thetaActual-thetaAff);
		dTheta = sqr(dTheta);
		affMeasures[k] += dTheta;
		if(collectPairs==1) nonaffs.push_back(dTheta/sqr(shear));
		_box->setShear(0.0);
	      }
	    }
	  }
	}
	int nNeighbNodes = neighbNodes.size();
	for(int nd2=0; nd2<nNeighbNodes; nd2++) {
	  //for(typename std::set< DefNode * >::iterator partiter=npiter->second.begin(); partiter!=npiter->second.end(); partiter++) {
	  //DefNode * node2 = *partiter;
	  DefNode * node2 = neighbNodes[nd2];
	  VectorND diff;
	  diff = node1->position() - node2->position();
	  if(fabs(norm2(diff)-pairDist)/pairDist < 1.0e-2) {
	    nSamps += 0.5;
	    double thetaAff = atan2(diff[1],diff[0]+(shear*diff[1]));
	    VectorND finaldiff;
	    finaldiff = node1->point() - node2->point();
	    double thetaActual = atan2(finaldiff[1],finaldiff[0]);
	    double dTheta = fabs(thetaActual-thetaAff) < M_PI ? thetaActual-thetaAff : 2.0*M_PI-fabs(thetaActual-thetaAff);
	    dTheta = sqr(dTheta);
	    affMeasures[k] += 0.5*dTheta;
	    if(collectPairs==1 && node1>node2) nonaffs.push_back(dTheta/sqr(shear));
	  }
	  else {
	    _box->setShear(0.0);
	    _box->mapDistance(diff);
	    if(fabs(norm2(diff)-pairDist)/pairDist < 1.0e-2) {
	      nSamps += 0.5;
	      double thetaAff = atan2(diff[1],diff[0]+(shear*diff[1]));
	      VectorND finaldiff;
	      finaldiff = node1->point() - node2->point();
	      _box->setShear(shear);
	      _box->mapDistance(finaldiff);
	      double thetaActual = atan2(finaldiff[1],finaldiff[0]);
	      double dTheta = fabs(thetaActual-thetaAff) < M_PI ? thetaActual-thetaAff : 2.0*M_PI-fabs(thetaActual-thetaAff);
	      dTheta = sqr(dTheta);
	      affMeasures[k] += 0.5*dTheta;
	      if(collectPairs==1 && node1>node2) nonaffs.push_back(dTheta/sqr(shear));
	      _box->setShear(0.0);
	    }
	  }
	  
	}
      }
      
      if(nSamps > 0.0) {
	affMeasures[k] /= nSamps;
	affMeasures[k] /= sqr(shear);
      }
      else affMeasures[k] = 0.0;
    }

    if(collectPairs!=1) {
      // print out average value of nonaffinity and standard deviation
    
      double meanna = 0.0;
      double stdna = 0.0;
      for(int nk=0; nk<nBoxes; nk++) {
	meanna += affMeasures[nk];
	stdna += sqr(affMeasures[nk]);
      }
      meanna /= nBoxes;
      stdna /= nBoxes;
      stdna -= sqr(meanna);
      stdna = sqrt(stdna);
      
      meanna /= sqr(shear);
      stdna /= sqr(shear);
      
      std::cout << "Average value of nonaffinity = " << meanna << "; standard deviation = " << stdna << "." << std::endl;
    }

    else {
      std::cout << "Enter the name of a file in which to put the nonaffinities: ";
      char naf[256];
      std::cin >> naf;
      std::ofstream naffile(naf);
      naffile << "#nonaffinities, r = " << pairDist << std::endl;
      for(vector<double>::iterator pdi=nonaffs.begin(); pdi!=nonaffs.end(); pdi++) {
	naffile << *pdi << std::endl;
      }
      naffile.close();
    }

    // now write vtk file with rectangles containing one scalar--the nonaffinity measure

    std::string fName = fileName + ".vtk";
    std::ofstream ofs(fName.c_str());
    if (!ofs) {
      std::cout << "Error: can not open paraview output file "
		<< fName
		<< std::endl;
      return;
    }

    tvmet::Vector<int,N> nBoxesDim;
    nBoxesDim = nodegrid->nBoxesDim();
    int nBTest = 1;
    for(int n=0; n<N; n++) {
      nBTest *= nBoxesDim[n];
    }
    assert(nBoxes == nBTest);

    int nPts = 1;
    for(int n=0; n<N; n++) {
      nPts *= (nBoxesDim[n]+1);
    }
    
    ofs << "# vtk DataFile Version 2.0\n"
	<< "Test example" << std::endl
	<< "ASCII" << std::endl
	<< "DATASET POLYDATA" << std::endl
	<< "POINTS  " << nPts << "  double" << std::endl;
    
    if(N==2) {
      for(int p=0; p<=nBoxesDim[0]; p++) {
	for(int q=0; q<=nBoxesDim[1]; q++) {
	  ofs << std::setprecision(16) 
	      << p*actualGridSize[0] << "  "
	      << 0.0 << "  "
	      << q*actualGridSize[1] << std::endl;
	}
      }

      ofs << "POLYGONS  " << nBoxes << "  "
	  << 5*nBoxes << std::endl;
      
      for(int p=0; p<nBoxesDim[0]; p++) {
	for(int q=0; q<nBoxesDim[1]; q++) {
	  int lowerCorner = p*(nBoxesDim[1]+1) + q;
	  ofs << 4 << "  "
	      << std::setw(10) << lowerCorner
	      << std::setw(10) << lowerCorner+1
	      << std::setw(10) << lowerCorner+nBoxesDim[1]+2
	      << std::setw(10) << lowerCorner+nBoxesDim[1]+1
	      << std::endl;
	}
      }
      
      ofs << "CELL_DATA    " << nBoxes << std::endl;
      ofs << "SCALARS    Nonaffinity    double    1" << std::endl;
      ofs << "LOOKUP_TABLE default" << std::endl;
      for(int p=0; p<nBoxes; p++) ofs << affMeasures[p] << std::endl;
      
    }
    
    ofs.close();

    if(doCorrTest) {
      std::cout << "Do you also want to compute the long filament length density/Head-Levine nonaffinity correlation function?\n(1) yes\n(2) no\n:";
      int ldnacorr;
      std::cin >> ldnacorr;
      std::vector<double> longld(nBoxes,0.0);
      double maxdist;
      if(ldnacorr==1) {
	std::cout << "Please input a maximum distance on which to compute correlations: ";
	std::cin >> maxdist;
	_box->setShear(0.0);
	for(FilamentIterator f=_filaments.begin(); f!=_filaments.end(); f++) {
	  int nNodes = (*f)->nodes.size();
	  bool isLong = false;
	  VectorND fe2e;
	  fe2e = (*f)->nodes[nNodes-1]->position() - (*f)->nodes[0]->position();
	  double fillen = norm2(fe2e);
	  if(fillen > largestFil) isLong = true;
	  if(isLong) {
	    for(int b=0; b<nNodes-1; b++) {
	      VectorND com;
	      com = .5*((*f)->nodes[b]->position() + (*f)->nodes[b+1]->position());
	      _box->mapPoint(com);
	      tvmet::Vector<int,N> coords;
	      int idx = 0;
	      for(int i=0; i<N; i++) {
		coords[i] = (int)(com[i]/actualGridSize[i]);
		coords[i] = coords[i]%nBoxesDim[i];
	      }
	      if(N==2) idx = nBoxesDim[1]*coords[0] + coords[1];
	      VectorND e2e;
	      e2e = (*f)->nodes[b]->position() - (*f)->nodes[b+1]->position();
	      double len = norm2(e2e);
	      longld[idx] += len;
	    }
	  }
	}
	double boxVol = 1.0;
	for(int dim=0; dim<N; dim++) boxVol *= actualGridSize[dim];
	for(int nb=0; nb<nBoxes; nb++) longld[nb] /= boxVol;
      }
 
      std::map<DefNode*,double> dataPts;
      std::map< DefNode*, std::pair<double,double> > lendensNonaffData;
      for(int k=0; k<nBoxes; k++) {
	if(affMeasures[k] > 0.0) {
	  NodeBase::DofIndexMap idx(N);
	  for(int j=0; j<N; j++) idx[j] = k*N + j;
	  if(N==2) {
	    VectorND cellCenter;
	    int row = k/nBoxesDim[1];
	    int column = k%nBoxesDim[1];
	    cellCenter[0] = (row+0.5)*actualGridSize[0];
	    cellCenter[1] = (column+0.5)*actualGridSize[1];
	    DefNode* newNode = new BrownianNode<2>(k,idx,cellCenter,cellCenter);
	    dataPts.insert(pair<DefNode*,double>(newNode,affMeasures[k]));
	    if(ldnacorr==1) {
	      std::pair<double,double> newPair = pair<double,double>(affMeasures[k],longld[k]);
	      lendensNonaffData.insert(pair< DefNode*, pair<double,double> >(newNode,newPair));
	    }
	  }
	}
      }
      if(N==2) {
	std::vector< pair<double,double> > corrData = computeCorrelationFunction(dataPts,max(actualGridSize[0],actualGridSize[1]),min(_box->size()[0],_box->size()[1])/3.0,max(actualGridSize[0],actualGridSize[1]),min(actualGridSize[0],actualGridSize[1])/2.0);
	std::cout << "Please input a file name in which to output the nonaffinity correlation data: ";
	char affCorrFN[256];
	std::cin >> affCorrFN;
	std::ofstream affCorrFile(affCorrFN);
	affCorrFile << "#r\tcorr\n";
	for(typename vector< pair<double,double> >::iterator pi=corrData.begin(); pi!=corrData.end(); pi++) {
	  affCorrFile << pi->first << "\t" << pi->second << "\n";
	}
	affCorrFile.close();
	
	if(ldnacorr==1) {
	  std::cout << "Please enter a file name in which to store the long filament lengt density/Head-Levine nonaffinity correlaion data: ";
	  char naldf[256];
	  std::cin >> naldf;
	  
	  double maxdim = max(actualGridSize[0],actualGridSize[1]);
	  //double maxdist = min(_box->size()[0],_box->size()[1])/3.0;
	  std::vector< std::pair<double,double> > corr = computeCrossCorrelationFunction(lendensNonaffData,2.0*maxdim,maxdist,2.0*maxdim,maxdim/2.0);
	  
	  std::ofstream nonAffLD(naldf);
	  nonAffLD << "#r\tcorr" << std::endl;
	  
	  for(typename vector< pair<double,double> >::iterator datait=corr.begin(); datait!=corr.end(); datait++) {
	    nonAffLD << datait->first << "\t" << datait->second << std::endl;
	  }
	  
	  nonAffLD.close();
	}
      }
      


 
    }
  }

  template<int N>
  void SemiflexibleGel<N>::computeBucklingMap(VectorND & boxsize, double shear, double bendfrac, std::string fileName, bool doCorrTest) {

    tvmet::Vector<int,N> nBox;
    int nBoxes = 1;
    VectorND gridSpace;
    for(int jd=0;jd<N; jd++) {
      nBox[jd] = (int)(_box->size()[jd]/boxsize[jd]);
      gridSpace[jd] = _box->size()[jd]/nBox[jd];
      nBoxes *= nBox[jd];
    }

    tvmet::Vector<int,N> mults;
    int curMult = nBoxes;
    for(int i=0; i<N; i++) {
      curMult /= nBox[i];
      mults[i] = curMult;
    }

    std::vector<double> compressedFD(nBoxes,0.0);
    std::vector<double> buckledFD(nBoxes,0.0);
    _box->setShear(0.0);
    for(FilamentIterator f=_filaments.begin(); f!=_filaments.end(); f++) {
      int nNodes = (*f)->nodes.size();
      for(int b=0; b<nNodes-1; b++) {
	VectorND com;
	com = .5*((*f)->nodes[b]->position() + (*f)->nodes[b+1]->position());
	_box->mapPoint(com);
	tvmet::Vector<int,N> coords;
	int idx = 0;
	for(int i=0; i<N; i++) {
	  coords[i] = (int)(com[i]/gridSpace[i]);
	  coords[i] = coords[i]%nBox[i];
	  idx += mults[i]*coords[i];
	}
	VectorND e2e;
	e2e = (*f)->nodes[b]->position() - (*f)->nodes[b+1]->position();
	double len = norm2(e2e);

	// check if the segment is under compression //
	double origLength = (*f)->bonds[b]->getLength();
	(*f)->bonds[b]->resetLength();
	double newLength = (*f)->bonds[b]->getLength();
	(*f)->bonds[b]->resetLength(origLength);
	if(newLength < origLength) {
	  // get stretching energy
	  double stretchE = (*f)->bonds[b]->energy();
	  double bendE = 0.0;
	  //get bending energy
	  if(nNodes>2) {
	    int nAngs = (*f)->angles.size();
	    assert(nAngs == nNodes-2);
	    if(b==0) {
	      bendE = .5*(*f)->angles[0]->energy();
	    }
	    else if(b==nNodes-2) {
	      bendE = .5*(*f)->angles[nAngs-1]->energy();
	    }
	    else {
	      bendE = .5*(*f)->angles[b-1]->energy();
	      bendE += .5*(*f)->angles[b]->energy();
	    }
	  }
	  
	  double totalE = stretchE + bendE;
	    
	  compressedFD[idx] += len;
	  if(bendE/totalE >= bendfrac) buckledFD[idx] += len;

	}
      }      
    }

    double boxVol = 1.0;
    for(int dim=0; dim<N; dim++) boxVol *= gridSpace[dim];
    for(int nb=0; nb<nBoxes; nb++) {
      compressedFD[nb] /= boxVol;
      buckledFD[nb] /= boxVol;
    }
    
    std::map<DefNode*, double> data;
    std::map<DefNode*, double> dataNormalized;
    for(int k=0; k<nBoxes; k++) {
      NodeBase::DofIndexMap idx(N);
      for(int j=0; j<N; j++) idx[j] = k*N + j;
      if(N==2) {
	VectorND cellCenter;
	int row = k/nBox[1];
	int column = k%nBox[1];
	cellCenter[0] = (row+0.5)*gridSpace[0];
	cellCenter[1] = (column+0.5)*gridSpace[1];
	DefNode* newNode = new BrownianNode<2>(k,idx,cellCenter,cellCenter);
	//std::pair<double,double> dpr = pair<double,double>(compressedFD[k],buckledFD[k]);
	data.insert(std::pair<DefNode*,double>(newNode,buckledFD[k]));
	dataNormalized.insert(std::pair<DefNode*,double>(newNode,buckledFD[k]/compressedFD[k]));
      }
    }
    
    double maxdim = 0.0;
    for(int dim=0; dim<N; dim++) {
      if(gridSpace[dim] > maxdim) maxdim = gridSpace[dim];
    }

    // now write vtk file with rectangles containing one scalar--the nonaffinity measure

    std::string fName = fileName + ".vtk";
    std::ofstream ofs(fName.c_str());
    if (!ofs) {
      std::cout << "Error: can not open paraview output file "
		<< fName
		<< std::endl;
      return;
    }

    int nPts = 1;
    for(int n=0; n<N; n++) {
      nPts *= (nBox[n]+1);
    }
    
    ofs << "# vtk DataFile Version 2.0\n"
	<< "Test example" << std::endl
	<< "ASCII" << std::endl
	<< "DATASET POLYDATA" << std::endl
	<< "POINTS  " << nPts << "  double" << std::endl;
    
    if(N==2) {
      for(int p=0; p<=nBox[0]; p++) {
	for(int q=0; q<=nBox[1]; q++) {
	  ofs << std::setprecision(16) 
	      << p*gridSpace[0] << "  "
	      << 0.0 << "  "
	      << q*gridSpace[1] << std::endl;
	}
      }

      ofs << "POLYGONS  " << nBoxes << "  "
	  << 5*nBoxes << std::endl;
      
      for(int p=0; p<nBox[0]; p++) {
	for(int q=0; q<nBox[1]; q++) {
	  int lowerCorner = p*(nBox[1]+1) + q;
	  ofs << 4 << "  "
	      << std::setw(10) << lowerCorner
	      << std::setw(10) << lowerCorner+1
	      << std::setw(10) << lowerCorner+nBox[1]+2
	      << std::setw(10) << lowerCorner+nBox[1]+1
	      << std::endl;
	}
      }
      
      ofs << "CELL_DATA    " << nBoxes << std::endl;
      ofs << "SCALARS    CompressedLenDens    double    1" << std::endl;
      ofs << "LOOKUP_TABLE default" << std::endl;
      for(int p=0; p<nBoxes; p++) ofs << compressedFD[p] << std::endl;

      ofs << std::endl;

      ofs << "SCALARS    BuckledLenDens    double    1" << std::endl;
      ofs << "LOOKUP_TABLE default" << std::endl;
      for(int p=0; p<nBoxes; p++) ofs << buckledFD[p] << std::endl;      
      
    }
    
    ofs.close();

    if(doCorrTest) {
      
 
      if(N==2) {
	std::vector< pair<double,double> > corrData = computeCorrelationFunction(data,maxdim,min(_box->size()[0],_box->size()[1])/3.0,maxdim,maxdim/4.0);
	std::vector< pair<double,double> > corrDataNormal = computeCorrelationFunction(dataNormalized,maxdim,min(_box->size()[0],_box->size()[1])/3.0,maxdim,maxdim/4.0);
	
	std::cout << "Please input a file name in which to output the buckling correlation data: ";
	char buckCorrFN[256];
	std::cin >> buckCorrFN;
	std::ofstream buckCorrFile(buckCorrFN);
	buckCorrFile << "#r\tcorr\n";
	typename vector< pair<double,double> >::iterator pi2 = corrDataNormal.begin();
	for(typename vector< pair<double,double> >::iterator pi=corrData.begin(); pi!=corrData.end(); pi++) {
	  buckCorrFile << pi->first << "\t" << pi->second << "\t" << pi2->second << "\n";
	  pi2++;
	}
	buckCorrFile.close();
	

      }
 
    }
  }

  template<int N>
  void SemiflexibleGel<N>::buckleOPCalc(double gridSize, std::map<double,std::string> strainedGelFiles, bool doCorrs) {
    Vector2D bondGridSize;
    bondGridSize[0] = gridSize;
    bondGridSize[1] = gridSize;
    int nBx = (int)(_box->size()[0]/bondGridSize[0]);
    int nBy = (int)(_box->size()[1]/bondGridSize[1]);
    bondGridSize[0] = _box->size()[0]/nBx;
    bondGridSize[1] = _box->size()[1]/nBy;
    double maxdim = 0.0;
    
    for(int dim=0; dim<N; dim++) {
      if(bondGridSize[dim] > maxdim) maxdim = bondGridSize[dim];
    }
    
    int nBoxes = nBx*nBy;
    double lastEtot = 0.0;
    double curEtot = 0.0;
    double lastEcomp = 0.0;
    double curEcomp = 0.0;
    double lastEtotaffine = 0.0;
    double curEtotaffine = 0.0;
    double curEcompaffine = 0.0;
    double lastEcompaffine = 0.0;
    std::vector<double> lastEtots(nBoxes);
    std::vector<double> curEtots(nBoxes);
    std::vector<double> lastEcomps(nBoxes);
    std::vector<double> curEcomps(nBoxes);
    std::vector<double> lastEtotsaffine(nBoxes);
    std::vector<double> curEtotsaffine(nBoxes);
    std::vector<double> lastEcompsaffine(nBoxes);
    std::vector<double> curEcompsaffine(nBoxes);
    std::vector<int> nElems(nBoxes);
    std::vector<int> nElemsCompressed(nBoxes);
    std::set<int> compFils;
    typename std::map< double, std::string >::iterator fileIt = strainedGelFiles.begin();
    updateNodalPoints(fileIt->second);
    _box->setShearX(fileIt->first);
    compute(true,true,false);
    _box->setShearX(0.0);
    for(int ii=0; ii<nBoxes; ii++) {
      lastEtots[ii] = 0.0;
      curEtots[ii] = 0.0;
      lastEcomps[ii] = 0.0;
      curEcomps[ii] = 0.0;
      lastEtotsaffine[ii] = 0.0;
      curEtotsaffine[ii] = 0.0;
      lastEcompsaffine[ii] = 0.0;
      curEcompsaffine[ii] = 0.0;
      nElems[ii] = 0;
    }
    std::cout << "Enter the name of a directory in which to store the vtk and correlation data files:\n";
    char dnm[256];
    std::cin >> dnm;
    std::string buckDir(dnm);
    if(buckDir.find("/")==string::npos) {
      buckDir += "/";
    }

    char totOPfl[256];
    sprintf(totOPfl,"buckleOPtotal.dat");
    std::string totOPFile(totOPfl);
    totOPFile.insert(0,buckDir);

    std::ofstream overallbuckFile(totOPFile.c_str());
    overallbuckFile << "#shear\t\tdEc/dEtot\t\tbuckOP\t\tdEc/dEtotaff\t\tbuckOPaff\t\tbuckOPcompaff" << std::endl;
    overallbuckFile.close();

    for(int nFil=0; nFil<_filaments.size(); nFil++) {
      int nNodesFil = filament(nFil)->nodes.size();
      VectorND start,end;
      start = filament(nFil)->nodes[0]->position();
      end = filament(nFil)->nodes[nNodesFil-1]->position();
      VectorND end2end;
      end2end = end - start;
      double filAng = atan2(end2end[1],end2end[0]);
      if(filAng < 0.0) filAng += M_PI;
      if(filAng > M_PI/2.0) {
	compFils.insert(nFil);
      }
      int nBonds = filament(nFil)->bonds.size();
      int nAngles = filament(nFil)->angles.size();
      for(int nbond=0; nbond<nBonds; nbond++) {
	VectorND bondPt;
	bondPt = 0.5*(filament(nFil)->nodes[nbond]->position() + filament(nFil)->nodes[nbond+1]->position());
	_box->mapPoint(bondPt);
	int xbox = (int)(bondPt[0]/bondGridSize[0]);
	int ybox = (int)(bondPt[1]/bondGridSize[1]);
	int indx = xbox*nBy + ybox;
	lastEtots[indx] += filament(nFil)->bonds[nbond]->energy();
	nElems[indx]++;
	lastEtot += filament(nFil)->bonds[nbond]->energy();
	if(compFils.find(nFil) != compFils.end()) {
	  lastEcomps[indx] += filament(nFil)->bonds[nbond]->energy();
	  nElemsCompressed[indx]++;
	  lastEcomp += filament(nFil)->bonds[nbond]->energy();
	}
      }
      for(int nang=0; nang<nAngles; nang++) {
	VectorND angPt;
	angPt = filament(nFil)->nodes[nang+1]->position();
	_box->mapPoint(angPt);
	int xbox = (int)(angPt[0]/bondGridSize[0]);
	int ybox = (int)(angPt[1]/bondGridSize[1]);
	int indx = xbox*nBy + ybox;
	lastEtots[indx] += filament(nFil)->angles[nang]->energy();
	nElems[indx]++;
	lastEtot += filament(nFil)->angles[nang]->energy();
      }
      
    }

    affineShearX(fileIt->first);
    _box->setShear(fileIt->first);
    compute(true,true,false);
    _box->setShear(0.0);
    
    // get affine data //
    
    for(int nFil=0; nFil<_filaments.size(); nFil++) {
      int nBonds = filament(nFil)->bonds.size();
      int nAngles = filament(nFil)->angles.size();
      for(int nbond=0; nbond<nBonds; nbond++) {
	VectorND bondPt;
	bondPt = 0.5*(filament(nFil)->nodes[nbond]->position() + filament(nFil)->nodes[nbond+1]->position());
	_box->mapPoint(bondPt);
	int xbox = (int)(bondPt[0]/bondGridSize[0]);
	int ybox = (int)(bondPt[1]/bondGridSize[1]);
	int indx = xbox*nBy + ybox;
	lastEtotsaffine[indx] += filament(nFil)->bonds[nbond]->energy();
	lastEtotaffine += filament(nFil)->bonds[nbond]->energy();
	if(compFils.find(nFil) != compFils.end()) {
	  lastEcompsaffine[indx] += filament(nFil)->bonds[nbond]->energy();
	  lastEcompaffine += filament(nFil)->bonds[nbond]->energy();
	}
      }
      for(int nang=0; nang<nAngles; nang++) {
	VectorND angPt;
	angPt = filament(nFil)->nodes[nang+1]->position();
	_box->mapPoint(angPt);
	int xbox = (int)(angPt[0]/bondGridSize[0]);
	int ybox = (int)(angPt[1]/bondGridSize[1]);
	int indx = xbox*nBy + ybox;
	lastEtotsaffine[indx] += filament(nFil)->angles[nang]->energy();
	lastEtotaffine += filament(nFil)->angles[nang]->energy();
      }
      
    }

    double lastShear = fileIt->first;
    fileIt++;
    updateNodalPoints(fileIt->second);
    _box->setShearX(fileIt->first);
    compute(true,true,false);
    _box->setShearX(0.0);
    for(int nFil=0; nFil<_filaments.size(); nFil++) {
      int nBonds = filament(nFil)->bonds.size();
      int nAngles = filament(nFil)->angles.size();
      for(int nbond=0; nbond<nBonds; nbond++) {
	VectorND bondPt;
	bondPt = 0.5*(filament(nFil)->nodes[nbond]->position() + filament(nFil)->nodes[nbond+1]->position());
	_box->mapPoint(bondPt);
	int xbox = (int)(bondPt[0]/bondGridSize[0]);
	int ybox = (int)(bondPt[1]/bondGridSize[1]);
	int indx = xbox*nBy + ybox;
	curEtots[indx] += filament(nFil)->bonds[nbond]->energy();
	curEtot += filament(nFil)->bonds[nbond]->energy();
	if(compFils.find(nFil) != compFils.end()) {
	  curEcomps[indx] += filament(nFil)->bonds[nbond]->energy();
	  curEcomp += filament(nFil)->bonds[nbond]->energy();
	}
      }
      for(int nang=0; nang<nAngles; nang++) {
	VectorND angPt;
	angPt = filament(nFil)->nodes[nang+1]->position();
	_box->mapPoint(angPt);
	int xbox = (int)(angPt[0]/bondGridSize[0]);
	int ybox = (int)(angPt[1]/bondGridSize[1]);
	int indx = xbox*nBy + ybox;
	curEtots[indx] += filament(nFil)->angles[nang]->energy();
	curEtot += filament(nFil)->angles[nang]->energy();
      }
    }
    
    std::vector<double> firstStepVals(nBoxes);
    for(int bx=0; bx<nBoxes; bx++) {
      double dEtot,dEcomp;
      dEtot = curEtots[bx] - lastEtots[bx];
      dEcomp = curEcomps[bx] - lastEcomps[bx];
      firstStepVals[bx] = dEcomp/dEtot;
      if(nElems[bx] == 0 || dEtot == 0.0 || nElemsCompressed[bx] == 0) firstStepVals[bx] = -1.1e6;
    }

    double dEtot = curEtot - lastEtot;
    double dEcomp = curEcomp - lastEcomp;

    double firstVal = dEcomp/dEtot;

    for(fileIt; fileIt!=strainedGelFiles.end(); fileIt++) {
      std::map<DefNode*,double> buckleOP;
      std::map<DefNode*,double> buckleOPnormalized;
      std::map<DefNode*,double> buckleOPnormalizedbyaffine;
      std::vector<double> buckleOPvals(nBoxes);
      std::vector<double> buckleOPvalsnormalized(nBoxes);
      std::vector<double> buckleOPvalsnormalizedbyaffine(nBoxes);
      updateNodalPoints(fileIt->second);
      _box->setShearX(fileIt->first);
      compute(true,true,false);
      _box->setShearX(0.0);
      for(int ii=0; ii<nBoxes; ii++) {
	curEtots[ii] = 0.0;
	curEcomps[ii] = 0.0;
	curEtot = 0.0;
	curEcomp = 0.0;

	curEtotsaffine[ii] = 0.0;
	curEcompsaffine[ii] = 0.0;
	curEtotaffine = 0.0;
	curEcompaffine = 0.0;
      }
      for(int nFil=0; nFil<_filaments.size(); nFil++) {
	int nBonds = filament(nFil)->bonds.size();
	int nAngles = filament(nFil)->angles.size();
	for(int nbond=0; nbond<nBonds; nbond++) {
	  VectorND bondPt;
	  bondPt = 0.5*(filament(nFil)->nodes[nbond]->position() + filament(nFil)->nodes[nbond+1]->position());
	  _box->mapPoint(bondPt);
	  int xbox = (int)(bondPt[0]/bondGridSize[0]);
	  int ybox = (int)(bondPt[1]/bondGridSize[1]);
	  int indx = xbox*nBy + ybox;
	  curEtots[indx] += filament(nFil)->bonds[nbond]->energy();
	  curEtot += filament(nFil)->bonds[nbond]->energy();
	  if(compFils.find(nFil) != compFils.end()) {
	    curEcomps[indx] += filament(nFil)->bonds[nbond]->energy();
	    curEcomp += filament(nFil)->bonds[nbond]->energy();
	  }
	}
	for(int nang=0; nang<nAngles; nang++) {
	  VectorND angPt;
	  angPt = filament(nFil)->nodes[nang+1]->position();
	  _box->mapPoint(angPt);
	  int xbox = (int)(angPt[0]/bondGridSize[0]);
	  int ybox = (int)(angPt[1]/bondGridSize[1]);
	  int indx = xbox*nBy + ybox;
	  curEtots[indx] += filament(nFil)->angles[nang]->energy();
	  curEtot += filament(nFil)->angles[nang]->energy();
	}
      }

      // now get affine data //

      affineShearX(fileIt->first);
      _box->setShear(fileIt->first);
      compute(true,true,false);
      _box->setShearX(0.0);

      for(int nFil=0; nFil<_filaments.size(); nFil++) {
	int nBonds = filament(nFil)->bonds.size();
	int nAngles = filament(nFil)->angles.size();
	for(int nbond=0; nbond<nBonds; nbond++) {
	  VectorND bondPt;
	  bondPt = 0.5*(filament(nFil)->nodes[nbond]->position() + filament(nFil)->nodes[nbond+1]->position());
	  _box->mapPoint(bondPt);
	  int xbox = (int)(bondPt[0]/bondGridSize[0]);
	  int ybox = (int)(bondPt[1]/bondGridSize[1]);
	  int indx = xbox*nBy + ybox;
	  curEtotsaffine[indx] += filament(nFil)->bonds[nbond]->energy();
	  curEtotaffine += filament(nFil)->bonds[nbond]->energy();
	  if(compFils.find(nFil) != compFils.end()) {
	    curEcompsaffine[indx] += filament(nFil)->bonds[nbond]->energy();
	    curEcompaffine += filament(nFil)->bonds[nbond]->energy();
	  }
	}
	for(int nang=0; nang<nAngles; nang++) {
	  VectorND angPt;
	  angPt = filament(nFil)->nodes[nang+1]->position();
	  _box->mapPoint(angPt);
	  int xbox = (int)(angPt[0]/bondGridSize[0]);
	  int ybox = (int)(angPt[1]/bondGridSize[1]);
	  int indx = xbox*nBy + ybox;
	  curEtotsaffine[indx] += filament(nFil)->angles[nang]->energy();
	  curEtotaffine += filament(nFil)->angles[nang]->energy();
	}
      }

      updateNodalPoints(fileIt->second);
      _box->setShearX(fileIt->first);
      compute(true,true,false);
      _box->setShearX(0.0);

      char tmpFNameList[256];
      sprintf(tmpFNameList,"buckleOPlist-shear=%f.dat",fileIt->first);
      std::string fNameList(tmpFNameList);
      fNameList.insert(0,buckDir);
      std::ofstream ofslist(fNameList.c_str());

      ofslist << "#x\t\ty\t\tbuck\t\tbuck_norm\t\tbuck_norm_aff\t\tbuck_comp_aff" << std::endl;

      // now normalize by first step //
      for(int bx=0; bx<nBoxes; bx++) {
	bool includePt = true;
	if(nElems[bx] <= 0) includePt = false;
	double dEtot,dEcomp;
	dEtot = curEtots[bx] - lastEtots[bx];
	dEcomp = curEcomps[bx] - lastEcomps[bx];
	double dat = dEcomp/dEtot;
	//if(nElems[bx] == 0 || dEtot == 0.0) dat = -1.1e6;
	if(std::isnan(dat) || !includePt) dat = -1.1e6;
	//if(dat != dat) dat = -1.1e6;
	buckleOPvals[bx] = dat;
	dat /= firstStepVals[bx];
	//if(firstStepVals[bx] < -1.0e6 || nElemsCompressed[bx] == 0 || dEtot == 0.0 || nElems[bx] == 0) dat = -1.1e6;
	if(std::isnan(dat) || !includePt) dat = -1.1e6;
	//if(dat != dat) dat = -1.1e6;
	if(firstStepVals[bx] < -1.0e6) dat = -1.1e6;
	buckleOPvalsnormalized[bx] = dat;

	dat = dEcomp/dEtot;
	double dEcompaffine,dEtotaffine;
	dEcompaffine = curEcompsaffine[bx] - lastEcompsaffine[bx];
	dEtotaffine = curEtotsaffine[bx] - lastEtotsaffine[bx];
	double dataffine = dEcompaffine/dEtotaffine;

	if(std::isnan(dat) || std::isnan(dataffine) || !includePt) dat = -1.1e6;
	else dat /= dataffine;

	if(std::isnan(dat) || !includePt) dat = -1.1e6;

	buckleOPvalsnormalizedbyaffine[bx] = dat;

	// create node, insert data //
	int xbox = bx/nBy;
	int ybox = bx%nBy;
	VectorND datPoint;
	datPoint[0] = bondGridSize[0]*(xbox+0.5);
	datPoint[1] = bondGridSize[1]*(ybox+0.5);
	
	NodeBase::DofIndexMap idx(N);
	for(int j=0; j<N; j++) idx[j] = bx*N + j;

	ofslist << datPoint[0] << "\t\t" << datPoint[1] << "\t\t" << buckleOPvals[bx] << "\t\t" << buckleOPvalsnormalized[bx] << "\t\t" << buckleOPvalsnormalizedbyaffine[bx];

	
	DefNode* datNode = new BrownianNode<2>(bx,idx,datPoint,datPoint);
	if(buckleOPvals[bx] >= -1.0e6) {
	  buckleOP.insert(pair<DefNode*,double>(datNode,buckleOPvals[bx]));
	}
	if(buckleOPvalsnormalized[bx] >= -1.0e6) {
	  buckleOPnormalized.insert(pair<DefNode*,double>(datNode,buckleOPvalsnormalized[bx]));
	}
	if(buckleOPvalsnormalizedbyaffine[bx] >= -1.0e6) {
	  buckleOPnormalizedbyaffine.insert(pair<DefNode*,double>(datNode,buckleOPvalsnormalizedbyaffine[bx]));
	}

	double datcompaffine = dEcomp/dEcompaffine;

	if(std::isnan(datcompaffine) || !includePt) datcompaffine = -1.1e6;

	ofslist << "\t\t" << datcompaffine << std::endl;
	
	
      }

      ofslist.close();


      // get overall gel value of OP //
      double dEtot = curEtot - lastEtot;
      double dEcomp = curEcomp - lastEcomp;
      double curVal = dEcomp/dEtot;
      double curOP = curVal/firstVal;
      double dEtotaffine = curEtotaffine - lastEtotaffine;
      double dEcompaffine = curEcompaffine - lastEcompaffine;
      double curValaffine = dEcompaffine/dEtotaffine;
      double curOPaff = curVal/curValaffine;

      std::cout << "dEtot affine = " << dEtotaffine << ", dEcomp affine = " << dEcompaffine << std::endl;

      std::ofstream overallFS(totOPFile.c_str(),ios_base::app);
      overallFS << fileIt->first << "\t\t" << curVal << "\t\t" << curOP << "\t\t" << curValaffine << "\t\t" << curOPaff << "\t\t" << dEcomp/dEcompaffine << std::endl;
      overallFS.close();

      // write out vtk //

      char tmpFName[256];
      sprintf(tmpFName,"buckleOPmap-shear=%f",fileIt->first);
      std::string fileName(tmpFName);
      std::string fName = fileName + ".vtk";
      fName.insert(0,buckDir);
      std::ofstream ofs(fName.c_str());


      if (!ofs) {
	std::cout << "Error: can not open paraview output file "
		  << fName
		  << std::endl;
	return;
      }
      
      tvmet::Vector<int,N> nBox;
      nBox[0] = nBx;
      nBox[1] = nBy;

      int nPts = 1;
      for(int n=0; n<N; n++) {
	nPts *= (nBox[n]+1);
      }
      
      ofs << "# vtk DataFile Version 2.0\n"
	  << "Test example" << std::endl
	  << "ASCII" << std::endl
	  << "DATASET POLYDATA" << std::endl
	  << "POINTS  " << nPts << "  double" << std::endl;
      
      if(N==2) {
	for(int p=0; p<=nBox[0]; p++) {
	  for(int q=0; q<=nBox[1]; q++) {
	    ofs << std::setprecision(16) 
		<< p*bondGridSize[0] << "  "
		<< 0.0 << "  "
		<< q*bondGridSize[1] << std::endl;

	  }
	}
	
	ofs << "POLYGONS  " << nBoxes << "  "
	    << 5*nBoxes << std::endl;
	
	for(int p=0; p<nBox[0]; p++) {
	  for(int q=0; q<nBox[1]; q++) {
	    int lowerCorner = p*(nBox[1]+1) + q;
	    ofs << 4 << "  "
		<< std::setw(10) << lowerCorner
		<< std::setw(10) << lowerCorner+1
		<< std::setw(10) << lowerCorner+nBox[1]+2
		<< std::setw(10) << lowerCorner+nBox[1]+1
		<< std::endl;
	  }
	}
	
	ofs << "CELL_DATA    " << nBoxes << std::endl;
	ofs << "SCALARS    buckleOP    double    1" << std::endl;
	ofs << "LOOKUP_TABLE default" << std::endl;
	for(int p=0; p<nBoxes; p++) {
	  ofs << buckleOPvals[p] << std::endl; 
	}	
	ofs << "SCALARS    buckleOPnorm    double    1" << std::endl;
	ofs << "LOOKUP_TABLE default" << std::endl;
	for(int p=0; p<nBoxes; p++) ofs << buckleOPvalsnormalized[p] << std::endl;

	ofs << "SCALARS    buckleOPnormbyaffine    double    1" << std::endl;
	ofs << "LOOKUP_TABLE default" << std::endl;
	for(int p=0; p<nBoxes; p++) ofs << buckleOPvalsnormalizedbyaffine[p] << std::endl;

	ofs << "SCALARS    numSegs    int    1" << std::endl;
	ofs << "LOOKUP_TABLE default" << std::endl;
	for(int p=0; p<nBoxes; p++) ofs << nElems[p] << std::endl; 

	ofs << "SCALARS    numSegsComp    int    1" << std::endl;
	ofs << "LOOKUP_TABLE default" << std::endl;
	for(int p=0; p<nBoxes; p++) ofs << nElemsCompressed[p] << std::endl;     
	
      }
      
      ofs.close();

      // write out location and buckleOP vals for each point //

      
    
      //       int nPts = 1;
      //       for(int n=0; n<N; n++) {
      // 	nPts *= (nBox[n]+1);
      //       }
      
      //       ofs << "# vtk DataFile Version 2.0\n"
      // 	  << "Test example" << std::endl
      // 	  << "ASCII" << std::endl
      // 	  << "DATASET POLYDATA" << std::endl
      // 	  << "POINTS  " << nPts << "  double" << std::endl;
      
      //       if(N==2) {
      // 	for(int p=0; p<=nBox[0]; p++) {
      // 	  for(int q=0; q<=nBox[1]; q++) {
      // 	    ofs << std::setprecision(16) 
      // 		<< p*bondGridSize[0] << "  "
      // 		<< 0.0 << "  "
      // 		<< q*bondGridSize[1] << std::endl;
      // 	  }
      // 	}
	
      // 	ofs << "POLYGONS  " << nBoxes << "  "
      // 	    << 5*nBoxes << std::endl;
	
      // 	for(int p=0; p<nBox[0]; p++) {
      // 	  for(int q=0; q<nBox[1]; q++) {
      // 	    int lowerCorner = p*(nBox[1]+1) + q;
      // 	    ofs << 4 << "  "
      // 		<< std::setw(10) << lowerCorner
      // 		<< std::setw(10) << lowerCorner+1
      // 		<< std::setw(10) << lowerCorner+nBox[1]+2
      // 		<< std::setw(10) << lowerCorner+nBox[1]+1
      // 		<< std::endl;
      // 	  }
      // 	}
	
      // 	ofs << "CELL_DATA    " << nBoxes << std::endl;
      // 	ofs << "SCALARS    buckleOP    double    1" << std::endl;
      // 	ofs << "LOOKUP_TABLE default" << std::endl;
      // 	for(int p=0; p<nBoxes; p++) ofs << buckleOPvals[p] << std::endl; 

      // 	ofs << std::endl;

      // 	ofs << "SCALARS    buckleOPnormalized    double    1" << std::endl;
      // 	ofs << "LOOKUP_TABLE default" << std::endl;
      // 	for(int p=0; p<nBoxes; p++) ofs << buckleOPvalsnormalized[p] << std::endl; 

	
      //       }
      
      //       ofs.close();

      if(doCorrs) {
	if(N==2) {
	  std::vector< pair<double,double> > corrData = computeCorrelationFunction(buckleOP,maxdim,min(_box->size()[0],_box->size()[1])/4.0,maxdim,maxdim/4.0);

	  std::vector< pair<double,double> > corrDataNorm = computeCorrelationFunction(buckleOPnormalized,maxdim,min(_box->size()[0],_box->size()[1])/4.0,maxdim,maxdim/4.0);

	  std::vector< pair<double,double> > corrDataNormAff = computeCorrelationFunction(buckleOPnormalizedbyaffine,maxdim,min(_box->size()[0],_box->size()[1])/4.0,maxdim,maxdim/4.0);
	  
	  char buckCorrFN[256];
	  sprintf(buckCorrFN,"buckleOPcorr-shear=%f.dat",fileIt->first);
	  std::string buckCorrFileString(buckCorrFN);
	  buckCorrFileString.insert(0,buckDir);
	  std::ofstream buckCorrFile(buckCorrFileString.c_str());
	  buckCorrFile << "#r\tcorr\tcorrnorm\n";
	  typename vector< pair<double,double> >::iterator pi2 = corrDataNorm.begin();
	  typename vector< pair<double,double> >::iterator pi3 = corrDataNormAff.begin();
	  for(typename vector< pair<double,double> >::iterator pi=corrData.begin(); pi!=corrData.end(); pi++) {
	    buckCorrFile << pi->first << "\t" << pi->second << "\t" << pi2->second << "\t" << pi3->second << "\n";
	    pi2++;
	    pi3++;
	  }
	  buckCorrFile.close();
	  
	  
	}
      }
      
    
      
      lastEtots = curEtots;
      lastEcomps = curEcomps;
      
      lastEtot = curEtot;
      lastEcomp = curEcomp;

      lastEtotsaffine = curEtotsaffine;
      lastEcompsaffine = curEcompsaffine;
      
      lastEtotaffine = curEtotaffine;
      lastEcompaffine = curEcompaffine;
      
      lastShear = fileIt->first;
    }
  }

  template<int N>
  void SemiflexibleGel<N>::cooperativeBuckleMeasure(double gridSize, double bendfrac, double lB, std::map<double,std::string> strainedGelFiles, bool doCorrs) {
    // get segments, order by expected buckling strain //

    std::set<Segment*,buckleComp> segments;

    int nFils = _filaments.size();
    for(int nf=0; nf<nFils; nf++) {
      Filament* f = filament(nf);
      int nNodes = f->nodes.size();
      std::vector<int> clinds;
      for(int nn=0; nn<nNodes; nn++) {
	DefNode* n = f->nodes[nn];
	if(_crossNodeMap.find(n) != _crossNodeMap.end()) {
	  clinds.push_back(nn);
	}
      }
      int nSegs = clinds.size()-1;
      for(int ns=0; ns<nSegs; ns++) {
	Segment* newSeg = new Segment();
	newSeg->filID = nf;
	newSeg->nodeID1 = clinds[ns];
	newSeg->nodeID2 = clinds[ns+1];
	newSeg->buckleStrain = -1.0;
	VectorND segPos,segPoint;
	segPos = .5*(f->nodes[newSeg->nodeID1]->position() + f->nodes[newSeg->nodeID2]->position());
	segPoint = .5*(f->nodes[newSeg->nodeID1]->point() + f->nodes[newSeg->nodeID2]->point());
	newSeg->pos = segPos;
	newSeg->pt = segPoint;

	// compute critical strain //

	VectorND e2e;
	e2e = f->nodes[newSeg->nodeID2]->position() - f->nodes[newSeg->nodeID1]->position();
	newSeg->length = norm2(e2e);
	double theta = atan2(e2e[1],e2e[0]);
	if(theta < 0.0) theta += M_PI;
	// check to see if this is a segment that should buckle...//
	if(theta > M_PI/2.0 && newSeg->nodeID2 != newSeg->nodeID1 + 1) {
	  newSeg->critStrain = sqr(M_PI*lB/norm2(e2e))/abs(cos(theta)*sin(theta));
	}
	else {
	  newSeg->critStrain = -sqr(M_PI*lB/norm2(e2e))/abs(cos(theta)*sin(theta));
	}
	segments.insert(newSeg);
      }
    }


    // we now have a list of segments ordered by expected buckling strain; now construct grid //
    Vector2D curGridSize;
    curGridSize[0] = gridSize;
    curGridSize[1] = gridSize;
    Grid<Segment,Segment,2> * grid = new Grid<Segment,Segment,2>(_box,curGridSize,&Segment::position,false);
    curGridSize = grid->gridSpace();

    typename std::set<Segment*,buckleComp>::iterator sit;
    for(sit=segments.begin(); sit!=segments.end(); sit++) {
      grid->addElem(*sit);
    }

    typename std::map< double,std::string >::iterator fileIt;
    double lastShear = 0.0;
    for(fileIt = strainedGelFiles.begin(); fileIt != strainedGelFiles.end(); fileIt++) {
      updateNodalPoints(fileIt->second);
      _box->setShearX(fileIt->first);
      compute(true,true,false);

      // now check to see which segments are newly buckled and change their buckleStrain fields //
      typename std::set<Segment*,buckleComp>::iterator segs = segments.begin();
      for(segs; segs!=segments.end(); segs++) {
	if((*segs)->buckleStrain < 0.0 && (*segs)->critStrain > 0.0) {
	  (*segs)->bendE = 0.0;
	  (*segs)->stretchE = 0.0;
	  for(int nodeNum=(*segs)->nodeID1; nodeNum<(*segs)->nodeID2; nodeNum++) {
	    double newStretchE = filament((*segs)->filID)->bonds[nodeNum]->energy();
	    (*segs)->stretchE += newStretchE;
	  }
	  for(int nodeNum=(*segs)->nodeID1; nodeNum<(*segs)->nodeID2-1; nodeNum++) {
	    double newBendE = filament((*segs)->filID)->angles[nodeNum]->energy();
	    (*segs)->bendE += newBendE;
	  }
	  if(((*segs)->bendE)/((*segs)->bendE + (*segs)->stretchE) > bendfrac) {
	    (*segs)->buckleStrain = .5*(lastShear+fileIt->first);
	  }
	}
      }
      lastShear = fileIt->first;
     
    }
    typename std::map< double,std::string >::reverse_iterator fileIt2 = strainedGelFiles.rbegin();
    double maxShear = fileIt2->first;
    
    // now that all shear files have been read in, compute measure

    std::cout << "Enter the name of a directory in which to store the vtk and correlation data files:\n";
    char dnm[256];
    std::cin >> dnm;
    std::string buckDir(dnm);
    if(buckDir.find("/")==string::npos) {
      buckDir += "/";
    }

    for(fileIt = strainedGelFiles.begin(); fileIt != strainedGelFiles.end(); fileIt++) {
      double curShear = fileIt->first;
      double dgamma = curShear - lastShear;
      int nBoxes = grid->nBoxes();
      double boxVol = grid->boxVol();
      map<DefNode*,double> dataLength;
      map<DefNode*,double> dataLengthFraction;
      map<DefNode*,double> dataNumber;
      map<DefNode*,double> dataNumberFraction;
      map<DefNode*,double> buckleOP;
      std::vector<int> nUnbuckled(nBoxes);
      std::vector<int> nTotal(nBoxes);
      std::vector<double> ldUnbuckled(nBoxes);
      std::vector<double> ldTotal(nBoxes);
      //std::vector<double> buckMeasures(nBoxes);
      for(int nb=0; nb<nBoxes; nb++) {
	int nTotalSegments = 0;
	int nUnbuckledSegments = 0;
	double ldUnbuck = 0.0;
	double ldTot = 0.0;
	std::set<Segment*> boxSegs = grid->getBoxElems(nb);
	std::vector<VectorND> boxCorners;
	boxCorners = grid->gridCorners(nb);
	VectorND cellCenter(0.0);
	int nCorners = boxCorners.size();
	for(int nc=0; nc<nCorners; nc++) {
	  cellCenter += (boxCorners[nc]/nCorners);
	}
	double buckMeasure = 0.0;
	typename std::set<Segment*>::iterator segi;
	int nSegsinBox = boxSegs.size();
	for(segi=boxSegs.begin(); segi!=boxSegs.end(); segi++) {
	  if((*segi)->critStrain > 0.0) {
	    nTotalSegments++;
	    ldTot += (*segi)->length;
	    // 	    if((*segi)->buckleStrain > 0.0) {
	    // 	      //buckMeasure += ((*segi)->critStrain-(*segi)->buckleStrain)/(*segi)->critStrain;
	    // 	    }
	    if(((*segi)->buckleStrain >= 0.0 && (*segi)->buckleStrain > curShear) || (*segi)->buckleStrain < 0.0) {
	      nUnbuckledSegments++;
	      ldUnbuck += (*segi)->length;
	    }
	    // 	    else {
	    // 	      nUnbuckledSegments++;
	    // 	      //buckMeasure += (critStrain-maxShear)/critStrain;
	    // 	    }
	  }
	}
	nUnbuckled[nb] = nUnbuckledSegments;
	nTotal[nb] = nTotalSegments;
	ldUnbuckled[nb] = ldUnbuck/boxVol;
	ldTotal[nb] = ldTot/boxVol;
 	if(nTotalSegments > 0) {
	  //buckMeasure /= nTotalSegments;
	  //buckMeasures[nb] = buckMeasure;
	  double numFracBuck = 1.0 - (((double)nUnbuckled[nb])/((double)nTotal[nb]));
	  NodeBase::DofIndexMap idx(N);
	  for(int j=0; j<N; j++) idx[j] = nb*N + j;
	  if(N==2) {
	    DefNode* newNode = new BrownianNode<2>(nb,idx,cellCenter,cellCenter);
	    //std::pair<double,double> dpr = pair<double,double>(compressedFD[k],buckledFD[k]);
	    dataLength.insert(std::pair<DefNode*,double>(newNode,ldTotal[nb]-ldUnbuckled[nb]));
	    dataLengthFraction.insert(std::pair<DefNode*,double>(newNode,1.0-(ldUnbuckled[nb]/ldTotal[nb])));
	    dataNumber.insert(std::pair<DefNode*,double>(newNode,(double)(nTotal[nb]-nUnbuckled[nb])));
	    dataNumberFraction.insert(std::pair<DefNode*,double>(newNode,numFracBuck));
	  }
	}
	//else buckMeasures[nb] = -1.0e10;
      }
      // now we have box measures and data; first make vtk map //

      double maxdim = 0.0;
      for(int dim=0; dim<N; dim++) {
	if(curGridSize[dim] > maxdim) maxdim = curGridSize[dim];
      }
      
      // now write vtk file with box data
      
      char tmpFName[256];
      sprintf(tmpFName,"bucklemap-shear=%f",curShear);
      std::string fileName(tmpFName);
      std::string fName = fileName + ".vtk";
      fName.insert(0,buckDir);
      std::ofstream ofs(fName.c_str());
      if (!ofs) {
	std::cout << "Error: can not open paraview output file "
		  << fName
		  << std::endl;
	return;
      }
      
      tvmet::Vector<int,N> nBox = grid->nBoxesDim();
      
      int nPts = 1;
      for(int n=0; n<N; n++) {
	nPts *= (nBox[n]+1);
      }
      
      ofs << "# vtk DataFile Version 2.0\n"
	  << "Test example" << std::endl
	  << "ASCII" << std::endl
	  << "DATASET POLYDATA" << std::endl
	  << "POINTS  " << nPts << "  double" << std::endl;
      
      if(N==2) {
	for(int p=0; p<=nBox[0]; p++) {
	  for(int q=0; q<=nBox[1]; q++) {
	    ofs << std::setprecision(16) 
		<< p*curGridSize[0] << "  "
		<< 0.0 << "  "
		<< q*curGridSize[1] << std::endl;
	  }
	}
	
	ofs << "POLYGONS  " << nBoxes << "  "
	    << 5*nBoxes << std::endl;
	
	for(int p=0; p<nBox[0]; p++) {
	  for(int q=0; q<nBox[1]; q++) {
	    int lowerCorner = p*(nBox[1]+1) + q;
	    ofs << 4 << "  "
		<< std::setw(10) << lowerCorner
		<< std::setw(10) << lowerCorner+1
		<< std::setw(10) << lowerCorner+nBox[1]+2
		<< std::setw(10) << lowerCorner+nBox[1]+1
		<< std::endl;
	  }
	}
	
	ofs << "CELL_DATA    " << nBoxes << std::endl;
	ofs << "SCALARS    nBucklableSegments    int    1" << std::endl;
	ofs << "LOOKUP_TABLE default" << std::endl;
	for(int p=0; p<nBoxes; p++) ofs << nTotal[p] << std::endl;
	
	ofs << std::endl;
	
	ofs << "SCALARS    nBuckledSegments    int    1" << std::endl;
	ofs << "LOOKUP_TABLE default" << std::endl;
	for(int p=0; p<nBoxes; p++) ofs << nTotal[p]-nUnbuckled[p] << std::endl;
	
	ofs << std::endl;
	
	ofs << "SCALARS    BucklableLengthDensity    double    1" << std::endl;
	ofs << "LOOKUP_TABLE default" << std::endl;
	for(int p=0; p<nBoxes; p++) ofs << ldTotal[p] << std::endl;    

	ofs << std::endl;
	
	ofs << "SCALARS    BuckledLengthDensity    double    1" << std::endl;
	ofs << "LOOKUP_TABLE default" << std::endl;
	for(int p=0; p<nBoxes; p++) ofs << ldTotal[p]-ldUnbuckled[p] << std::endl;  
	
      }
      
      ofs.close();

      if(doCorrs) {
	if(N==2) {
	  std::vector< pair<double,double> > corrData = computeCorrelationFunction(dataLength,maxdim,min(_box->size()[0],_box->size()[1])/4.0,maxdim,maxdim/4.0);
	  
	  std::cout << "Please input a file name in which to output the buckling strain correlation data: ";
	  char buckCorrFN[256];
	  std::cin >> buckCorrFN;
	  std::ofstream buckCorrFile(buckCorrFN);
	  buckCorrFile << "#r\tcorr\n";
	  //typename vector< pair<double,double> >::iterator pi2 = corrDataNormal.begin();
	  for(typename vector< pair<double,double> >::iterator pi=corrData.begin(); pi!=corrData.end(); pi++) {
	    buckCorrFile << pi->first << "\t" << pi->second << "\n";
	    //pi2++;
	  }
	  buckCorrFile.close();
	  
	  
	}
      }
      
    }
    
    //     double maxdim = 0.0;
    //     for(int dim=0; dim<N; dim++) {
    //       if(curGridSize[dim] > maxdim) maxdim = curGridSize[dim];
    //     }

    //     // now write vtk file with segment data

    //     std::cout << "Please enter a file name in which to store the map of buckled segments (leave out the vtk extension): ";
    //     char fNm[256];
    //     std::cin >> fNm;
    //     std::string fileName(fNm);

    //     std::string fName = fileName + ".vtk";
    //     std::ofstream ofs(fName.c_str());
    //     if (!ofs) {
    //       std::cout << "Error: can not open paraview output file "
    // 		<< fName
    // 		<< std::endl;
    //       return;
    //     }

    //     tvmet::Vector<int,N> nBox = grid->nBoxesDim();

    //     int nPts = 1;
    //     for(int n=0; n<N; n++) {
    //       nPts *= (nBox[n]+1);
    //     }
    
    //     ofs << "# vtk DataFile Version 2.0\n"
    // 	<< "Test example" << std::endl
    // 	<< "ASCII" << std::endl
    // 	<< "DATASET POLYDATA" << std::endl
    // 	<< "POINTS  " << nPts << "  double" << std::endl;
    
    //     if(N==2) {
    //       for(int p=0; p<=nBox[0]; p++) {
    // 	for(int q=0; q<=nBox[1]; q++) {
    // 	  ofs << std::setprecision(16) 
    // 	      << p*curGridSize[0] << "  "
    // 	      << 0.0 << "  "
    // 	      << q*curGridSize[1] << std::endl;
    // 	}
    //       }

    //       ofs << "POLYGONS  " << nBoxes << "  "
    // 	  << 5*nBoxes << std::endl;
      
    //       for(int p=0; p<nBox[0]; p++) {
    // 	for(int q=0; q<nBox[1]; q++) {
    // 	  int lowerCorner = p*(nBox[1]+1) + q;
    // 	  ofs << 4 << "  "
    // 	      << std::setw(10) << lowerCorner
    // 	      << std::setw(10) << lowerCorner+1
    // 	      << std::setw(10) << lowerCorner+nBox[1]+2
    // 	      << std::setw(10) << lowerCorner+nBox[1]+1
    // 	      << std::endl;
    // 	}
    //       }
      
    //       ofs << "CELL_DATA    " << nBoxes << std::endl;
    //       ofs << "SCALARS    buckMeasure    double    1" << std::endl;
    //       ofs << "LOOKUP_TABLE default" << std::endl;
    //       for(int p=0; p<nBoxes; p++) ofs << buckMeasures[p] << std::endl;

    //       ofs << std::endl;

    //       ofs << "SCALARS    nBucklableSegments    int    1" << std::endl;
    //       ofs << "LOOKUP_TABLE default" << std::endl;
    //       for(int p=0; p<nBoxes; p++) ofs << nTotal[p] << std::endl;

    //       ofs << std::endl;

    //       ofs << "SCALARS    nUnbuckledSegments    int    1" << std::endl;
    //       ofs << "LOOKUP_TABLE default" << std::endl;
    //       for(int p=0; p<nBoxes; p++) ofs << nUnbuckled[p] << std::endl;      
      
    //     }
    
    //     ofs.close();
 
    //     if(N==2) {
    //       std::vector< pair<double,double> > corrData = computeCorrelationFunction(data,maxdim,min(_box->size()[0],_box->size()[1])/3.0,maxdim,maxdim/4.0);
      
    //       std::cout << "Please input a file name in which to output the buckling strain correlation data: ";
    //       char buckCorrFN[256];
    //       std::cin >> buckCorrFN;
    //       std::ofstream buckCorrFile(buckCorrFN);
    //       buckCorrFile << "#r\tcorr\n";
    //       //typename vector< pair<double,double> >::iterator pi2 = corrDataNormal.begin();
    //       for(typename vector< pair<double,double> >::iterator pi=corrData.begin(); pi!=corrData.end(); pi++) {
    // 	buckCorrFile << pi->first << "\t" << pi->second << "\n";
    // 	//pi2++;
    //       }
    //       buckCorrFile.close();
      
      
    //     }
  }
  
  template<int N>
  std::vector< std::pair<double,double> > SemiflexibleGel<N>::computeNemCorrelations(double minSep, double step, double tol) {
    double maxSep = .25*(_box->size()[0] + _box->size()[1]);
    int nSteps = (int)((maxSep-minSep)/step) - 1;
    std::vector< std::pair<double,double> > corrData;
    
    VectorND curGridSize;
    for(int k=0; k<N; k++) curGridSize[k] = minSep;
    Grid<Filament,Filament,2> * grid = new Grid<Filament,Filament,2>(_box,curGridSize,&Filament::point,false);
    curGridSize = grid->gridSpace();

    double corrval = 1.0;
    //     for(typename map<DefNode*,double>::iterator mi=dataPts.begin(); mi!=dataPts.end(); mi++) {
    //       meanval += mi->second;
    //       corrval += sqr(mi->second);
    //       nodegrid->addElem(mi->first);
    //     }
    for(FilamentIterator fi=_filaments.begin(); fi!=_filaments.end(); fi++) {
      grid->addElem(*fi);
    }
    int nFils =_filaments.size();

    pair<double,double> corrPt = pair<double,double>(0.0,corrval);
    corrData.push_back(corrPt);
    
    for(int ns=0; ns<nSteps; ns++) {
      int nSamps = 0;
      corrval = 0.0;
      VectorND oldGridSize;
      oldGridSize = curGridSize;
      double curdist = minSep + ns*step;
      for(int k=0; k<N; k++) curGridSize[k] = curdist + tol;
      grid->resetGridSpace(curGridSize);
      curGridSize = grid->gridSpace();
      std::cout << "Current desired node separation = " << curdist << "; current grid size = (" << curGridSize[0] << ", " << curGridSize[1] << ")." << std::endl;
      assert(min(curGridSize[0],curGridSize[1]) >= curdist + tol);
      int nGridBoxes = grid->nBoxes();
      for(int nb=0; nb<nGridBoxes; nb++) {
	std::map< Filament*, std::set<Filament*> > pairs = grid->getNeighbors(nb);
	for(typename map< Filament*, set<Filament*> >::iterator pairit=pairs.begin(); pairit!=pairs.end(); pairit++) {
	  Filament* node1 = pairit->first;
	  for(typename set<Filament*>::iterator partit=pairit->second.begin(); partit!=pairit->second.end(); partit++) {
	    Filament* node2 = *partit;
	    if(node1<node2) {
	      VectorND sep;
	      sep = node1->point() - node2->point();
	      _box->mapDistance(sep);
	      if(fabs(norm2(sep)-curdist) < tol) {
		nSamps++;
		VectorND e2e1;
		e2e1 = node1->nodes[0]->point() - node1->nodes[node1->nodes.size()-1]->point();
		double len1 = norm2(e2e1);
		e2e1 /= len1;
		VectorND e2e2;
		e2e2 = node2->nodes[0]->point() - node2->nodes[node2->nodes.size()-1]->point();
		double len2 = norm2(e2e2);
		e2e2 /= len2;
		corrval += 2.0*sqr(dot(e2e1,e2e2)) - 1.0;
	      }
	    }
	  }
	}
      }
      if(nSamps > 0) {
	corrval /= nSamps;
	std::pair<double,double> curPair = pair<double,double>(curdist,corrval);
	corrData.push_back(curPair);
      }
    }
    
    delete grid;

    return corrData;
  }

  template<int N>
  std::vector< std::pair<double,double> > SemiflexibleGel<N>::computeCorrelationFunction(std::map<BrownianNode<N> *, double> & dataPts, double minSep, double maxSep, double step, double tol) {
    int nSteps = (int)((maxSep-minSep)/step);
    std::vector< std::pair<double,double> > corrData;
    
    VectorND curGridSize;
    for(int k=0; k<N; k++) curGridSize[k] = minSep;
    NodeGrid* nodegrid = new Grid<DefNode,BaseDefNode,2>();
    nodegrid->setBox(_box);
    nodegrid->setPosFunc(&DeformationNode<2>::position);
    nodegrid->setGridSpace(curGridSize);
    nodegrid->setComputeNeighbors(false);
    curGridSize = nodegrid->gridSpace();

    double meanval = 0.0;
    double corrval = 0.0;
    for(typename map<DefNode*,double>::iterator mi=dataPts.begin(); mi!=dataPts.end(); mi++) {
      meanval += mi->second;
      corrval += sqr(mi->second);
      nodegrid->addElem(mi->first);
    }
    meanval /= dataPts.size();
    corrval /= dataPts.size();
    corrval -= sqr(meanval);
    pair<double,double> corrPt = pair<double,double>(0.0,corrval);
    corrData.push_back(corrPt);
    
    for(int ns=0; ns<nSteps; ns++) {
      int nSamps = 0;
      corrval = 0.0;
      VectorND oldGridSize;
      oldGridSize = curGridSize;
      double curdist = minSep + ns*step;
      for(int k=0; k<N; k++) curGridSize[k] = curdist + tol;
      nodegrid->resetGridSpace(curGridSize);
      curGridSize = nodegrid->gridSpace();
      std::cout << "Current desired node separation = " << curdist << "; current grid size = (" << curGridSize[0] << ", " << curGridSize[1] << ")." << std::endl;
      assert(min(curGridSize[0],curGridSize[1]) >= curdist + tol);
      int nGridBoxes = nodegrid->nBoxes();
      for(int nb=0; nb<nGridBoxes; nb++) {
	std::map< DefNode*, std::set<DefNode*> > pairs = nodegrid->getNeighbors(nb);
	for(typename map< DefNode*, set<DefNode*> >::iterator pairit=pairs.begin(); pairit!=pairs.end(); pairit++) {
	  DefNode* node1 = pairit->first;
	  for(typename set<DefNode*>::iterator partit=pairit->second.begin(); partit!=pairit->second.end(); partit++) {
	    DefNode* node2 = *partit;
	    if(node1<node2) {
	      VectorND sep;
	      sep = node1->position() - node2->position();
	      _box->mapDistance(sep);
	      if(fabs(norm2(sep)-curdist) < tol) {
		nSamps++;
		corrval += (dataPts[node1]-meanval)*(dataPts[node2]-meanval);
	      }
	    }
	  }
	}
      }
      corrval /= nSamps;
      std::pair<double,double> curPair = pair<double,double>(curdist,corrval);
      corrData.push_back(curPair);
    }
    
    delete nodegrid;

    return corrData;
  }

  template<int N>
  std::vector< std::pair<double,double> > SemiflexibleGel<N>::computeCrossCorrelationFunction(std::map< BrownianNode<N> *, std::pair<double,double> > & dataPts, double minSep, double maxSep, double step, double tol) {
    int nSteps = (int)((maxSep-minSep)/step);
    std::vector< std::pair<double,double> > corrData;
    
    VectorND curGridSize;
    for(int k=0; k<N; k++) curGridSize[k] = minSep;
    NodeGrid* nodegrid = new Grid<DefNode,BaseDefNode,2>();
    nodegrid->setBox(_box);
    nodegrid->setPosFunc(&DeformationNode<2>::position);
    nodegrid->setGridSpace(curGridSize);
    nodegrid->setComputeNeighbors(false);
    curGridSize = nodegrid->gridSpace();

    double meanval1 = 0.0;
    double meanval2 = 0.0;
    double corrval = 0.0;
    for(typename map< DefNode*,pair<double,double> >::iterator mi=dataPts.begin(); mi!=dataPts.end(); mi++) {
      meanval1 += mi->second.first;
      meanval2 += mi->second.second;
      corrval += ((mi->second.first)*(mi->second.second));
      nodegrid->addElem(mi->first);
    }
    meanval1 /= dataPts.size();
    meanval2 /= dataPts.size();
    corrval /= dataPts.size();
    corrval -= (meanval1*meanval2);
    pair<double,double> corrPt = pair<double,double>(0.0,corrval);
    corrData.push_back(corrPt);
    
    for(int ns=0; ns<nSteps; ns++) {
      int nSamps = 0;
      corrval = 0.0;
      VectorND oldGridSize;
      oldGridSize = curGridSize;
      double curdist = minSep + ns*step;
      for(int k=0; k<N; k++) curGridSize[k] = curdist + tol;
      nodegrid->resetGridSpace(curGridSize);
      curGridSize = nodegrid->gridSpace();
      std::cout << "Current desired node separation = " << curdist << "; current grid size = (" << curGridSize[0] << ", " << curGridSize[1] << ")." << std::endl;
      assert(min(curGridSize[0],curGridSize[1]) >= curdist + tol);
      int nGridBoxes = nodegrid->nBoxes();
      for(int nb=0; nb<nGridBoxes; nb++) {
	std::map< DefNode*, std::set<DefNode*> > pairs = nodegrid->getNeighbors(nb);
	for(typename map< DefNode*, set<DefNode*> >::iterator pairit=pairs.begin(); pairit!=pairs.end(); pairit++) {
	  DefNode* node1 = pairit->first;
	  for(typename set<DefNode*>::iterator partit=pairit->second.begin(); partit!=pairit->second.end(); partit++) {
	    DefNode* node2 = *partit;
	    if(node1<node2) {
	      VectorND sep;
	      sep = node1->position() - node2->position();
	      _box->mapDistance(sep);
	      if(fabs(norm2(sep)-curdist) < tol) {
		nSamps++;
		corrval += (dataPts[node1].first-meanval1)*(dataPts[node2].second-meanval2);
	      }
	    }
	  }
	}
      }
      corrval /= nSamps;
      std::pair<double,double> curPair = pair<double,double>(curdist,corrval);
      corrData.push_back(curPair);
    }
    
    delete nodegrid;

    return corrData;
  }

  template<int N>
  double SemiflexibleGel<N>::computeCorrelation(std::vector<double> & dat1, std::vector<double> & dat2) {
    assert(dat1.size() == dat2.size());
    int nPts = dat1.size();
    double mn1 = 0.0;
    double mn2 = 0.0;
    double std1 = 0.0;
    double std2 = 0.0;
    double corr = 0.0;

    for(int i=0; i<nPts; i++) {
      mn1 += dat1[i];
      mn2 += dat2[i];
      std1 += sqr(dat1[i]);
      std2 += sqr(dat2[i]);
      corr += dat1[i]*dat2[i];
    }

    mn1 /= nPts;
    mn2 /= nPts;
    std1 /= nPts;
    std2 /= nPts;
    std1 -= sqr(mn1);
    std2 -= sqr(mn2);
    std1 *= nPts/(nPts-1.0);
    std2 *= nPts/(nPts-1.0);
    std1 = sqrt(std1);
    std2 = sqrt(std2);
    corr /= nPts;
    corr -= mn1*mn2;
    corr /= (std1*std2);
    corr *= nPts/(nPts-1.0);

    return corr;
  }

  template<int N>
  void SemiflexibleGel<N>::computeCrossCorrelations(double len, double shear, std::string & fileName) {
    std::vector<double> nonaffinities;

    VectorND boxsize;
    for(int i=0; i<N; i++) boxsize[i] = len;

    std::cout << "Enter the maximum filament length from which to take nodes for the affinity measure: ";
    double maxFL;
    std::cin >> maxFL;

    std::cout << "Enter a pair distance to use for computing nonaffinity: ";
    double pairDist;
    std::cin >> pairDist;
    assert(pairDist < len);
    assert(pairDist > 0.0);
    
    DefNodeContainer nodes4triangulation;
    for(FilamentIterator fi=_filaments.begin(); fi!=_filaments.end(); fi++) {
      bool itNodes = true;
      if(maxFL > 0.0) {
	int nNds = (*fi)->nodes.size();
	VectorND e2e;
	e2e = (*fi)->nodes[nNds-1]->position() - (*fi)->nodes[0]->position();
	if(norm2(e2e) > maxFL) itNodes = false;
      } 
      if(itNodes) {
	for(DefNodeIterator dni=(*fi)->nodes.begin(); dni!=(*fi)->nodes.end(); dni++) {
	  // 	if(isMaster(*dni)) {
	  // 	  Vector2D tmpPos;
	  // 	  Vector2D tmpDef;
	  // 	  tmpPos = (*dni)->position();
	  // 	  tmpDef = (*dni)->point() - (*dni)->position();
	  // 	  _box->mapPoint(tmpPos);
	  // 	  tmpDef += tmpPos;
	  // 	  DefNode* newNode = new BrownianNode<2>((*dni)->id(),(*dni)->index(),tmpPos,tmpDef);
	  // 	  newNode->setId((*dni)->id());
	  // 	  nodes4triangulation.push_back(newNode);
	  // 	}
	  if(!isSlave(*dni)) {
	    // 	  Vector2D tmpPos;
	    // 	  Vector2D tmpDef;
	    //  	  tmpPos = (*dni)->position() - minPos;
	    //  	  tmpDef = (*dni)->point() - minPos;
	    // 	  //tmpPos = (*dni)->position();
	    // 	  //_box->setShear(0.0);
	    // 	  //_box->mapPoint(tmpPos);
	    // 	  //tmpDef = (*dni)->point() - tmpPos;
	    // 	  //_box->setShear(shear);
	    // 	  //_box->mapDistance(tmpDef);
	    // 	  //tmpDef += tmpPos;
	    // 	  DefNode* newNode = new BrownianNode<2>((*dni)->id(),(*dni)->index(),tmpPos,tmpDef);
	    // 	  newNode->setId((*dni)->id());
	    nodes4triangulation.push_back(*dni);
	  }
	}
      }
    }

    NodeGrid* nodegrid = new Grid<DefNode,BaseDefNode,2>();
    nodegrid->setBox(_box);
    nodegrid->setPosFunc(&DeformationNode<2>::position);
    nodegrid->setGridSpace(boxsize);
    nodegrid->setComputeNeighbors(false);
    nodegrid->addElems(nodes4triangulation);

    boxsize = nodegrid->gridSpace();
    
    int nBoxes = nodegrid->nBoxes();
    for(int k=0; k<nBoxes; k++) {
      double nSamps = 0.0;
      nonaffinities.push_back(0.0);
      //std::map< DefNode*, std::set< DefNode * > > nodePairs = nodegrid->getNeighbors(k);
      std::set< DefNode * > & boxNodes = nodegrid->getBoxElems(k);
      DefNodeContainer neighbNodes = nodegrid->getBoxNeighbors(k);
      for(typename std::set< DefNode * >::iterator bn=boxNodes.begin(); bn!=boxNodes.end(); bn++) {
	//for(int nd1=0; nd1<nBoxNodes; nd1++) {
	//for(typename std::map< DefNode *, std::set< DefNode * > >::iterator npiter=nodePairs.begin(); npiter!=nodePairs.end(); npiter++) {
	//DefNode * node1 = npiter->first;
	DefNode * node1 = *bn;
	for(typename std::set< DefNode * >::iterator bn2=bn; bn2!=boxNodes.end(); bn2++) {
	  if(bn2 != bn) {
	    DefNode * node2 = *bn2;
	    VectorND diff;
	    diff = node1->position() - node2->position();
	    if(fabs(norm2(diff)-pairDist)/pairDist < 1.0e-2) {
	      nSamps += 1.0;
	      double thetaAff = atan2(diff[1],diff[0]+(shear*diff[1]));
	      VectorND finaldiff;
	      finaldiff = node1->point() - node2->point();
	      double thetaActual = atan2(finaldiff[1],finaldiff[0]);
	      double dTheta = fabs(thetaActual-thetaAff) < M_PI ? thetaActual-thetaAff : 2.0*M_PI-fabs(thetaActual-thetaAff);
	      dTheta = sqr(dTheta);
	      nonaffinities[k] += dTheta;
	    }
	    else {
	      _box->setShear(0.0);
	      _box->mapDistance(diff);
	      if(fabs(norm2(diff)-pairDist)/pairDist < 1.0e-2) {
		nSamps += 1.0;
		double thetaAff = atan2(diff[1],diff[0]+(shear*diff[1]));
		VectorND finaldiff;
		finaldiff = node1->point() - node2->point();
		_box->setShear(shear);
		_box->mapDistance(finaldiff);
		double thetaActual = atan2(finaldiff[1],finaldiff[0]);
		double dTheta = fabs(thetaActual-thetaAff) < M_PI ? thetaActual-thetaAff : 2.0*M_PI-fabs(thetaActual-thetaAff);
		dTheta = sqr(dTheta);
		nonaffinities[k] += dTheta;
		_box->setShear(0.0);
	      }
	    }
	  }
	}
	int nNeighbNodes = neighbNodes.size();
	for(int nd2=0; nd2<nNeighbNodes; nd2++) {
	  //for(typename std::set< DefNode * >::iterator partiter=npiter->second.begin(); partiter!=npiter->second.end(); partiter++) {
	  //DefNode * node2 = *partiter;
	  DefNode * node2 = neighbNodes[nd2];
	  VectorND diff;
	  diff = node1->position() - node2->position();
	  if(fabs(norm2(diff)-pairDist)/pairDist < 1.0e-2) {
	    nSamps += 0.5;
	    double thetaAff = atan2(diff[1],diff[0]+(shear*diff[1]));
	    VectorND finaldiff;
	    finaldiff = node1->point() - node2->point();
	    double thetaActual = atan2(finaldiff[1],finaldiff[0]);
	    double dTheta = fabs(thetaActual-thetaAff) < M_PI ? thetaActual-thetaAff : 2.0*M_PI-fabs(thetaActual-thetaAff);
	    dTheta = sqr(dTheta);
	    nonaffinities[k] += 0.5*dTheta;
	  }
	  else {
	    _box->setShear(0.0);
	    _box->mapDistance(diff);
	    if(fabs(norm2(diff)-pairDist)/pairDist < 1.0e-2) {
	      nSamps += 0.5;
	      double thetaAff = atan2(diff[1],diff[0]+(shear*diff[1]));
	      VectorND finaldiff;
	      finaldiff = node1->point() - node2->point();
	      _box->setShear(shear);
	      _box->mapDistance(finaldiff);
	      double thetaActual = atan2(finaldiff[1],finaldiff[0]);
	      double dTheta = fabs(thetaActual-thetaAff) < M_PI ? thetaActual-thetaAff : 2.0*M_PI-fabs(thetaActual-thetaAff);
	      dTheta = sqr(dTheta);
	      nonaffinities[k] += 0.5*dTheta;  
	      _box->setShear(0.0);
	    }
	  }
	  
	}
      }
      
      if(nSamps > 0.0) {
	nonaffinities[k] /= nSamps;
	nonaffinities[k] /= sqr(shear);
      }
      else nonaffinities[k] = 0.0;
    }


    tvmet::Vector<int,N> nCells;
    nCells = nodegrid->nBoxesDim();
    
    tvmet::Vector<int,N> mults;
    int curMult = nBoxes;
    for(int i=0; i<N; i++) {
      curMult /= nCells[i];
      mults[i] = curMult;
    }


    std::vector<double> energies(nBoxes,0.0);
    std::vector<double> bendenergies(nBoxes,0.0);
    std::vector<double> stretchenergies(nBoxes,0.0);
    std::vector<double> lengthdensity(nBoxes,0.0);
    std::vector<double> longfillengthdensity(nBoxes,0.0);    
    for(FilamentIterator f=_filaments.begin(); f!=_filaments.end(); f++) {
      int nNodes = (*f)->nodes.size();
      bool isLong = false;
      VectorND fe2e;
      fe2e = (*f)->nodes[nNodes-1]->position() - (*f)->nodes[0]->position();
      double fillen = norm2(fe2e);
      if(fillen > maxFL) isLong = true;
      for(int b=0; b<nNodes-1; b++) {
	VectorND com;
	com = .5*((*f)->nodes[b]->position() + (*f)->nodes[b+1]->position());
	_box->mapPoint(com);
	tvmet::Vector<int,N> coords;
	int idx = 0;
	for(int i=0; i<N; i++) {
	  coords[i] = (int)(com[i]/boxsize[i]);
	  coords[i] = coords[i]%nCells[i];
	  idx += mults[i]*coords[i];
	}
	// 	std::cout << "Troubleshoot: coords = (" 
	// 		  << coords[0] << ", " << coords[1] << "); index = " 
	// 		  << idx << "; grid dimensions = ("
	// 		  << nCells[0] << ", " << nCells[1] << ")."
	// 		  << std::endl;
	assert(idx < nBoxes);
	assert(idx >= 0);
	energies[idx] += (*f)->bonds[b]->energy();
	stretchenergies[idx] += (*f)->bonds[b]->energy();
	VectorND e2e;
	e2e = (*f)->nodes[b]->position() - (*f)->nodes[b+1]->position();
	double len = norm2(e2e);
	lengthdensity[idx] += len;
	if(isLong) longfillengthdensity[idx] += len;
      }
      for(int a=1; a<nNodes-1; a++) {
	VectorND com;
	com = (*f)->nodes[a]->position();
	_box->mapPoint(com);
	tvmet::Vector<int,N> coords;
	int idx = 0;
	for(int i=0; i<N; i++) {
	  coords[i] = (int)(com[i]/boxsize[i]);
	  coords[i] = coords[i]%nCells[i];
	  idx += mults[i]*coords[i];
	}
	assert(idx < nBoxes);
	assert(idx >= 0);
	energies[idx] += (*f)->angles[a-1]->energy();
	bendenergies[idx] += (*f)->angles[a-1]->energy();
      }
    }
    
    double boxVol = 1.0;
    for(int nd=0; nd<N; nd++) boxVol *= boxsize[nd];
    for(int ni=0; ni<nBoxes; ni++) {
      lengthdensity[ni] /= boxVol;
      longfillengthdensity[ni] /= boxVol;
    }
    
    double endenscorr = computeCorrelation(energies,lengthdensity);
    double bendendenscorr = computeCorrelation(bendenergies,lengthdensity);
    double stretchendenscorr = computeCorrelation(stretchenergies,lengthdensity);
    double affdenscorr = computeCorrelation(nonaffinities,lengthdensity);
    double affldenscorr = computeCorrelation(nonaffinities,longfillengthdensity);
    double affbendencorr = computeCorrelation(nonaffinities,bendenergies);
    
    std::ofstream corrFile(fileName.c_str());

    corrFile << "#Box Size = (" << boxsize[0] << ", " << boxsize[1] << ")" << std::endl 
	     << "#Pair Separation = " << pairDist << std::endl << std::endl;

    corrFile << "#Energy-Length Density\n" << endenscorr << std::endl << std::endl
	     << "#Bending Energy-Length Density\n" << bendendenscorr << std::endl << std::endl
	     << "#Stretcing Energy-Length Density\n" << stretchendenscorr << std::endl << std::endl
	     << "#Nonaffinity-Length Density\n" << affdenscorr << std::endl << std::endl
	     << "#Nonaffinity-Long Filament Length Density\n" << affldenscorr << std::endl << std::endl
	     << "#Nonaffinity-Bending Energy\n" << affbendencorr << std::endl;
    
    corrFile.close();
    
    delete nodegrid;
    
  }

  template<int N>
  void SemiflexibleGel<N>::checkParallelForces() {
    for(FilamentIterator f=_filaments.begin(); f!=_filaments.end(); f++) {
      DefNode* n1 = (*f)->nodes[0];
      DefNode* n2 = (*f)->nodes[(*f)->nodes.size()-1];
      const VectorND & p1 = n1->point();
      const VectorND & p2 = n2->point();
      const VectorND & force1 = n1->force();
      const VectorND & force2 = n2->force();
      VectorND diff;
      diff = p2 - p1;
      double f1parallel = dot(diff,force1);
      double f2parallel = dot(diff,force2);
      if(abs(f1parallel-f2parallel)/(abs(f1parallel)+abs(f2parallel)) > 1.0e-6) {
	std::cerr << "Error: parallel forces on rod ends are unequal." << std::endl
		  << "F_par on end 1 = " << f1parallel << std::endl
		  << "F_par on end 2 = " << f2parallel << std::endl << std::endl;
      }
    }
  }

  template<int N>
  void SemiflexibleGel<N>::printCLFilDist() {
    std::map<int,int> CLFilDist;
    typename std::map<DefNode*,int>::iterator cli = _nSlavesMap.begin();
    for(cli; cli!=_nSlavesMap.end(); cli++) {
      int nFilsCL = cli->second + 1;
      if(CLFilDist.find(nFilsCL) == CLFilDist.end()) CLFilDist.insert(pair<int,int>(nFilsCL,1));
      else CLFilDist[nFilsCL]++;
    }
    std::cout << std::endl << "Printing out distribution of # of filaments in crosslinks." << std::endl << std::endl;
    std::cout << "# of fils\t# of cls" << std::endl;
    for(typename map<int,int>::iterator clfdi = CLFilDist.begin(); clfdi!=CLFilDist.end(); clfdi++) {
      std::cout << clfdi->first << "\t" << clfdi->second << std::endl;
    }
    std::cout << std::endl;
  }

  template<int N>
  void SemiflexibleGel<N>::printInitialBends() {
    double meanAng = 0.0;
    double stdd = 0.0;
    int nAngs = 0;
    std::multiset<double> angs;
    double mina = M_PI;
    double maxa = -M_PI;
    for(FilamentIterator fi=_filaments.begin(); fi!=_filaments.end(); fi++) {
      for(AngleIterator ai=(*fi)->angles.begin(); ai!=(*fi)->angles.end(); ai++) {
        double angABC = (*ai)->getAngleABC();
	meanAng += angABC;
	stdd += sqr(angABC);
	nAngs++;
	angs.insert(angABC);
	if(angABC < mina) mina = angABC;
	if(angABC > maxa) maxa = angABC;
      }
    }
    meanAng /= nAngs;
    stdd /= nAngs;
    stdd -= sqr(meanAng);
    stdd = sqrt(stdd);

    double binwidth = 3.49*stdd/pow(nAngs,1.0/3.0);
    int nBins = (int)(floor((maxa-mina)/binwidth)+.5);
    binwidth = (maxa-mina)/nBins;
    double minVal = mina;
    std::cout << "Printing distribution of initial bending angles." << std::endl << std::endl;
    std::cout << "theta\t#angles" << std::endl;
    for(int i=0; i<nBins; i++) {
      multiset<double>::iterator lenItHigh;
      double curHigh = minVal + (i+1.0)*binwidth;
      lenItHigh = angs.lower_bound(curHigh);
      int numPts = angs.size();
      angs.erase(angs.begin(),lenItHigh);
      std::cout << curHigh - 0.5*binwidth << "\t" << numPts-angs.size() << std::endl;
    }
  }

  template<int N>
  void SemiflexibleGel<N>::printBigBends() {
    int nLargeAngles = 0;
    double crit = M_PI/2.0;
    for(FilamentIterator fi=_filaments.begin(); fi!=_filaments.end(); fi++) {
      for(AngleIterator ai=(*fi)->angles.begin(); ai!=(*fi)->angles.end(); ai++) {
        double angABC = (*ai)->getAngleABC();
	if(abs(angABC) > crit) nLargeAngles++;
      }
    }
    std::cout << nLargeAngles << " angles greater than " << crit << " in gel." << std::endl;
  }

  template<int N>
  double SemiflexibleGel<N>::computeBucklingEnergy(double shear, double kap, double mu) {
    int nFils = _filaments.size();
    double en2return = 0.0;
    double lB = sqrt(kap/mu);
    double crit = sqr(M_PI)*sqr(lB)/shear;
    for(int i=0; i<nFils; i++) {
      Filament* f = filament(i);
      int nNodes = f->nodes.size();
      VectorND e2e;
      e2e = f->nodes[0]->position() - f->nodes[nNodes-1]->position();
      double ang = atan2(e2e[1],e2e[0]);
      double cossin = cos(ang)*sin(ang);
      double curLen = 0.0;
      for(int j=0; j<nNodes-1; j++) { 
	if(_crossNodeMap.find(f->nodes[j+1]) != _crossNodeMap.end()) {
	  curLen += f->bonds[j]->getLength();
	  if(cossin < 0.0) {
	    if(sqr(curLen)*fabs(cossin) > crit) {
	      double benden = 12.0*kap*shear*fabs(cossin)/curLen;
	      en2return += benden;
	    }
	    else en2return += mu*sqr(shear)*curLen*sqr(cossin)/2.0;
	  }
	  else{
	    en2return += mu*sqr(shear)*curLen*sqr(cossin)/2.0;
	  }
	  curLen = 0.0;
	}
	else curLen += f->bonds[j]->getLength();
      }
    }
    
    return en2return;
  }
};
