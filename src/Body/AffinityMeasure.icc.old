// -*- C++ -*-
//----------------------------------------------------------------------
//
//                          Mo Bai
//                University of California Los Angeles
//                   (C) 2009 All Rights Reserved
//
//----------------------------------------------------------------------

//#include "AffinityMeasure.h"

namespace voom
{

  AffinityMeasure::AffinityMeasure(NodeContainer & nodes){
    _nodes = nodes;
    _nNodes = nodes.size();
    _strains.clear();
    _centroids.clear();
    _nElements = 0;
  }

  int AffinityMeasure::triangulate(){
    vtkPoints *newPts = vtkPoints::New();
   
    for (int i=0;i<_nNodes;i++){
      const Vector2D & x = _nodes[i]->position();
      newPts->InsertNextPoint(  x(0),  x(1), 0.0 );
    }

    vtkIdType inNumPts = newPts->GetNumberOfPoints();
    cout << "input numPts= " << inNumPts << endl;

    vtkPolyData *pointCloud = vtkPolyData::New();
    pointCloud->SetPoints(newPts);
    newPts->Delete();

    vtkDelaunay2D *delaunay2D = vtkDelaunay2D::New();
    delaunay2D->SetInput( pointCloud );
    pointCloud->Delete();
    delaunay2D->Update();

    vtkPolyData *triangulation = delaunay2D->GetOutput();

    vtkPolyDataWriter *writer = vtkPolyDataWriter::New();
    writer->SetInput( triangulation );
    writer->SetFileName( "mesh.vtk" ); 
    writer->SetFileTypeToASCII();
    writer->Write();

    vtkIdType outNumPts = triangulation->GetNumberOfPoints();
    vtkIdType outNumCells = triangulation->GetNumberOfCells();
    vtkIdType outNumPolys = triangulation->GetNumberOfPolys();
    vtkIdType outNumLines = triangulation->GetNumberOfLines();
    vtkIdType outNumVerts = triangulation->GetNumberOfVerts();

    cout << "output numPts= " << outNumPts << endl;
    cout << "output numCells= " << outNumCells << endl;
    cout << "output numPolys= " << outNumPolys << endl;
    cout << "output numLines= " << outNumLines << endl;
    cout << "output numVerts= " << outNumVerts << endl;

    if( outNumPts != inNumPts )
      {
	cout << "ERROR: output numPts " << outNumPts
	     << " doesn't match input numPts=" << inNumPts << endl;
	delaunay2D->Delete();
	return EXIT_FAILURE;
      }

    if( !outNumCells )
      {
	cout << "ERROR: output numCells= " << outNumCells << endl;
	delaunay2D->Delete();
	return EXIT_FAILURE;
      }

    if( outNumPolys != outNumCells )
      {
	cout << "ERROR: output numPolys= " << outNumPolys
	     << " doesn't match output numCells= " << outNumCells << endl;
	delaunay2D->Delete();
	return EXIT_FAILURE;
      }

    if( outNumLines )
      {
	cout << "ERROR: output numLines= " << outNumLines << endl;
	delaunay2D->Delete();
	return EXIT_FAILURE;
      }

    if( outNumVerts )
      {
	cout << "ERROR: output numVerts= " << outNumVerts << endl;
	delaunay2D->Delete();
	return EXIT_FAILURE;
      }

    // check that every point is connected
    triangulation->BuildLinks();

    vtkIdList *cellIds = vtkIdList::New();
    vtkIdType numUnconnectedPts = 0;

    for(vtkIdType ptId=0; ptId<outNumPts; ptId++)
      {
	triangulation->GetPointCells(ptId,cellIds);
	if( !cellIds->GetNumberOfIds() )
	  {
	    numUnconnectedPts++;
	  }
      }

    cellIds->Delete();

    cout << "Triangulation has " << numUnconnectedPts
	 << " unconnected points" << endl;

    if( numUnconnectedPts )
      {
	cout << "ERROR: Triangulation has " << numUnconnectedPts
	     << " unconnected points" << endl;
	delaunay2D->Delete();
	return EXIT_FAILURE;
      }

    tvmet::Vector<double, 2> coords;
    coords = 0.3 , 0.3; //can be any values, because they don't change the strain tensor
    ShapeTri3 s(coords);
    _nElements = triangulation->GetNumberOfCells();
    int nodes_per_element = 3; //triangle
    _strains.clear();
    _centroids.clear();

    for(int e=0; e<_nElements; e++) {
      NodeContainer elementnodes;
      elementnodes.clear();
      Vector2D centroid(0.0);

      for(int a=0; a<nodes_per_element; a++) {
	int A = triangulation->GetCell(e)->GetPointId(a);
	elementnodes.push_back(_nodes[A]);
	centroid += _nodes[A]->point();
      }
      centroid = centroid/nodes_per_element;
      _centroids.push_back(centroid);

      AffinityElement * element = new AffinityElement(s,elementnodes);
      Tensor2D strain(0.0);
      strain = element->Strain();
      _strains.push_back(strain);

      delete element;
    }
    
    return 0;
  }

} // namespace voom
