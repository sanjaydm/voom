// -*- C++ -*-
//----------------------------------------------------------------------
//
//                      William S. Klug, Feng Feng
//                University of California Los Angeles
//                   (C) 2004 All Rights Reserved
//
//----------------------------------------------------------------------

////////////////////////////////////////////////////////////////////
// LAPACK subroutine for computing eigenvalues and eigenvectors
//
// define prototype of LAPACK functions
extern "C" void dsyev_(char *jobz, char *uplo, int *n, double *a, int *lda,
		       double *w, double *work, int *lwork, int *info);

//#define _DEBUG_

namespace voom
{

  template<class Quadrature_t, class Material_t, class Shape_t>
  void C0Membrane<Quadrature_t, Material_t, Shape_t>::compute(bool f0, bool f1, bool f2)
  {
    //
    // initialize things
    //
    // if applied volume constraint, _volume is needed for computing
    // if applied area constraint, _area is needed for computing
    // both energy and forces
    _volume = 0.0;
    _area = 0.0;
    // _trC = 0.0;

   
		
    if( f0 ) {
      _energy = 0.0;
      _strainEnergy = 0.0;
      _work = 0.0;
    }

    if( f1 ) {
      Vector3D zero(0);
      _internalForce = zero;
      _pressureForce = zero;
      _tensionForce = zero;
    }
		
    // loop for every quadrature point
    for(QuadPointIterator p=_quadPoints.begin(); 
	p!=_quadPoints.end(); p++){
      //
      // compute Shell geometry
      //
			
      // compute position, basis vector, and derivatives of basis vector
      Vector3D x(0.0);
      tvmet::Vector< Vector3D, 2 > a;
      tvmet::Matrix< Vector3D, 2, 2 > aPartials;
      Vector3D zero(0);
      a = zero, zero;
      aPartials = zero, zero, zero, zero;

      const typename Shape_t::FunctionContainer & N 
	= p->shape.functions();
      const typename Shape_t::DerivativeContainer & DN 
	= p->shape.derivatives();

      for (int b = 0; b < _nodes.size(); b++){
	const DeformationNode<3>::Point & xb = _nodes[b]->point();
	x 	       +=   N[b]     * xb;
	a(0)           +=  DN[b](0)   * xb;
	a(1)           +=  DN[b](1)   * xb;
      }
	
      //std::cout<<_nodes[0]->point()<<std::endl;		
      Material_t& material = p->material;
      // compute shell geometry
      ShellGeometry geometry( a, aPartials );
      const Vector3D& d = geometry.d();
      const tvmet::Vector< Vector3D, 2 >& aDual = geometry.aDual();
			
      // store the deformed geometry in shell geometry class
      material.setGeometry(geometry);

      // compute strain energy, stress and moment resultants
      material.updateState(f0, f1, f2); 
			
      //0.5 is not needed
      const double metric = /*0.5 */ geometry.metric();
      const double refMetric = /*0.5 */( material.refShellGeometry()).metric();
      const double jacobian = metric/refMetric;
      const double weight =  metric * p->weight;

      // compute area for the area constaint energy
      _area += weight;

      // compute volume for the volume constraint energy
      _volume +=  dot(d,x) * weight / 3.0;
      
      // compute energy
      if ( f0 ){

	// compute strain energy 
	_strainEnergy += material.energyDensity() * weight;
              
      }

      // compute forces
      if ( f1 ) {
	//
	// get stress and moment resultants
	const tvmet::Vector< Vector3D, 3 >& sr = material.stressResultants();

	double pressure = (_pressureNode==0) ? 0.0 : _pressureNode->point();

	double tension = (_tensionNode==0) ? 0.0 : _tensionNode->point();

	// loop for all nodes to compute forces 
	for (int a=0; a<_nodes.size(); a++) {

	  // compute internal forces

	  // calculate the gradient of the derivatives of the director
	  // w.r.t curvilinear coords
	  for ( int alpha = 0; alpha < 2; alpha++){
	    // Stress Resultant part
	    Vector3D ftmp;
	    ftmp = sr(alpha) *  DN[a](alpha) * weight;
 	    _internalForce(a)  += ftmp;
	  } 

	  // compute pressure/volume constraint forces 
// 	  _pressureForce(a) -= pressure * d * N(a) * weight;
	  _pressureForce(a) -= 
	    pressure*( d * N[a] 
		       + dot(x,d)*( aDual[0]*DN[a](0)+
				    aDual[1]*DN[a](1) )
		       - ( dot(x,aDual[0])*DN[a](0) + 
			   dot(x,aDual[1])*DN[a](1)  )*d
		       )*weight/3.0;

          // global area constraint
	  _tensionForce(a) += 
	    tension * (DN[a](0) * aDual[0] + DN[a][1] * aDual[1]) * weight;

	} // end nodes loop

	
      } // end force calcs

      // compute stiffness matrix
      if( f2 ) {
// 	std::cerr << std::endl << std::endl << "\t"
// 		  << "Aaaarrrrrrggggggh!  No stiffness matrix yet!" 
// 		  << std::endl << std::endl;
      }
      
    } // end quadrature loop


    if(f0) {
      double pressure = (_pressureNode==0) ? 0.0 : _pressureNode->point();
      _work = pressure * _volume;

      //double tension = _tensionNode->point();

      //energy by volume and area are done in body
      _energy = _strainEnergy; //- _work + tension * _area;
    }

    if(f1) {
      int a=0, ia=0;
      for(NodeIterator na=_nodes.begin();  na!=_nodes.end(); na++, a++)
	for(int i=0; i<3; i++, ia++) {
	  double f_ia = _internalForce(a)(i) + _pressureForce(a)(i) + _tensionForce(a)(i);
	  (*na)->addForce( i, f_ia );
	}


    }

  }


  template<class Quadrature_t, class Material_t, class Shape_t>
  void C0Membrane<Quadrature_t, Material_t, Shape_t>::updateRefConfiguration( double edgeLength ) {
    for(QuadPointIterator p=_quadPoints.begin(); 
	p!=_quadPoints.end(); p++){
      //
      // compute Shell geometry
      //
			
      // compute basis vector, and derivatives of basis vector
      tvmet::Vector< Vector3D, 2 > a;
      tvmet::Matrix< Vector3D, 2, 2 > aPartials;
      Vector3D zero(0);
      a = zero, zero;
      aPartials = zero, zero, zero, zero;
			
      if( edgeLength > 0.0 ) {
	// this is a hack to treat the reference geometry as if the
	// element were equilateral in a flat sheet.

	if(_nodes.size() == 3) { //triangle
	//
	//     ^ s^2
	//    /
	//   2
	//  / \
	// 0 - 1 --> s^1
	// 
	// X = (1-s^1-s^2)*X_0 + s^1*X_1 + s^2*X_2
	// G_1 = X_{,1} = X_1-X_0
	// G_2 = X_{,2} = X_2-X_0
	//

	a(0) = edgeLength, 0.0, 0.0;
	a(1) = edgeLength*cos(M_PI/3.0), edgeLength*sin(M_PI/3.), 0.0;

	} else if(_nodes.size() == 4) {
	  //
	  //     ^ s2
	  //     |
	  //  3-----2
	  //  |  |  |
	  // ----------> s1
	  //  |  |  |
	  //  0-----1
	  //     |
	  //
	  // A_1 = h/2*( 1, 0)
	  // A_2 = h/2*( 0, 1)
	  a(0) = 0.5*edgeLength, 0.0, 0.0;
	  a(1) = 0.0, 0.5*edgeLength, 0.0;
	}
	
      } else {
	// compute reference geometry correctly by interpolation from
	// the reference coordinates of the nodes
	const typename Shape_t::FunctionContainer & N 
	  = p->shape.functions();
	const typename Shape_t::DerivativeContainer & DN 
	  = p->shape.derivatives();
	
	for (int b = 0; b < _nodes.size(); b++){
	  const DeformationNode<3>::Point & Xb = _nodes[b]->position();
	  a(0) += DN[b](0) * Xb;
	  a(1) += DN[b](1) * Xb;
	}
      }		
	
      Material_t& material = p->material;
      // compute shell geometry
      ShellGeometry refgeometry( a, aPartials );
			
      // store the reference geometry in shell geometry class
      material.setRefGeometry(refgeometry);

      //material.updateState(true, true, true);

    }    
    compute(true,true,true);
    
    return;
  }
   

  template<class Quadrature_t, class Material_t, class Shape_t>
  Vector3D 
  C0Membrane<Quadrature_t, Material_t, Shape_t>::
  computePosition(const double s1, const double s2)
  {
    //CornerValences v(6,6,6);
    tvmet::Vector<unsigned int, 3> v(6,6,6);
    Array1D paraCoords(2);
    paraCoords = s1, s2;
    const int nodes = v(0) + v(1) + v(2) - 6;
    //
    // create a loop shell shape function object
    Shape_t shp( paraCoords );
    //
    // new position
    Vector3D pos(0.0);
    NodeIterator p = _nodes.begin();
    for(; p != _nodes.end(); p ++){
      const int i = std::distance(_nodes.begin(), p);
      pos += shp.functions()(i) * (*p)->point();
    }
		
    return pos;
  }

} // namespace voom
